{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to my narcissistic corner on the Net. I work as Principal Engineer for Hedvig, a Commvault Venture, and as an Associate Professor for the Computer Science Faculty @ Federal University of Uberl\u00e2ndia, where I co-founded the Distributed Systems and Networks research group . Previously I have also worked for Microsoft as a Software Development Engineer on the Active Directory and BPOS, where I wrote code that run in the MS identity related cloud and in the most deployed directory service in the world. I received my PhD from IC/Unicamp, Brazil, and USI, Switzerland, where I worked under the supervision of Profs. Edmundo Madeira and Fernando Pedone. As a PhD student I was a member of the Sprint project on high performance database replication. In general, I like working on interesting problems and so far I've found plenty of them in distributed computing. If you want to know more about my research, please follow the link on the left pane. Email me at lasaro at ufu dot br","title":"About"},{"location":"publications/","text":"I am a computer scientist working on the design and implementation of large scale distributed systems including, but not limited to, P2P systems, Network Protocols, and Agreement Problems. I enjoy reasoning about concurrency in large scale systems and the challenges it brings to achieving consistency. The following is an incomplete list of my publications. As time allows I will complete it and add details. In the mean time, if you need more information, please visit Research Gate , your favorite academic search engine, or contact me directly. Journals Multicoordinated agreement for groups of agents Lasaro Camargos, Rodrigo Schmidt, Edmundo R. M. Madeira, Fernando Pedone Journal of the Brazilian Computer Society PDF Abstract Agents in agreement protocols play well distinct roles. Proposers propose values to the acceptors, which will accept proposals and inform the learners so they detect that an agreement has been reached. A fourth role is that of the coordinator, who filters the proposals from proposers to acceptors. While proposers, learners, and coordinators are easily replaced, substituting an acceptor is prohibitive. Protocols that do not employ a coordinator are less resilient to acceptor failures. Protocols that use one coordinator are more resilient to acceptor failures, at the expense of one extra communication step even in the absence of failures. Moreover, they require replacing the coordinator as soon as it fails, a reconfiguration that, although relatively inexpensive, diminishes the protocol availability. Hence, either option, i.e, one or zero coordinator, has its drawbacks. In previous works, we have presented an alternative: multicoordinated agreement protocols. Such protocols are as resilient as single-coordinated protocols but require less reconfiguration to cope with coordinator failures. In fact, most reconfiguration can be done in parallel to the execution of the protocol's normal steps. Multicoordination can be applied to several problems. In this paper we exemplify its use in solving consensus and then introduce a fast multicoordinated agreement protocol for agents organized in groups, an abstraction for fast local area networks interconnected by slower links. A game theoretical approach to model the channel selection dynamics in non-coordinated IEEE 802.11 networks S\u00e9rgio L. D. L. Gramacho, Gustavo B. Figueiredo, Lasaro Camargos Wireless Networks PDF Abstract The massive deployment of Wireless Local Area Networks has made interference mitigation between neighboring networks a challenging issue. These uncoordinated access networks aim at improving their operation by choosing the best wireless channel available, characterizing a competition over the restricted set of possible channels. This work analyses this competition using Game Theory and Markov Chains models, showing that such competitive behavior can lead to Nash Equilibria and that outcomes mostly will not be maximal. Additionally, partially and fully cooperative models are proposed and evaluated, allowing (a) individual players to increase global results using arbitrarily computed and non-rational moves, and (b) achieving maximal outcomes when considering the cooperation of up to all players. Analysis of Monitoring and Multipath Support on top of OpenFlow Specification Pedro Rezende, Paulo R. S. L. Coelho, Luiz F. Faina, Lasaro Camargos, Rafael Pasquini International Journal of Network Management PDF Abstract In general, traffic is pushed through a single path despite the existence of alternative paths in networks. For example, routing solutions based on spanning tree prune the topology to prevent loops, consequently preventing also the use of alternative paths. Research on quality of service frequently advocates that the use of alternative paths is interesting for enforcing Service Level Agreements (SLAs), bypassing bottlenecks created by shortest paths. In this paper, we are interested in analyzing the support for monitoring network traffic and for provisioning of multipaths in software\u2010defined networking (SDN), given the strong platform it provides for experimentation of new networked solutions. Our approach firstly enriches the topology view at the control plane with data gathered through fine grain data plane monitoring. On the basis of such enriched view, our system determines the path, or multipaths, necessary to enforce the specified SLA. We propose 2 extension modules to an OpenFlow controller: SDNMon, which monitors the data plane to enrich the topology information at the control plane, and MP\u2010Routing, which determines a set of paths, in the absence of a single path capable of enforcing the SLA. Both modules are extensively evaluated, and the results not only demonstrate what can be achieved in terms of accuracy in SDNMon and in terms of quality of service benefits in MP\u2010Routing but also highlight some limitations of OpenFlow specification. On the basis of our findings, we propose a set of new counters to Per Port and Per Flow granularity levels of OpenFlow specification. Book Chapters Byzantine Collision-Fast Consensus Protocols Rodrigo Saramago, Eduardo Alchieri, Tuanir Rezende, Lasaro Camargos Transactions on Computational Collective Intelligence XXXIII PDF Abstract Atomic broadcast protocols are fundamental building blocks used in the construction of many reliable distributed systems. Atomic broadcast and consensus are equivalent problems, but the inefficiency of consensus-based atomic broadcast protocols in the presence of collisions (concurrent proposals) harms their adoption in the implementation of reliable systems, as the ones based on state machine replication. In the traditional consensus protocols, proposals that are not decided in some instance of consensus (commands not delivered) must be re-proposed in a new instance, delaying their execution. Moreover, whether different values (commands) are proposed in the same instance (leading to a collision), some of its phases must be restarted, also delaying the execution of these commands involved in the collision. The CFABCast (Collision-Fast Atomic Broadcast) algorithm uses m-consensus to decide and deliver multiple values in the same instance. However, CFABCast is not byzantine fault-tolerant, a requirement for many systems. Our first contribution is a modified version of CFABCast to handle byzantine failures. Unfortunately, the resulting protocol is not collision-fast due to the possibility of malicious failures. In fact, our second contribution is to prove that there are no byzantine collision-fast algorithms in an asynchronous model as traditionally extended to solve consensus. Finally, our third contribution is a byzantine collision-fast algorithm that bypasses the stated impossibility by means of a USIG (Unique Sequential Identifier Generator) trusted component. Peer-reviewed Conferences Priority-Based State Machine Replication with PRaxos Paulo R. Pinho Filho, Luciana De Oliveira Rech, Lau Cheuk Lung, Miguel Correia, L\u00e1saro Camargos 2016 IEEE 30 th International Conference on Advanced Information Networking and Applications (AINA) PDF Abstract State machine replication is a form of active replication commonly used to create fault-tolerant distributed services. In a nutshell, the approach consists in ensuring that a set of replicas receive and execute the same sequence of deterministic requests, returning the same results. This approach handles all requests evenly, but for some services it is important to consider that some requests have priority over others, i.e., that whenever two or more requests are ready to be executed, the one with higher priority is executed first. Paxos is perhaps the best known protocol to order requests in asynchronous environments, but Paxos has no notion of priority. In this paper we introduce the notion of priority-based state machine replication and modify Paxos to take request priorities into account. The proposed algorithm, PRaxos, works in three steps and satisfies Paxos' safety properties in asynchronous systems, while enforcing priorities when the system behaves synchronously. An Architecture for Monitoring and Improving Public Transportation Systems Pedro H. S. Duarte, Luis F. Faina, L\u00e1saro Camargos, Luciano B. de Paula, Rafael Pasquini 2016 IEEE 30 th International Conference on Advanced Information Networking and Applications (AINA), Crans-Montana, Switzerland PDF Abstract Brazilian public transportation systems are facing a significant demand reduction, mainly due to the poor quality of the offered services, lack of information regarding lines and timetables, high cost and lack of investment from the government. Even though it is not trivial to improve financial aspects related to the public transportation system, this work claims that the overall system quality can be improved through ubiquitous data collection according to a proposed ontology, which is the basis for knowledge extraction to support the required quality of experience improvements. The proposed architecture relies on standard technologies available nowadays, providing a low cost solution for the required data collection and analysis. This paper presents the proposed inter-networking architecture and ontology, then evaluates the system performance using a prototype developed with standard solutions. An Architecture for Traffic Sign Management in Smart Cities Everton Lira, Enrique Fynn, Paulo R. S. L. Coelho, Luis F Faina, Lasaro Camargos, Rodolfo S. Villaca, Rafael Pasquini 2016 IEEE 30 th International Conference on Advanced Information Networking and Applications (AINA), Crans-Montana, Switzerland PDF Abstract This paper introduces and evaluates a Traffic SignManagement Architecture (TSMA), which represents a paradigmshift for the deployment of traffic sign infrastructure in thecontext of Intelligent Transport Systems, Vehicular Networks andSmart Cities. The proposal addresses limitations of the currenttraffic control model by enabling remote updates of traffic signsand displaying them on the vehicular navigation system displayto improve their legibility. TSMA is an architecture developedto provide V2I interaction using a commodity technology, Wi-Fi, through the beacon-stuffing technique. The initial design ofTSMA\u2019s security mechanisms is also presented in this paper.Evaluations were performed on a developed prototype andsimulation environments. AR2C2 - Actively Replicated Controllers for SDN resilient Control Planes Eros S. Spalla, Diego Rossi Mafioletti, Alextian Bartolomeu Liberato, Gilberto Ewald, Christian Esteve Rothenberg, L\u00e1saro Camargos, Rodolfo Villaca, Magnos Martinello NOMS 2016 - 2016 IEEE/IFIP Network Operations and Management Symposium PDF Abstract Software Defined Networking (SDN) is a promisingarchitectural approach based on a programmatic separation ofthe control and data planes. For high availability purposes,logically centralized SDN controllers follow a distributed im-plementation. While controller role features in the OpenFlowprotocol allow switches to communicate with multiple controllers,these mechanisms alone are not sufficient to guarantee a resilientcontrol plane, leaving the actual implementation an open chal-lenge for SDN designers. This paper explores OpenFlow roles forthe design of resilient SDN control plane and proposes AR2C2as an actively replicated multi-controller strategy. As proof ofconcept, AR2C2 is implemented based on the Ryu controllerand relying on OpenReplica to ensure consistent state amongthe distributed controllers. Our prototype is experimentallyevaluated using real commodity switches and Mininet emulatedenvironment. Results of the measured times to recover fromfailures for different workloads shed some light on the practicaltrade-offs on replication overhead and latency as a step forwardtowards SDN resiliency. Roteamento Multicaminhos em Redes Definidas por Software Pedro Rezende, Luis Fernando Faina, L\u00e1saro Camargos, Rafael Pasquini XXXIV Simp\u00f3sio Brasileiro de Redes de Computadores e Sistemas Distribu\u00eddos, Salvador, Brazil PDF Replica\u00e7\u00e3o de M\u00e1quina de Estado Baseada em Prioridade com PRaft Paulo R. Pinho Filho, Luciana Rech, Lau Cheuk Lung, Miguel Correia, L\u00e1saro Camargos XXXIV Simp\u00f3sio Brasileiro de Redes de Computadores e Sistemas Distribu\u00eddos, Salvador, Brazil PDF Abstract State machine replication is an approach to create fault tolerant dis-tributed systems. The system remains corret while tolerating faults from someof its replicas. These replicas must execute the same sequence of requests, aproblem that is solved by total order algorithsm like Raft. some services mayneed that requests have different priority levels, such that some be executed be-fore others. In this work, we propose an algorithm, PRaft, that introduces theidea of priority based state machine replication to Raft, modifying it to deal withrequest priority. Busca por Similaridade no CassandraDB Antonio Mour\u00e3o, Rafael Pasquini, Rodolfo Villa\u00e7a, L\u00e1saro Camargos 31 st Brazilian Symposium on Databases PDF Abstract The need for scalability in the Big Data era has lead to flourishing of distributed NOSQL systems. However, none of the widely used solutions available support similarity searches, another important feature in such scenarios. Here we propose to overcome this limitation by extending Cassandra with similarity search capabilities. Our approach is based on using locality sensitive hashing to spread data to nodes, to target nodes for queries, and for efficiently recovering similar data from stable storage at the nodes. We overview how to implement the approach, our test plan, and initial results. Resumo. A necessidade de escalabilidade em cen\u00e1rios de Big Data levou \u00e0 prospera\u00e7\u00e3o dos NOSQL distribu\u00eddos. Contudo, as solu\u00e7\u00f5es mais amplamente usadas n\u00e3o suportam uma outra caracter\u00edstica desej\u00e1vel, busca por similari-dade. Neste artigo propomos contornar tal limita\u00e7\u00e3o estendendo o Cassandra com suporte a buscas por dados similares. Nossa abordagem usa hashing sens\u00ed-vel \u00e0 localidade para distribuir dados entre n\u00f3s, direcionar buscas, e recuperar dados em armazenamento est\u00e1vel de forma eficiente. Descrevemos aqui como implementar esta abordagem, nosso plano de testes e resultados iniciais. Introdu\u00e7\u00e3o Cassandra [Lakshman and Malik 2010] \u00e9 um banco de dados NOSQL (Not Only SQL) amplamente utilizado em cen\u00e1rios BigData devido \u00e0 sua escalabilidade horizontal. Como em outros NOSQL [Decandia et al. 2007, Chang et al. 2008], essa caracter\u00edstica vem do consistent hashing, particionamento aleat\u00f3rio dos dados entre os n\u00f3s do sistema que dis-tribui a carga uniformemente entre os mesmos e facilita sua entrada e sa\u00edda do sistema [Stoica et al. 2001]. Apesar das vantagens, essa distribui\u00e7\u00e3o dificulta a busca por dados similares, outra caracter\u00edstica desej\u00e1vel em BigData. Dois objetos de um mesmo dom\u00ednio s\u00e3o similares se seus atributos possuem um grau de semelhan\u00e7a elevado; caso contr\u00e1rio s\u00e3o dissimilares. A busca por similaridade consiste em recuperar objetos que sejam similares aos par\u00e2metros da consulta. Alguns exemplos incluem a identifica\u00e7\u00e3o de perfis de clientes com h\u00e1bitos de consumo parecidos e de imagens com o mesmo tema. Dentre alguns esfor\u00e7os para se melhorar a busca por similaridade nestes sistemas, destacamos a HammingDHT [Villaca et al. 2013]. Na HammingDHT, a chave de cada objeto \u00e9 constru\u00edda por uma fun\u00e7\u00e3o de espa-lhamento sens\u00edvel a localidade (LSH), que gera chaves similares para dados similares e ???++ \" Agradecimentos \u00e0 CAPES, CNPq, FAPEMIG e FAPES pelo apoio \u00e0 realiza\u00e7\u00e3o deste trabalho. Algoritmo de Difusao Atomica Rapido a Despeito de Colisoes Tolerante a Falhas Bizantinas Rodrigo Saramago, Eduardo Ad\u00edlio Pelinson Alchieri, Tuanir Fran\u00e7a Rezende, L\u00e1saro Camargos XXXV Simp\u00f3sio Brasileiro de Redes de Computadores e Sistemas Distribu\u00eddos (SBRC), Belem, PA, Brazil PDF Abstract The inefficiency of Consensus-based Atomic Broadcast protocols inthe presence of collisions (concurrent proposals) harms their adoption in theimplementation of State Machine Replication. Proposals that are not decidedin some instance of Consensus (commands not delivered) must be reproposed ina new instance, delaying their execution. The CFABCast algorithm (Collision-Fast Atomic Broadcast) uses M-Consensus, a Consensus variant, to decide anddeliver multiple values in the same instance. However, CFABCast is not By-zantine fault tolerant, a requirement for many systems. Our first contributionis a variation CFABCast that handles Byzantine failures. Unfortunately, the re-sulting protocol is not collison-fast due to the possibility of Byzantine failures.In fact, our second contribution is the conjecture that there are no Byzantinecollision-fast algorithm in the asynchronous model. Finally, our third contri-bution is a Byzantine collision-fast algorithm that bypasses our impossibilityconjecture by using the USIG (Unique Sequential Identifier Generator) trustedcomponent. On Making Generalized Paxos Practical Tuanir Fran\u00e7a Rezende, Pierre Sutra, Rodrigo Saramago, L\u00e1saro Camargos The 31 st IEEE International Conference on Advanced Information Networking and Applications (IEEE AINA-2017) PDF Abstract Generalized Paxos, GPaxos, is a recent solution to Generalized Consensus, a distributed problem to which several key agreement problems reduce. We envision that GPaxos may unify within a single and novel Agreement-as-a-Service infrastructure multiple distributed protocols. To date this potential is however not fully unleashed, due to the steep learning curve of the protocol and the high complexity of its implementation.Moreover, before GPaxos reaches a real world usage, several computationally expensive operations have to be optimized and simplified. This paper aims at closing this gap between theory and practice. To this end, we first provide a concise tour of Generalized Paxos, hardly found elsewhere. Then, we assess the versatility of the Generalized Consensus problem by presenting a variation of GPaxos that solves the lease coordination problem. Our last contribution consists in three optimizations that apply to the critical phases of the algorithm: i) a method to quickly start a new round, ii) a novel approach to execute a checkpoint, and iii) a data structure that speeds-up the detection of an agreement. On the Impossibility of Byzantine Collision-Fast Atomic Broadcast Rodrigo Saramago, Tuanir Fran\u00e7a Rezende, Eduardo Ad\u00edlio Pelinson Alchieri, Lasaro Camargos The 32 nd IEEE International Conference on Advanced Information Networking and Applications (IEEE AINA-2018), Krakow, Poland PDF Abstract The inefficiency of Consensus-based Atomic Broadcast protocols in the presence of collisions (concurrent proposals) harms their adoption in the implementation of State Machine Replication. Proposals that are not decided in some instance of Consensus (commands not delivered) must be re-proposed in a new instance, delaying their execution. The CFABCast (Collision-Fast Atomic Broadcast) algorithm uses M-Consensus to decide and deliver multiple values in the same instance. However, CFABCast is not Byzantine fault-tolerant, a requirement for many systems. Our first contribution is a modified version of CFABCast to handle Byzantine failures. Unfortunately, the resulting protocol is not collision-fast due to the possibility of malicious failures. In fact, our second contribution is to prove that there are no Byzantine collision-fast algorithms in an asynchronous model as traditionally extended to solve Consensus. Finally, our third contribution is a Byzantine collision-fast algorithm that bypasses the stated impossibility by means of a USIG (Unique Sequential Identifier Generator) trusted component. Peer-reviewed Workshop Mechanism Reduction via Adjacency Matrix Power L\u00e1saro Camargos, Jo\u00e3o Marcelo Vedovoto, Ricardo Serfaty, Aristeu da Silveira Neto 5 th International Workshop on Model Reduction in Reacting Flows (IWMRRF 2015), Spreewald, Germany PDF Abstract Mechanism reduction is badly needed in large scale chemical simulations. Most graph based approaches, such as Directed Relation Graphs, derive the dependency of a species on all the others using single paths between them, which is not optimal. But since calculating the optimal solution has prohibitive costs, in this paper we propose the use of all the paths of a given large size to approximate the dependency. Comutador P4 com Suporte a Roteamento Multicaminhos Lucas Borges Fernandes, Pedro Henrique Ribeiro, Leonardo Martins, Rafael Pasquini, Luis F. Faina, Lasaro Camargos IX Workshop de Pesquisa Experimental da Internet do Futuro (WPEIF 2018) PDF Abstract In this paper we describe a network switch with multi-path routing capabilities. The switch is implemented using P4, easily extensible and available as a free software project. The switch supports different routing policies, which adhere to different levels of QoS, making the network use very flexible. Thesis MSc Thesis - DisCusS desenvolvendo um Servi\u00e7o de Consenso gen\u00e9rico, simples e modular Lasaro Camargos State university of Campinas PDF Abstract Esta disserta\u00e7\u00e3o trata do processo de engenharia de um servi\u00e7o de detec\u00e7\u00e3o de falhas compat\u00edvel com FT-CORBA, a especifica\u00e7\u00e3o para toler\u00e2ncia a falhas em CORBA, e de um servi\u00e7co de consenso distribu\u00eddo. Os servi\u00e7oos s\u00e3o independentes e fornecem diferentes propriedades para a aplica\u00e7\u00e3o cliente, dependendo dos m\u00f3dulos, com implementa\u00e7\u00f5es de algoritmos diferentes, selecionados para uma instancia\u00e7\u00e3o destes servi\u00e7os. A arquitetura dos servi\u00e7os \u00e9 tal que a aplica\u00e7\u00e3o cliente n\u00e3o toma conhecimento dos algoritmos de detec\u00e7\u00e3o e consenso sendo executados, acessando-os por uma interface gen\u00e9rica. Com o intuito de facilitar a escolha dos m\u00f3dulos dos servi\u00e7os, apresentamos um pequeno estudo comparativo da influ\u00eancia de detectores de falhas adaptativos, aqueles que se adaptam para prover melhor qualidade de servi\u00e7o na detec\u00e7\u00e3o, e n\u00e3o adaptativos sobre o desempenho dos algoritmos de consenso distribu\u00eddo. PhD Dissertation - Multicoordinated agreement protocols and the log service Lasaro Camargos Universit\u00e0 della Svizzera Italiana and State university of Campinas PDF Abstract Agreement problems are a common abstraction in distributed systems. They appear when the components of the system must concur on reconfigurations, changes of state, or in lines of action in general. Examples of agreement problems are Consensus, Atomic Commitment, and Atomic Broadcast. In this thesis we investigate these abstractions in the context of the environment in which they will run and the applications that they will serve; in general, we consider the asynchronous crash-recovery model. The goal is to devise protocols that explore the contextual information to deliver improved availability. The correctness of our protocols holds even when the extra assumptions do not. In the first part of this thesis we explore the following property: messages broadcast in small networks tend to be delivered in order and reliably. We make three contributions in this part. The first contribution is to turn known Consensus algorithms that harness this ordering property to reach agreement in the crash-stop model into practical protocols. That is, protocols that tolerate message losses and recovery after crashes, efficiently. Our protocols ensure progress even in the presence of failures, if spontaneous ordering holds frequently. In the absence of spontaneous ordering, some other assumption is required to cope with failures. The second contribution of this thesis is to generalize one of our crash-recovery consensus protocols as a ``multicoordinated'' mode of a hybrid Consensus protocol, that may use spontaneous ordering or failure detection to progress. Compared to other protocols, ours provide improved availability with no price in resilience. The third contribution is to employ this new mode to solve Generalized Consensus, a problem that generalizes a series of other agreement problems and, hence, is of much practical interest. Moreover, we considered several aspects of solving this problem in practice, which had not been considered before. As a result, our Generalized Consensus protocol features graceful degradation, load balancing, and is parsimonious in accessing stable storage. In the second part of this thesis we have considered agreement problems in wide area networks organized hierarchically. More specifically, we considered a topology that is commonplace in the data centers of large corporations: groups of nodes, with large-bandwidth low-latency links connecting the nodes in the same group, and slow and limited links connecting nodes in different groups. In such environments, latency is clearly a major concern and reconfiguration procedures that render the agreement protocol momentarily unavailable must be avoided as much as possible. Our contribution here is in avoiding reconfigurations and improving the availability of a collision fast agreement protocol. That is, a protocol that can reach agreement in two intergroup communication steps, irrespectively to concurrent proposals. Besides the use of a multicoordinated approach, we employed multicast primitives and consensus to restrict some reconfigurations to within groups, where they are less expensive. In the last part of this thesis we study the problem of terminating distributed transactions. The problem consists of enforcing agreement among the parties on whether to commit or rollback the transaction and ensuring the durability of committed transactions. Our contribution in this topic is an abstract log service that detaches the termination problem from the processes actually performing the transactions. The service works as a black box and abstracts its implementation details from the application utilizing it. Moreover, it allows slow and failed resource managers be re-started on different hosts without relying on the stable storage of the previous host. We provide two implementations of the service, which we evaluated experimentally.","title":"Research"},{"location":"publications/#journals","text":"Multicoordinated agreement for groups of agents Lasaro Camargos, Rodrigo Schmidt, Edmundo R. M. Madeira, Fernando Pedone Journal of the Brazilian Computer Society PDF Abstract Agents in agreement protocols play well distinct roles. Proposers propose values to the acceptors, which will accept proposals and inform the learners so they detect that an agreement has been reached. A fourth role is that of the coordinator, who filters the proposals from proposers to acceptors. While proposers, learners, and coordinators are easily replaced, substituting an acceptor is prohibitive. Protocols that do not employ a coordinator are less resilient to acceptor failures. Protocols that use one coordinator are more resilient to acceptor failures, at the expense of one extra communication step even in the absence of failures. Moreover, they require replacing the coordinator as soon as it fails, a reconfiguration that, although relatively inexpensive, diminishes the protocol availability. Hence, either option, i.e, one or zero coordinator, has its drawbacks. In previous works, we have presented an alternative: multicoordinated agreement protocols. Such protocols are as resilient as single-coordinated protocols but require less reconfiguration to cope with coordinator failures. In fact, most reconfiguration can be done in parallel to the execution of the protocol's normal steps. Multicoordination can be applied to several problems. In this paper we exemplify its use in solving consensus and then introduce a fast multicoordinated agreement protocol for agents organized in groups, an abstraction for fast local area networks interconnected by slower links. A game theoretical approach to model the channel selection dynamics in non-coordinated IEEE 802.11 networks S\u00e9rgio L. D. L. Gramacho, Gustavo B. Figueiredo, Lasaro Camargos Wireless Networks PDF Abstract The massive deployment of Wireless Local Area Networks has made interference mitigation between neighboring networks a challenging issue. These uncoordinated access networks aim at improving their operation by choosing the best wireless channel available, characterizing a competition over the restricted set of possible channels. This work analyses this competition using Game Theory and Markov Chains models, showing that such competitive behavior can lead to Nash Equilibria and that outcomes mostly will not be maximal. Additionally, partially and fully cooperative models are proposed and evaluated, allowing (a) individual players to increase global results using arbitrarily computed and non-rational moves, and (b) achieving maximal outcomes when considering the cooperation of up to all players. Analysis of Monitoring and Multipath Support on top of OpenFlow Specification Pedro Rezende, Paulo R. S. L. Coelho, Luiz F. Faina, Lasaro Camargos, Rafael Pasquini International Journal of Network Management PDF Abstract In general, traffic is pushed through a single path despite the existence of alternative paths in networks. For example, routing solutions based on spanning tree prune the topology to prevent loops, consequently preventing also the use of alternative paths. Research on quality of service frequently advocates that the use of alternative paths is interesting for enforcing Service Level Agreements (SLAs), bypassing bottlenecks created by shortest paths. In this paper, we are interested in analyzing the support for monitoring network traffic and for provisioning of multipaths in software\u2010defined networking (SDN), given the strong platform it provides for experimentation of new networked solutions. Our approach firstly enriches the topology view at the control plane with data gathered through fine grain data plane monitoring. On the basis of such enriched view, our system determines the path, or multipaths, necessary to enforce the specified SLA. We propose 2 extension modules to an OpenFlow controller: SDNMon, which monitors the data plane to enrich the topology information at the control plane, and MP\u2010Routing, which determines a set of paths, in the absence of a single path capable of enforcing the SLA. Both modules are extensively evaluated, and the results not only demonstrate what can be achieved in terms of accuracy in SDNMon and in terms of quality of service benefits in MP\u2010Routing but also highlight some limitations of OpenFlow specification. On the basis of our findings, we propose a set of new counters to Per Port and Per Flow granularity levels of OpenFlow specification.","title":"Journals"},{"location":"publications/#book-chapters","text":"Byzantine Collision-Fast Consensus Protocols Rodrigo Saramago, Eduardo Alchieri, Tuanir Rezende, Lasaro Camargos Transactions on Computational Collective Intelligence XXXIII PDF Abstract Atomic broadcast protocols are fundamental building blocks used in the construction of many reliable distributed systems. Atomic broadcast and consensus are equivalent problems, but the inefficiency of consensus-based atomic broadcast protocols in the presence of collisions (concurrent proposals) harms their adoption in the implementation of reliable systems, as the ones based on state machine replication. In the traditional consensus protocols, proposals that are not decided in some instance of consensus (commands not delivered) must be re-proposed in a new instance, delaying their execution. Moreover, whether different values (commands) are proposed in the same instance (leading to a collision), some of its phases must be restarted, also delaying the execution of these commands involved in the collision. The CFABCast (Collision-Fast Atomic Broadcast) algorithm uses m-consensus to decide and deliver multiple values in the same instance. However, CFABCast is not byzantine fault-tolerant, a requirement for many systems. Our first contribution is a modified version of CFABCast to handle byzantine failures. Unfortunately, the resulting protocol is not collision-fast due to the possibility of malicious failures. In fact, our second contribution is to prove that there are no byzantine collision-fast algorithms in an asynchronous model as traditionally extended to solve consensus. Finally, our third contribution is a byzantine collision-fast algorithm that bypasses the stated impossibility by means of a USIG (Unique Sequential Identifier Generator) trusted component.","title":"Book Chapters"},{"location":"publications/#peer-reviewed-conferences","text":"Priority-Based State Machine Replication with PRaxos Paulo R. Pinho Filho, Luciana De Oliveira Rech, Lau Cheuk Lung, Miguel Correia, L\u00e1saro Camargos 2016 IEEE 30 th International Conference on Advanced Information Networking and Applications (AINA) PDF Abstract State machine replication is a form of active replication commonly used to create fault-tolerant distributed services. In a nutshell, the approach consists in ensuring that a set of replicas receive and execute the same sequence of deterministic requests, returning the same results. This approach handles all requests evenly, but for some services it is important to consider that some requests have priority over others, i.e., that whenever two or more requests are ready to be executed, the one with higher priority is executed first. Paxos is perhaps the best known protocol to order requests in asynchronous environments, but Paxos has no notion of priority. In this paper we introduce the notion of priority-based state machine replication and modify Paxos to take request priorities into account. The proposed algorithm, PRaxos, works in three steps and satisfies Paxos' safety properties in asynchronous systems, while enforcing priorities when the system behaves synchronously. An Architecture for Monitoring and Improving Public Transportation Systems Pedro H. S. Duarte, Luis F. Faina, L\u00e1saro Camargos, Luciano B. de Paula, Rafael Pasquini 2016 IEEE 30 th International Conference on Advanced Information Networking and Applications (AINA), Crans-Montana, Switzerland PDF Abstract Brazilian public transportation systems are facing a significant demand reduction, mainly due to the poor quality of the offered services, lack of information regarding lines and timetables, high cost and lack of investment from the government. Even though it is not trivial to improve financial aspects related to the public transportation system, this work claims that the overall system quality can be improved through ubiquitous data collection according to a proposed ontology, which is the basis for knowledge extraction to support the required quality of experience improvements. The proposed architecture relies on standard technologies available nowadays, providing a low cost solution for the required data collection and analysis. This paper presents the proposed inter-networking architecture and ontology, then evaluates the system performance using a prototype developed with standard solutions. An Architecture for Traffic Sign Management in Smart Cities Everton Lira, Enrique Fynn, Paulo R. S. L. Coelho, Luis F Faina, Lasaro Camargos, Rodolfo S. Villaca, Rafael Pasquini 2016 IEEE 30 th International Conference on Advanced Information Networking and Applications (AINA), Crans-Montana, Switzerland PDF Abstract This paper introduces and evaluates a Traffic SignManagement Architecture (TSMA), which represents a paradigmshift for the deployment of traffic sign infrastructure in thecontext of Intelligent Transport Systems, Vehicular Networks andSmart Cities. The proposal addresses limitations of the currenttraffic control model by enabling remote updates of traffic signsand displaying them on the vehicular navigation system displayto improve their legibility. TSMA is an architecture developedto provide V2I interaction using a commodity technology, Wi-Fi, through the beacon-stuffing technique. The initial design ofTSMA\u2019s security mechanisms is also presented in this paper.Evaluations were performed on a developed prototype andsimulation environments. AR2C2 - Actively Replicated Controllers for SDN resilient Control Planes Eros S. Spalla, Diego Rossi Mafioletti, Alextian Bartolomeu Liberato, Gilberto Ewald, Christian Esteve Rothenberg, L\u00e1saro Camargos, Rodolfo Villaca, Magnos Martinello NOMS 2016 - 2016 IEEE/IFIP Network Operations and Management Symposium PDF Abstract Software Defined Networking (SDN) is a promisingarchitectural approach based on a programmatic separation ofthe control and data planes. For high availability purposes,logically centralized SDN controllers follow a distributed im-plementation. While controller role features in the OpenFlowprotocol allow switches to communicate with multiple controllers,these mechanisms alone are not sufficient to guarantee a resilientcontrol plane, leaving the actual implementation an open chal-lenge for SDN designers. This paper explores OpenFlow roles forthe design of resilient SDN control plane and proposes AR2C2as an actively replicated multi-controller strategy. As proof ofconcept, AR2C2 is implemented based on the Ryu controllerand relying on OpenReplica to ensure consistent state amongthe distributed controllers. Our prototype is experimentallyevaluated using real commodity switches and Mininet emulatedenvironment. Results of the measured times to recover fromfailures for different workloads shed some light on the practicaltrade-offs on replication overhead and latency as a step forwardtowards SDN resiliency. Roteamento Multicaminhos em Redes Definidas por Software Pedro Rezende, Luis Fernando Faina, L\u00e1saro Camargos, Rafael Pasquini XXXIV Simp\u00f3sio Brasileiro de Redes de Computadores e Sistemas Distribu\u00eddos, Salvador, Brazil PDF Replica\u00e7\u00e3o de M\u00e1quina de Estado Baseada em Prioridade com PRaft Paulo R. Pinho Filho, Luciana Rech, Lau Cheuk Lung, Miguel Correia, L\u00e1saro Camargos XXXIV Simp\u00f3sio Brasileiro de Redes de Computadores e Sistemas Distribu\u00eddos, Salvador, Brazil PDF Abstract State machine replication is an approach to create fault tolerant dis-tributed systems. The system remains corret while tolerating faults from someof its replicas. These replicas must execute the same sequence of requests, aproblem that is solved by total order algorithsm like Raft. some services mayneed that requests have different priority levels, such that some be executed be-fore others. In this work, we propose an algorithm, PRaft, that introduces theidea of priority based state machine replication to Raft, modifying it to deal withrequest priority. Busca por Similaridade no CassandraDB Antonio Mour\u00e3o, Rafael Pasquini, Rodolfo Villa\u00e7a, L\u00e1saro Camargos 31 st Brazilian Symposium on Databases PDF Abstract The need for scalability in the Big Data era has lead to flourishing of distributed NOSQL systems. However, none of the widely used solutions available support similarity searches, another important feature in such scenarios. Here we propose to overcome this limitation by extending Cassandra with similarity search capabilities. Our approach is based on using locality sensitive hashing to spread data to nodes, to target nodes for queries, and for efficiently recovering similar data from stable storage at the nodes. We overview how to implement the approach, our test plan, and initial results. Resumo. A necessidade de escalabilidade em cen\u00e1rios de Big Data levou \u00e0 prospera\u00e7\u00e3o dos NOSQL distribu\u00eddos. Contudo, as solu\u00e7\u00f5es mais amplamente usadas n\u00e3o suportam uma outra caracter\u00edstica desej\u00e1vel, busca por similari-dade. Neste artigo propomos contornar tal limita\u00e7\u00e3o estendendo o Cassandra com suporte a buscas por dados similares. Nossa abordagem usa hashing sens\u00ed-vel \u00e0 localidade para distribuir dados entre n\u00f3s, direcionar buscas, e recuperar dados em armazenamento est\u00e1vel de forma eficiente. Descrevemos aqui como implementar esta abordagem, nosso plano de testes e resultados iniciais. Introdu\u00e7\u00e3o Cassandra [Lakshman and Malik 2010] \u00e9 um banco de dados NOSQL (Not Only SQL) amplamente utilizado em cen\u00e1rios BigData devido \u00e0 sua escalabilidade horizontal. Como em outros NOSQL [Decandia et al. 2007, Chang et al. 2008], essa caracter\u00edstica vem do consistent hashing, particionamento aleat\u00f3rio dos dados entre os n\u00f3s do sistema que dis-tribui a carga uniformemente entre os mesmos e facilita sua entrada e sa\u00edda do sistema [Stoica et al. 2001]. Apesar das vantagens, essa distribui\u00e7\u00e3o dificulta a busca por dados similares, outra caracter\u00edstica desej\u00e1vel em BigData. Dois objetos de um mesmo dom\u00ednio s\u00e3o similares se seus atributos possuem um grau de semelhan\u00e7a elevado; caso contr\u00e1rio s\u00e3o dissimilares. A busca por similaridade consiste em recuperar objetos que sejam similares aos par\u00e2metros da consulta. Alguns exemplos incluem a identifica\u00e7\u00e3o de perfis de clientes com h\u00e1bitos de consumo parecidos e de imagens com o mesmo tema. Dentre alguns esfor\u00e7os para se melhorar a busca por similaridade nestes sistemas, destacamos a HammingDHT [Villaca et al. 2013]. Na HammingDHT, a chave de cada objeto \u00e9 constru\u00edda por uma fun\u00e7\u00e3o de espa-lhamento sens\u00edvel a localidade (LSH), que gera chaves similares para dados similares e ???++ \" Agradecimentos \u00e0 CAPES, CNPq, FAPEMIG e FAPES pelo apoio \u00e0 realiza\u00e7\u00e3o deste trabalho. Algoritmo de Difusao Atomica Rapido a Despeito de Colisoes Tolerante a Falhas Bizantinas Rodrigo Saramago, Eduardo Ad\u00edlio Pelinson Alchieri, Tuanir Fran\u00e7a Rezende, L\u00e1saro Camargos XXXV Simp\u00f3sio Brasileiro de Redes de Computadores e Sistemas Distribu\u00eddos (SBRC), Belem, PA, Brazil PDF Abstract The inefficiency of Consensus-based Atomic Broadcast protocols inthe presence of collisions (concurrent proposals) harms their adoption in theimplementation of State Machine Replication. Proposals that are not decidedin some instance of Consensus (commands not delivered) must be reproposed ina new instance, delaying their execution. The CFABCast algorithm (Collision-Fast Atomic Broadcast) uses M-Consensus, a Consensus variant, to decide anddeliver multiple values in the same instance. However, CFABCast is not By-zantine fault tolerant, a requirement for many systems. Our first contributionis a variation CFABCast that handles Byzantine failures. Unfortunately, the re-sulting protocol is not collison-fast due to the possibility of Byzantine failures.In fact, our second contribution is the conjecture that there are no Byzantinecollision-fast algorithm in the asynchronous model. Finally, our third contri-bution is a Byzantine collision-fast algorithm that bypasses our impossibilityconjecture by using the USIG (Unique Sequential Identifier Generator) trustedcomponent. On Making Generalized Paxos Practical Tuanir Fran\u00e7a Rezende, Pierre Sutra, Rodrigo Saramago, L\u00e1saro Camargos The 31 st IEEE International Conference on Advanced Information Networking and Applications (IEEE AINA-2017) PDF Abstract Generalized Paxos, GPaxos, is a recent solution to Generalized Consensus, a distributed problem to which several key agreement problems reduce. We envision that GPaxos may unify within a single and novel Agreement-as-a-Service infrastructure multiple distributed protocols. To date this potential is however not fully unleashed, due to the steep learning curve of the protocol and the high complexity of its implementation.Moreover, before GPaxos reaches a real world usage, several computationally expensive operations have to be optimized and simplified. This paper aims at closing this gap between theory and practice. To this end, we first provide a concise tour of Generalized Paxos, hardly found elsewhere. Then, we assess the versatility of the Generalized Consensus problem by presenting a variation of GPaxos that solves the lease coordination problem. Our last contribution consists in three optimizations that apply to the critical phases of the algorithm: i) a method to quickly start a new round, ii) a novel approach to execute a checkpoint, and iii) a data structure that speeds-up the detection of an agreement. On the Impossibility of Byzantine Collision-Fast Atomic Broadcast Rodrigo Saramago, Tuanir Fran\u00e7a Rezende, Eduardo Ad\u00edlio Pelinson Alchieri, Lasaro Camargos The 32 nd IEEE International Conference on Advanced Information Networking and Applications (IEEE AINA-2018), Krakow, Poland PDF Abstract The inefficiency of Consensus-based Atomic Broadcast protocols in the presence of collisions (concurrent proposals) harms their adoption in the implementation of State Machine Replication. Proposals that are not decided in some instance of Consensus (commands not delivered) must be re-proposed in a new instance, delaying their execution. The CFABCast (Collision-Fast Atomic Broadcast) algorithm uses M-Consensus to decide and deliver multiple values in the same instance. However, CFABCast is not Byzantine fault-tolerant, a requirement for many systems. Our first contribution is a modified version of CFABCast to handle Byzantine failures. Unfortunately, the resulting protocol is not collision-fast due to the possibility of malicious failures. In fact, our second contribution is to prove that there are no Byzantine collision-fast algorithms in an asynchronous model as traditionally extended to solve Consensus. Finally, our third contribution is a Byzantine collision-fast algorithm that bypasses the stated impossibility by means of a USIG (Unique Sequential Identifier Generator) trusted component.","title":"Peer-reviewed Conferences"},{"location":"publications/#peer-reviewed-workshop","text":"Mechanism Reduction via Adjacency Matrix Power L\u00e1saro Camargos, Jo\u00e3o Marcelo Vedovoto, Ricardo Serfaty, Aristeu da Silveira Neto 5 th International Workshop on Model Reduction in Reacting Flows (IWMRRF 2015), Spreewald, Germany PDF Abstract Mechanism reduction is badly needed in large scale chemical simulations. Most graph based approaches, such as Directed Relation Graphs, derive the dependency of a species on all the others using single paths between them, which is not optimal. But since calculating the optimal solution has prohibitive costs, in this paper we propose the use of all the paths of a given large size to approximate the dependency. Comutador P4 com Suporte a Roteamento Multicaminhos Lucas Borges Fernandes, Pedro Henrique Ribeiro, Leonardo Martins, Rafael Pasquini, Luis F. Faina, Lasaro Camargos IX Workshop de Pesquisa Experimental da Internet do Futuro (WPEIF 2018) PDF Abstract In this paper we describe a network switch with multi-path routing capabilities. The switch is implemented using P4, easily extensible and available as a free software project. The switch supports different routing policies, which adhere to different levels of QoS, making the network use very flexible.","title":"Peer-reviewed Workshop"},{"location":"publications/#thesis","text":"MSc Thesis - DisCusS desenvolvendo um Servi\u00e7o de Consenso gen\u00e9rico, simples e modular Lasaro Camargos State university of Campinas PDF Abstract Esta disserta\u00e7\u00e3o trata do processo de engenharia de um servi\u00e7o de detec\u00e7\u00e3o de falhas compat\u00edvel com FT-CORBA, a especifica\u00e7\u00e3o para toler\u00e2ncia a falhas em CORBA, e de um servi\u00e7co de consenso distribu\u00eddo. Os servi\u00e7oos s\u00e3o independentes e fornecem diferentes propriedades para a aplica\u00e7\u00e3o cliente, dependendo dos m\u00f3dulos, com implementa\u00e7\u00f5es de algoritmos diferentes, selecionados para uma instancia\u00e7\u00e3o destes servi\u00e7os. A arquitetura dos servi\u00e7os \u00e9 tal que a aplica\u00e7\u00e3o cliente n\u00e3o toma conhecimento dos algoritmos de detec\u00e7\u00e3o e consenso sendo executados, acessando-os por uma interface gen\u00e9rica. Com o intuito de facilitar a escolha dos m\u00f3dulos dos servi\u00e7os, apresentamos um pequeno estudo comparativo da influ\u00eancia de detectores de falhas adaptativos, aqueles que se adaptam para prover melhor qualidade de servi\u00e7o na detec\u00e7\u00e3o, e n\u00e3o adaptativos sobre o desempenho dos algoritmos de consenso distribu\u00eddo. PhD Dissertation - Multicoordinated agreement protocols and the log service Lasaro Camargos Universit\u00e0 della Svizzera Italiana and State university of Campinas PDF Abstract Agreement problems are a common abstraction in distributed systems. They appear when the components of the system must concur on reconfigurations, changes of state, or in lines of action in general. Examples of agreement problems are Consensus, Atomic Commitment, and Atomic Broadcast. In this thesis we investigate these abstractions in the context of the environment in which they will run and the applications that they will serve; in general, we consider the asynchronous crash-recovery model. The goal is to devise protocols that explore the contextual information to deliver improved availability. The correctness of our protocols holds even when the extra assumptions do not. In the first part of this thesis we explore the following property: messages broadcast in small networks tend to be delivered in order and reliably. We make three contributions in this part. The first contribution is to turn known Consensus algorithms that harness this ordering property to reach agreement in the crash-stop model into practical protocols. That is, protocols that tolerate message losses and recovery after crashes, efficiently. Our protocols ensure progress even in the presence of failures, if spontaneous ordering holds frequently. In the absence of spontaneous ordering, some other assumption is required to cope with failures. The second contribution of this thesis is to generalize one of our crash-recovery consensus protocols as a ``multicoordinated'' mode of a hybrid Consensus protocol, that may use spontaneous ordering or failure detection to progress. Compared to other protocols, ours provide improved availability with no price in resilience. The third contribution is to employ this new mode to solve Generalized Consensus, a problem that generalizes a series of other agreement problems and, hence, is of much practical interest. Moreover, we considered several aspects of solving this problem in practice, which had not been considered before. As a result, our Generalized Consensus protocol features graceful degradation, load balancing, and is parsimonious in accessing stable storage. In the second part of this thesis we have considered agreement problems in wide area networks organized hierarchically. More specifically, we considered a topology that is commonplace in the data centers of large corporations: groups of nodes, with large-bandwidth low-latency links connecting the nodes in the same group, and slow and limited links connecting nodes in different groups. In such environments, latency is clearly a major concern and reconfiguration procedures that render the agreement protocol momentarily unavailable must be avoided as much as possible. Our contribution here is in avoiding reconfigurations and improving the availability of a collision fast agreement protocol. That is, a protocol that can reach agreement in two intergroup communication steps, irrespectively to concurrent proposals. Besides the use of a multicoordinated approach, we employed multicast primitives and consensus to restrict some reconfigurations to within groups, where they are less expensive. In the last part of this thesis we study the problem of terminating distributed transactions. The problem consists of enforcing agreement among the parties on whether to commit or rollback the transaction and ensuring the durability of committed transactions. Our contribution in this topic is an abstract log service that detaches the termination problem from the processes actually performing the transactions. The service works as a black box and abstracts its implementation details from the application utilizing it. Moreover, it allows slow and failed resource managers be re-started on different hosts without relying on the stable storage of the previous host. We provide two implementations of the service, which we evaluated experimentally.","title":"Thesis"},{"location":"students/","text":"MSc Lucas Borges Rodrigo Videschi Jos\u00e9 Augusto Bolina Douglas Antunes - Generalized Consensus (Alumnus, 2019) Lucas Marchesotti Franco - Uma solu\u00e7\u00e3o for\u00e7a-bruta para o problema de minimiza\u00e7\u00e3o de HandOvers Intra-VPON utilizando Teoria dos Grafos(Alumnus, 2018) Tuanir Fran\u00e7a Rezende - A Faithful Generalized Paxos Implementation and a Novel CStruct for Distributed Lease Coordination (Alumnus, 2017) Pedro Henrique Amorim Rezende - Extens\u00f5es na arquitetura SDN para o provisionamento de QoS atrav\u00e9s do monitoramento e uso de m\u00faltiplos caminhos (Advisor: Rafael Pasquini, Alumnus, 2016) Rodrigo Queiroz Saramago - Implementa\u00e7\u00e3o e Avalia\u00e7\u00e3o de Protocolos de Difus\u00e3o R\u00e1pida \u00e0 Despeito de Colis\u00f5es (Alumnus, 2016) Enrique Fynn - Previs\u00e3o eficiente do posicionamento futuro de n\u00f3s em redes m\u00f3veis (Alumnus, 2015) Lucas Vela - Adv.: Pedro Frosi. Uma abordagem complementar \u00e0 tradu\u00e7\u00e3o de endere\u00e7os para conectividade transparente (Advisor: Pedro Frosi, Alumnus, 2012) Ant\u00f4nio Mour\u00e3o (Alumnus) S\u00e9rgio P\u00edter (Alumnus) Cleber Zacarias J\u00fanior (Alumnus) Pedro Augusto da Silva Reis (Alumnus) Caio Orthu (Alumnus) Matheus Scharf (Alumnus) Undergrad Pedro Victor (Alumnus) Jos\u00e9 Augusto Bolina - Next gen networks (Alumnus, 2019) Pedro Henrique - Descoberta de Comutadores em Redes Definidas por Software Usando P4 (Alumnus, 2018) Lucas Borges - Roteamento multicaminhos em redes definidas por software usando p4 (Alumnus, 2017) Leonardo Martins - Next gen networks (Alumnus, 2017) Daniel Thales - Ferramenta para Edi\u00e7\u00e3o e Visualizaliza\u00e7\u00e3o de Rastros de Execu\u00e7\u00e3o de Sistemas Distribu\u00eddos (Alumnus, 2016) T\u00falio Alves - Use of Parallel Processing in the Spectral Method for Computational Fluid Dynamics (Alumnus, 20195 Jo\u00e3o Pedro Ferreira - CPX: Classroom P2P Experience (Alumnus, 2015) Samuel Henrique Ferreira - Toler\u00e2ncia a Falhas de Controladores OpenFlow via Espa\u00e7o de Tuplas (Alumnus, 2015) Patrick Godinho - Access point mobility traces collection for next place forecast verification. (Alumnus, 2015) \u00c1lvaro Pereira - Uso de IdTrees como Mecanismo de Endere\u00e7amento para a Internet do Futuro (Alumnus, 2014) T\u00falio Gomes - Using OpenStack for Distributed Systems Experimentation (Alumnus, 2013) Julia Carol Arduini (Alumna)","title":"Students"},{"location":"students/#msc","text":"Lucas Borges Rodrigo Videschi Jos\u00e9 Augusto Bolina Douglas Antunes - Generalized Consensus (Alumnus, 2019) Lucas Marchesotti Franco - Uma solu\u00e7\u00e3o for\u00e7a-bruta para o problema de minimiza\u00e7\u00e3o de HandOvers Intra-VPON utilizando Teoria dos Grafos(Alumnus, 2018) Tuanir Fran\u00e7a Rezende - A Faithful Generalized Paxos Implementation and a Novel CStruct for Distributed Lease Coordination (Alumnus, 2017) Pedro Henrique Amorim Rezende - Extens\u00f5es na arquitetura SDN para o provisionamento de QoS atrav\u00e9s do monitoramento e uso de m\u00faltiplos caminhos (Advisor: Rafael Pasquini, Alumnus, 2016) Rodrigo Queiroz Saramago - Implementa\u00e7\u00e3o e Avalia\u00e7\u00e3o de Protocolos de Difus\u00e3o R\u00e1pida \u00e0 Despeito de Colis\u00f5es (Alumnus, 2016) Enrique Fynn - Previs\u00e3o eficiente do posicionamento futuro de n\u00f3s em redes m\u00f3veis (Alumnus, 2015) Lucas Vela - Adv.: Pedro Frosi. Uma abordagem complementar \u00e0 tradu\u00e7\u00e3o de endere\u00e7os para conectividade transparente (Advisor: Pedro Frosi, Alumnus, 2012) Ant\u00f4nio Mour\u00e3o (Alumnus) S\u00e9rgio P\u00edter (Alumnus) Cleber Zacarias J\u00fanior (Alumnus) Pedro Augusto da Silva Reis (Alumnus) Caio Orthu (Alumnus) Matheus Scharf (Alumnus)","title":"MSc"},{"location":"students/#undergrad","text":"Pedro Victor (Alumnus) Jos\u00e9 Augusto Bolina - Next gen networks (Alumnus, 2019) Pedro Henrique - Descoberta de Comutadores em Redes Definidas por Software Usando P4 (Alumnus, 2018) Lucas Borges - Roteamento multicaminhos em redes definidas por software usando p4 (Alumnus, 2017) Leonardo Martins - Next gen networks (Alumnus, 2017) Daniel Thales - Ferramenta para Edi\u00e7\u00e3o e Visualizaliza\u00e7\u00e3o de Rastros de Execu\u00e7\u00e3o de Sistemas Distribu\u00eddos (Alumnus, 2016) T\u00falio Alves - Use of Parallel Processing in the Spectral Method for Computational Fluid Dynamics (Alumnus, 20195 Jo\u00e3o Pedro Ferreira - CPX: Classroom P2P Experience (Alumnus, 2015) Samuel Henrique Ferreira - Toler\u00e2ncia a Falhas de Controladores OpenFlow via Espa\u00e7o de Tuplas (Alumnus, 2015) Patrick Godinho - Access point mobility traces collection for next place forecast verification. (Alumnus, 2015) \u00c1lvaro Pereira - Uso de IdTrees como Mecanismo de Endere\u00e7amento para a Internet do Futuro (Alumnus, 2014) T\u00falio Gomes - Using OpenStack for Distributed Systems Experimentation (Alumnus, 2013) Julia Carol Arduini (Alumna)","title":"Undergrad"},{"location":"teaching/gbc074gsi028/","text":"Pr\u00f3logo As \u00e1reas ligadas ao desenvolvimentos de sistemas computacionais, como Ci\u00eancia e Engenharia de Computa\u00e7\u00e3o e Sistemas de Informa\u00e7\u00e3o, est\u00e3o extremamente em voga e tem atra\u00eddo mais e mais profissionais, mais ou menos qualificados, tornando este mercado cada vez mais competitivo . Ter conhecimentos espec\u00edficos da sub\u00e1rea de desenvolvimento de sistemas distribu\u00eddos e pode ser uma excelente vantagem e forma de se destacar de seus colegas e competidores, mesmo que voc\u00ea nunca tenha ouvido falar em sistemas distribu\u00eddos at\u00e9 ter que se matricular nesta disciplina. Sendo sincero, o desenvolvimento da teoria da computa\u00e7\u00e3o distribu\u00edda , na forma do estudo de algoritmos e t\u00e9cnicas de implementa\u00e7\u00e3o, e sua coloca\u00e7\u00e3o em pr\u00e1tica, na forma do desenvolvimento de sistemas distribu\u00eddos, n\u00e3o \u00e9 t\u00e3o \"quente\" como outras \u00e1reas, por exemplo intelig\u00eancia artificial e ci\u00eancia de dados. Mas acontece que sem a computa\u00e7\u00e3o distribu\u00edda, nenhum desenvolvimento s\u00e9rio destas outras \u00e1reas, sedentas por desempenho, escalaria para problemas reais. Veja por exemplo a seguinte descri\u00e7\u00e3o dos skills necess\u00e1rios para atuar como cientista de dados ou como engenheiro no Facebook . \u00c9 fato que aplica\u00e7\u00f5es distribu\u00eddos s\u00e3o importantes por j\u00e1 serem parte inexpurg\u00e1vel da infraestrutura computacional que usamos. Se j\u00e1 estiver convencido de que esta \u00e9 uma \u00e1rea importante, \u00f3timo! Se n\u00e3o estiver, s\u00f3 te pe\u00e7o que d\u00ea uma chance ao t\u00f3pico e leia mais um pouco, pois neste curso apesentaremos uma vis\u00e3o geral do que s\u00e3o sistemas distribu\u00eddos, porqu\u00eas t\u00e9cnicos para os desenvolvemos e como faz\u00ea-lo, com uma forte componente pr\u00e1tica, por meio do desenvolvimento de um projeto com (um dos) p\u00e9s na realidade, ou seja, s\u00f3 coisas super divertidas. Como exatamente faremos isso? Come\u00e7aremos por uma revis\u00e3o de conceitos de redes de computadores e sistemas operacionais enquanto falamos sobre a arquitetura mais fundamental de computa\u00e7\u00e3o distribu\u00edda, Cliente/Servidor, e de como \u00e9 usada para implementar um proto banco de dados distribu\u00eddo, uma Tabela de Espalhamento Distribu\u00edda em mem\u00f3ria. \u00c0 medida em que apresentamos problemas com o modelo assumido inicialmente e com nossa implementa\u00e7\u00e3o inicial, buscaremos por solu\u00e7\u00f5es enquanto introduzimos novas abstra\u00e7\u00f5es, mais poderosas e mais complexas. Ao final desta jornada, teremos fundamentado a constru\u00e7\u00e3o de uma Tabela de Espalhamento Distribu\u00eddo com particionamento de dados entre n\u00f3s, usando protocolos par-a-par e replica\u00e7\u00e3o de m\u00e1quinas de estados. Em paralelo, teremos estudado diversos frameworks de computa\u00e7\u00e3o distribu\u00edda atuais, como modelo ou bloco de constru\u00e7\u00e3o para a resolu\u00e7\u00e3o de nossos problemas. Se voc\u00ea ainda n\u00e3o est\u00e1 convencido, bem, voc\u00ea n\u00e3o tem muita escolha, n\u00e3o \u00e9 mesmo? Ent\u00e3o tente aproveitar esta vis\u00e3o geral para praticar um pouco de programa\u00e7\u00e3o neuro-ligu\u00edstica e repita o seguinte mantra: heeeeeeeuuuuummmmmm amo computa\u00e7\u00e3o distribu\u00edda. Brincadeiras a parte, voc\u00ea desenvolver\u00e1 um projeto em v\u00e1rias etapas que lhe permitir\u00e1 exercitar os conceitos vistos aqui e que te levar\u00e1 a: programar processos que se comuniquem via redes de computadores; conhecer arquiteturas cl\u00e1ssicas de sistemas distribu\u00eddos (e.g, cliente/servidor, p2p e h\u00edbrida), seus usos e limita\u00e7\u00f5es; escrever programas multithreaded simples e a entender como o uso de multithreading afeta os componentes de um sistema distribu\u00eddo; entender a problem\u00e1tica da coordena\u00e7\u00e3o e do controle de concorr\u00eancia em sistemas distribu\u00eddos; entender o uso de sistemas de nomea\u00e7\u00e3o em sistemas distribu\u00eddos bem como diversas formas de se implementar tais sistemas de nomea\u00e7\u00e3o; entender os conceitos b\u00e1sicos de replica\u00e7\u00e3o e toler\u00e2ncia a falhas; entender as implica\u00e7\u00f5es da dessincroniza\u00e7\u00e3o de rel\u00f3gios na coordena\u00e7\u00e3o, replica\u00e7\u00e3o e toler\u00e2ncia a falhas; projetar sistemas com componentes geograficamente distantes, fracamente acoplados; entender onde os diversos middleware podem ser usados para acoplar tais componentes; conhecer v\u00e1rias t\u00e9cnicas que controle de concorr\u00eancia controlar o acesso a um recurso compartilhado; Estas notas, em sua forma atual, s\u00e3o fortemente baseadas no livro Distributed Systems: Principles and Paradigms 1 , mas tamb\u00e9m em alguns materiais mais recentes dispon\u00edveis livremente na Internet. Refer\u00eancias s\u00e3o apontadas em links nas notas de rodap\u00e9. Refer\u00eancias para imagens s\u00e3o dadas como links nas pr\u00f3prias imagens. Aten\u00e7\u00e3o! Para navegar no material, utilize o menu \u00e0 esquerda para Cap\u00edtulos, \u00e0 direita para se\u00e7\u00f5es, ou os bot\u00f5es abaixo para Anterior e Pr\u00f3ximo. TODO Tipografia: Clarificar uso de diferentes fontes. Caixas: Clarificar uso de caixas como esta. Gerar lista de material referenciado no final p\u00e1gina em vez de em links embutidos. Distributed Systems: Principles and Paradigms \u21a9","title":"Pr\u00f3logo"},{"location":"teaching/gbc074gsi028/#prologo","text":"As \u00e1reas ligadas ao desenvolvimentos de sistemas computacionais, como Ci\u00eancia e Engenharia de Computa\u00e7\u00e3o e Sistemas de Informa\u00e7\u00e3o, est\u00e3o extremamente em voga e tem atra\u00eddo mais e mais profissionais, mais ou menos qualificados, tornando este mercado cada vez mais competitivo . Ter conhecimentos espec\u00edficos da sub\u00e1rea de desenvolvimento de sistemas distribu\u00eddos e pode ser uma excelente vantagem e forma de se destacar de seus colegas e competidores, mesmo que voc\u00ea nunca tenha ouvido falar em sistemas distribu\u00eddos at\u00e9 ter que se matricular nesta disciplina. Sendo sincero, o desenvolvimento da teoria da computa\u00e7\u00e3o distribu\u00edda , na forma do estudo de algoritmos e t\u00e9cnicas de implementa\u00e7\u00e3o, e sua coloca\u00e7\u00e3o em pr\u00e1tica, na forma do desenvolvimento de sistemas distribu\u00eddos, n\u00e3o \u00e9 t\u00e3o \"quente\" como outras \u00e1reas, por exemplo intelig\u00eancia artificial e ci\u00eancia de dados. Mas acontece que sem a computa\u00e7\u00e3o distribu\u00edda, nenhum desenvolvimento s\u00e9rio destas outras \u00e1reas, sedentas por desempenho, escalaria para problemas reais. Veja por exemplo a seguinte descri\u00e7\u00e3o dos skills necess\u00e1rios para atuar como cientista de dados ou como engenheiro no Facebook . \u00c9 fato que aplica\u00e7\u00f5es distribu\u00eddos s\u00e3o importantes por j\u00e1 serem parte inexpurg\u00e1vel da infraestrutura computacional que usamos. Se j\u00e1 estiver convencido de que esta \u00e9 uma \u00e1rea importante, \u00f3timo! Se n\u00e3o estiver, s\u00f3 te pe\u00e7o que d\u00ea uma chance ao t\u00f3pico e leia mais um pouco, pois neste curso apesentaremos uma vis\u00e3o geral do que s\u00e3o sistemas distribu\u00eddos, porqu\u00eas t\u00e9cnicos para os desenvolvemos e como faz\u00ea-lo, com uma forte componente pr\u00e1tica, por meio do desenvolvimento de um projeto com (um dos) p\u00e9s na realidade, ou seja, s\u00f3 coisas super divertidas. Como exatamente faremos isso? Come\u00e7aremos por uma revis\u00e3o de conceitos de redes de computadores e sistemas operacionais enquanto falamos sobre a arquitetura mais fundamental de computa\u00e7\u00e3o distribu\u00edda, Cliente/Servidor, e de como \u00e9 usada para implementar um proto banco de dados distribu\u00eddo, uma Tabela de Espalhamento Distribu\u00edda em mem\u00f3ria. \u00c0 medida em que apresentamos problemas com o modelo assumido inicialmente e com nossa implementa\u00e7\u00e3o inicial, buscaremos por solu\u00e7\u00f5es enquanto introduzimos novas abstra\u00e7\u00f5es, mais poderosas e mais complexas. Ao final desta jornada, teremos fundamentado a constru\u00e7\u00e3o de uma Tabela de Espalhamento Distribu\u00eddo com particionamento de dados entre n\u00f3s, usando protocolos par-a-par e replica\u00e7\u00e3o de m\u00e1quinas de estados. Em paralelo, teremos estudado diversos frameworks de computa\u00e7\u00e3o distribu\u00edda atuais, como modelo ou bloco de constru\u00e7\u00e3o para a resolu\u00e7\u00e3o de nossos problemas. Se voc\u00ea ainda n\u00e3o est\u00e1 convencido, bem, voc\u00ea n\u00e3o tem muita escolha, n\u00e3o \u00e9 mesmo? Ent\u00e3o tente aproveitar esta vis\u00e3o geral para praticar um pouco de programa\u00e7\u00e3o neuro-ligu\u00edstica e repita o seguinte mantra: heeeeeeeuuuuummmmmm amo computa\u00e7\u00e3o distribu\u00edda. Brincadeiras a parte, voc\u00ea desenvolver\u00e1 um projeto em v\u00e1rias etapas que lhe permitir\u00e1 exercitar os conceitos vistos aqui e que te levar\u00e1 a: programar processos que se comuniquem via redes de computadores; conhecer arquiteturas cl\u00e1ssicas de sistemas distribu\u00eddos (e.g, cliente/servidor, p2p e h\u00edbrida), seus usos e limita\u00e7\u00f5es; escrever programas multithreaded simples e a entender como o uso de multithreading afeta os componentes de um sistema distribu\u00eddo; entender a problem\u00e1tica da coordena\u00e7\u00e3o e do controle de concorr\u00eancia em sistemas distribu\u00eddos; entender o uso de sistemas de nomea\u00e7\u00e3o em sistemas distribu\u00eddos bem como diversas formas de se implementar tais sistemas de nomea\u00e7\u00e3o; entender os conceitos b\u00e1sicos de replica\u00e7\u00e3o e toler\u00e2ncia a falhas; entender as implica\u00e7\u00f5es da dessincroniza\u00e7\u00e3o de rel\u00f3gios na coordena\u00e7\u00e3o, replica\u00e7\u00e3o e toler\u00e2ncia a falhas; projetar sistemas com componentes geograficamente distantes, fracamente acoplados; entender onde os diversos middleware podem ser usados para acoplar tais componentes; conhecer v\u00e1rias t\u00e9cnicas que controle de concorr\u00eancia controlar o acesso a um recurso compartilhado; Estas notas, em sua forma atual, s\u00e3o fortemente baseadas no livro Distributed Systems: Principles and Paradigms 1 , mas tamb\u00e9m em alguns materiais mais recentes dispon\u00edveis livremente na Internet. Refer\u00eancias s\u00e3o apontadas em links nas notas de rodap\u00e9. Refer\u00eancias para imagens s\u00e3o dadas como links nas pr\u00f3prias imagens. Aten\u00e7\u00e3o! Para navegar no material, utilize o menu \u00e0 esquerda para Cap\u00edtulos, \u00e0 direita para se\u00e7\u00f5es, ou os bot\u00f5es abaixo para Anterior e Pr\u00f3ximo. TODO Tipografia: Clarificar uso de diferentes fontes. Caixas: Clarificar uso de caixas como esta. Gerar lista de material referenciado no final p\u00e1gina em vez de em links embutidos. Distributed Systems: Principles and Paradigms \u21a9","title":"Pr\u00f3logo"},{"location":"teaching/gbc074gsi028/arch/","text":"Arquiteturas Cliente Servidor Como brevemente discutido em Fundamentos , quando pensamos em termos de comunica\u00e7\u00e3o entre dois processos usando sockets, em geral pensamos em processos clientes e servidores, onde servidores esperam a conex\u00e3o por parte de clientes e executam as opera\u00e7\u00f5es requisitadas pelos mesmos. Como exemplos desta arquitetura, podemos pensar em um navegador requisitando a um servidor Apache que lhe retorne uma p\u00e1gina Web, ou em um aplicativo m\u00f3vel solicitando ao servidor de aplica\u00e7\u00f5es que dispare uma transfer\u00eancia de fundos. Um exemplo gen\u00e9rico \u00e9 apresentado na figura a seguir. sequenceDiagram activate Servidor activate Cliente note left of Servidor: Cria socket e espera por conex\u00f5es deactivate Servidor Cliente->>+Servidor: Connect? note left of Servidor: Aceita conex\u00e3o Servidor->>-Cliente: Connect! note right of Cliente: Ativo (gerando requisi\u00e7\u00e3o) note left of Servidor: Inativo (esperando requisi\u00e7\u00e3o) Cliente->>+Servidor: Request deactivate Cliente note right of Cliente: Inativo (esperando resposta) note left of Servidor: Ativo (processando requisi\u00e7\u00e3o) Servidor-->>-Cliente: Response activate Cliente note right of Cliente: Ativo (processando resposta note left of Servidor: Inativo (esperando requisi\u00e7\u00e3o) deactivate Cliente O modelo cliente/servidor forma a base da computa\u00e7\u00e3o distribu\u00edda, sobre a qual todos os outros modelos s\u00e3o implementados. Uma das raz\u00f5es \u00e9 hist\u00f3rica: os primeiros sistemas a permitirem a opera\u00e7\u00e3o por m\u00faltiplos usu\u00e1rios, ainda na d\u00e9cada de 60, eram compostos de uma host robusto ao qual se conectavam diversos terminais, essencialmente com teclado e monitor, isto \u00e9, um servidor e v\u00e1rios clientes. Com a redu\u00e7\u00e3o dos computadores, surgiram as primeiras redes de computadores e a necessidade de uma abstra\u00e7\u00e3o para o estabelecimento de comunica\u00e7\u00e3o entre processos em hosts distintos, e assim surgiram os sockets . Com os sockets, vem uma grande flexibilidade, pois um processo n\u00e3o precisa saber como o outro manuseia os dados que lhe cabem, desde que siga um protocolo pr\u00e9-estabelecido na comunica\u00e7\u00e3o. Isto \u00e9, processos podem ser implementado em diferentes linguagens, sistemas operacionais e arquiteturas, desde observadas os cuidados necess\u00e1rios para se obter transpar\u00eancia de acesso . Esta flexibilidade \u00e9 a outra raz\u00e3o do sucesso do modelo cliente/servidor, permitindo que clientes se conectem a servidores para usar seus recursos, que podem ser acessados concorrentemente por diversos clientes. Exemplos cotidianos disto s\u00e3o servidores de bancos de dados, de p\u00e1ginas Web e email. De fato, esta flexibilidade permite que diversas aplica\u00e7\u00f5es continuem operando de forma centralizada, com servidores rodando, por exemplo, em mainframes e clientes rodando de forma emulada por software em computadores pessoais. Contudo, em certas situa\u00e7\u00f5es, esta divis\u00e3o entre clientes e servidores pode ser tornar confusa. Primeiro, porqu\u00ea uma vez estabelecida a conex\u00e3o, n\u00e3o h\u00e1 uma diferencia\u00e7\u00e3o entre quem iniciou e quem aceitou a mesma; s\u00e3o apenas duas pontas do mesmo socket. Segundo, pode ser que o servi\u00e7o relevante sendo prestado, seja prestado por quem estabelece a conex\u00e3o. De fato ambos podem estar prestando servi\u00e7os um para o outro, no que \u00e9 conhecido como P2P. Terceiro, um mesmo processo pode atuar tanto como cliente quanto como servidor, no que \u00e9 conhecido como arquitetura multicamadas, tamb\u00e9m a ser visto adiante. Quarto, usando-se sockets como base, podemos construir outros modelos de comunica\u00e7\u00e3o entre processos, efetivamente colocando camadas na nossa cebola. 1 A seguir, exploraremos as arquiteturas constru\u00eddas sobre cliente/servidor. Par-a-Par (Peer-to-Peer, P2P) Nos sistemas que seguem a arquitetura Par-a-Par, ou simplesmente P2P, h\u00e1 uma substitui\u00e7\u00e3o dos pap\u00e9is de clientes e servidores, em que h\u00e1 uma \"hirarquia\" entre os componentes, por uma onde todos os n\u00f3s s\u00e3o pares na execu\u00e7\u00e3o da tarefa em quest\u00e3o. Um exemplo comum destas arquitetura s\u00e3o os sistemas de compartilhamento de arquivos, em que cada n\u00f3 armazena e disponibiliza parte dos dados, bem como acessa os dados disponibilizados por outros n\u00f3s. Como todo sistema distribu\u00eddo, a arquitetura P2P visa agregar poder computacional de m\u00faltiplos n\u00f3s . Mas al\u00e9m disso, pelo n\u00e3o diferencia\u00e7\u00e3o dos componentes, espera-se tolerar falhas de componentes sem paralizar o servi\u00e7o , uma vez que n\u00e3o h\u00e1 um componenente centralizador, detentor \u00fanico de uma certa funcionalidade. Os sistemas P2P tendem portanto a lever a maior disponibilidade. Historicamente, e devido \u00e0s caracter\u00edsticas j\u00e1 mencionadas, os sistemas P2P tem outra caracter\u00edstica muito importante, a alta escalabilidade a que se oferecerem, chegando a n\u00edveis globais. Se pensarmos por exemplo nos sistemas de compartilhamento de arquivos, m\u00fasicas e filmes, raz\u00e3o da fama e inf\u00e2mia da arquitetura, teremos bons exemplos disso. Para que isso seja poss\u00edvel, estes sistemas precisam se tornar auto-gerenci\u00e1veis , pois sistemas globais devem tolerar entrada e sa\u00edda frequente de n\u00f3s (por falhas ou a\u00e7\u00e3o de seus usu\u00e1rios), diferentes dom\u00ednios administrativos , e heterogeneidade na comunica\u00e7\u00e3o. Uma das ferramentas utilizadas para simplificar o trabalho de auto-gerenciamento \u00e9 o conceito de redes sobrepostas . Rede Sobreposta ( Overlay ) Os componentes de um sistema P2P se organizam em uma rede l\u00f3gica, sobreposta \u00e0 rede f\u00edsica. Nesta rede l\u00f3gica, os processos estabelecem canais de comunica\u00e7\u00e3o tipicamente na forma de conex\u00f5es TCP/IP. Por serem ignorantes \u00e0 topologia f\u00edsica da rede e usarem a pilha de comunica\u00e7\u00e3o IP, as redes sobrepostas s\u00e3o mais simples e ao mesmo tempo mais poderosas. Nestas redes s\u00e3o executados diversos algoritmos, como de descoberta de n\u00f3s, roteamento de pacotes e de otimiza\u00e7\u00e3o de rotas pelo descarte e cria\u00e7\u00e3o de conex\u00f5es. Uma vez que as conex\u00f5es na rede sobreposta n\u00e3o correspondem a conex\u00f5es f\u00edsicas, como se pode ver na seguinte figura, vizinhos em um rede sobreposta n\u00e3o necessariamente correspondem a vizinhos na rede f\u00edsica e vice-versa. Isto tamb\u00e9m implica que a otimiza\u00e7\u00e3o da rota l\u00f3gica n\u00e3o necessariamente leva \u00e0 otimiza\u00e7\u00e3o da rota f\u00edsica. Todo A figura n\u00e3o mostra hosts, apenas roteadores. Trocar por figura em com hosts, roteadores, e processos nos hosts. Dependendo em como esta rede \u00e9 organizada (ou n\u00e3o), a mesma \u00e9 classificada como estruturada ou n\u00e3o-estruturada . Rede N\u00e3o-Estruturada Se a rede sobreposta \u00e9 constru\u00edda de forma aleat\u00f3ria, por exemplo deixando os n\u00f3s se conectarem apenas aos vizinhos na rede no ponto em que se conectaram inicialmente, ent\u00e3o esta \u00e9 denominada uma rede n\u00e3o-estruturada . A figura a seguir \u00e9 um exemplo que se percebe que n\u00f3s tem graus diferentes de conectividade e que n\u00e3o est\u00e3o particularmente organizados em nenhuma topologia. Suponha que esta rede seja usada para armazenar e consultar dados. Inser\u00e7\u00f5es de dados podem ser feitas muito rapidamente, armazenando-os no primeiro n\u00f3 dispon\u00edvel encontrado. Os objetos amarelo e vermelho foram inseridos desta forma, e copiados em n\u00f3s pr\u00f3ximos para tolerar a falha de alguns hosts sem perder os dados. Buscas, contudo, ter\u00e3o que vasculhar a rede usando algoritmos como busca em largura , busca em profundidade ou caminhada aleat\u00f3ria (resposta probabil\u00edstica). Rede Estruturada Se as conex\u00f5es s\u00e3o constru\u00eddas e mantidas de forma a gerar uma topologia bem definida, chamamos esta rede de estruturada . Nesta rede, a inser\u00e7\u00e3o de n\u00f3s requer a propaga\u00e7\u00e3o desta informa\u00e7\u00e3o para outros n\u00f3s e a atualiza\u00e7\u00e3o das conex\u00f5es para manter a estrutura. A estrutura geralmente serve ao prop\u00f3sito de associar os n\u00f3s aos dados de uma forma planejada. Por exemplo, n\u00f3s pr\u00f3ximos na rede podem ser respons\u00e1veis por dados logicamente pr\u00f3ximos. Claramente, a inser\u00e7\u00e3o e acesso a dados nesta rede \u00e9 mais custosa, pois independentemente de onde a requisi\u00e7\u00e3o \u00e9 feita, isto \u00e9, a partir de qual n\u00f3, ela dever\u00e1 ser atendida por um n\u00f3 espec\u00edfico. Veja o exemplo do Chord, uma rede P2P em que os n\u00f3s formam um anel l\u00f3gico, cujos detalhes veremos adiante. Cada n\u00f3 \u00e9 respons\u00e1vel pela faixa de valores indexados por chaves entre o identificador do n\u00f3 e o do n\u00f3 anterior. Logo, qualquer inser\u00e7\u00e3o ou consulta de dados, deve ser feita especificamente para um determinado n\u00f3, e deve ser roteada para o mesmo. A estrutura da rede permite que tal roteamento seja feito eficientemente, no n\u00edvel da rede sobreposta. Como outro exemplo considere uma rede em que os n\u00f3s armazenam informa\u00e7\u00f5es sobre os dados de uma certa \u00e1rea geogr\u00e1fica e que n\u00f3s vizinhos na rede sejam aqueles respons\u00e1veis por \u00e1reas que se tocam. Neste exemplo, para se acessar os dados de um certo ponto no mapa, basta rotear a requisi\u00e7\u00e3o para o vizinho mais pr\u00f3ximo do ponto; necessariamente a requisi\u00e7\u00e3o chegar\u00e1 ao n\u00f3 correto. De n\u00e3o estruturada a estruturada A seguinte tabela resume as diferen\u00e7as entre os dois tipos de redes sobrepostas. Estruturada N\u00e3o-Estruturada Estrutura bem definida Estrutura aleat\u00f3ria Adi\u00e7\u00e3o de dados \u00e9 lenta Adi\u00e7\u00e3o de dados \u00e9 r\u00e1pida Adi\u00e7\u00e3o de n\u00f3s \u00e9 lenta Adi\u00e7\u00e3o de n\u00f3s \u00e9 r\u00e1pida Busca por dados \u00e9 r\u00e1pida Busca por dados lenta Mas, e se pud\u00e9ssemos juntar o melhor dos dois mundos em um \u00fanico sistema? Isso \u00e9 poss\u00edvel em certos cen\u00e1rios. Por exemplo, seja uma grade N \\times N N \\times N em que n\u00f3s se conectam aleatoriamente uns aos outros, e que n\u00f3s em uma borda da matriz conseguem se conectar aos n\u00f3s da borda oposta, com dist\u00e2ncia 1. Efetivamente, temos a rede sobreposta \u00e0 esquerda. Se cada n\u00f3 executar o seguinte protocolo, a rede evoluir\u00e1 da topologia n\u00e3o estruturada para a estruturada, \u00e0 direita. Divida a organiza\u00e7\u00e3o da topologia em dois m\u00f3dulos, um de descoberta de novos n\u00f3s e outro de sele\u00e7\u00e3o. O m\u00f3dulo de descoberta, repetidamente, pergunta aos seus vizinhos quem s\u00e3o os seus vizinhos e se conecta aos mesmos. O m\u00f3dulo de sele\u00e7\u00e3o computa a dist\u00e2ncia entre o n\u00f3 e todos os seus vizinhos e descarta as conex\u00f5es com maior dist\u00e2ncia, onde a = (x,y), b = (x', y') a = (x,y), b = (x', y') dx_{a,b} = min(|x - x'|, N - |x - x'|) dx_{a,b} = min(|x - x'|, N - |x - x'|) dy_{a,b} = min(|y - y'|, N - |y - y'|) dy_{a,b} = min(|y - y'|, N - |y - y'|) Ao final de m\u00faltiplas intera\u00e7\u00f5es, cada n\u00f3 ter\u00e1 como seus vizinhos, os n\u00f3s mais pr\u00f3ximos. Se a rede for completa (um n\u00f3 em cada posi\u00e7\u00e3o da grade), os vizinhos ser'\u00e3o os n\u00f3s \u00e0 direita, esquerda, acima e abaixo. A seguinte figura apresenta uma outra rede resultada da aplica\u00e7\u00e3o do mesmo princ\u00edpio, mas em uma \"grade\" 3D. Se em vez da dist\u00e2ncia cartesiana fosse usada a dist\u00e2ncia de Hamming entre os identificadores dos n\u00f3s, ao final das itera\u00e7\u00f5es, a topologia alcan\u00e7ada seria um hyper-cubo, como os da seguinte figura, no qual diversos esquemas de roteamento eficientes podem ser usados . 3 Sistemas P2P Arquitetura decentralizada; N\u00e3o h\u00e1 distin\u00e7\u00e3o de pap\u00e9is entre n\u00f3s ou conjuntos de n\u00f3s desempenham os mesmos pap\u00e9is, em parceria; Escalabilidade geogr\u00e1fica global, isto \u00e9, com n\u00f3s espalhados por todo o globo; Pode haver entrada e sa\u00edda de n\u00f3s do sistema com alta frequ\u00eancia; N\u00f3s se organizam em redes sobrepostas (em ingl\u00eas, overlay ), redes l\u00f3gicas sobre as redes f\u00edsicas; Auto-administra\u00e7\u00e3o. Resiliente a falhas Tabelas de Espalhamento Distribu\u00eddas (DHT) A versatilidade dos sistemas P2P os levaram a ser amplamente estudados e aplicados, sendo que entre as aplica\u00e7\u00f5es mais bem sucedidas est\u00e3o as Tabelas de Espalhamento Distribu\u00edds (DHT, do ingl\u00eas, Distributed Hash Tables ). As tabelas de espalhamento (tamb\u00e9m conhecidas como mapas, dicion\u00e1rios, arrays associativos) tem caracter\u00edsticas que a tornam adequadas ao armazenamento de dados a v\u00e1rios cen\u00e1rios. Em ess\u00eancia, estas tabelas s\u00e3o fun\u00e7\u00f5es que mapeiam uma chave para um valor, uma fun\u00e7\u00e3o f f tal que f(K): V \\cup f(K): V \\cup {null} K K : Universo de chaves V V : Universo de valores isto \u00e9, f(k) = v, k\\in K, v \\in V f(k) = v, k\\in K, v \\in V ou v = v = null. Na pr\u00e1tica, s\u00e3o estruturas de dados adapt\u00e1veis, com um API muito simples, e com opera\u00e7\u00f5es de tempo (mais ou menos) constante para fazer CRUD de pares chave/valor. Tanto K K quanto V V s\u00e3o blobs de dados, isto \u00e9, sem nenhuma forma distinta, e por isso podem ser usadas para resolver uma gama de problemas. API put(k,v) put(k,v) : if k \\rightarrow w k \\rightarrow w then return w w else k \\rightarrow v k \\rightarrow v ; return \\emptyset \\emptyset update(k,v) update(k,v) : if k \\rightarrow w k \\rightarrow w then return w w else return \\emptyset \\emptyset get(k) get(k) : if k \\rightarrow w k \\rightarrow w then return w w else return \\emptyset \\emptyset del(k) del(k) : if k \\rightarrow w k \\rightarrow w then return w w else k \\rightarrow v k \\rightarrow v ; return \\emptyset \\emptyset k k e v v s\u00e3o blobs execu\u00e7\u00e3o O(1) O(1) Se as tabelas de espalhamento s\u00e3o estruturas de dados \u00fateis, uma vers\u00e3o distribu\u00edda seria ainda mais \u00fatil, principalmente porqu\u00ea ela poderia ser tolerante a falhas e ter escalabilidade linear . \u00c9 justamente desta idea que surgem as DHT, literalmente tabelas de espalhamento distribu\u00eddas, estruturas de dados que mant\u00e9m a mesma API e funcionalidades de tabelas de espalhamento, mas que agrega capacidades de diversos hosts . Dentre os desafios na implementa\u00e7\u00e3o de uma DHT est\u00e3o O que usar como chave? Uma DHT deve ser vers\u00e1til para ser utilizada para v\u00e1rios fins, ent\u00e3o a chave precisa ser independente da aplica\u00e7\u00e3o. Como dividir a carga entre hosts? \u00c9 preciso balancear a carga para que um lado da rede n\u00e3o se torne mais importante que o outro e para n\u00e3o levar a uma hierarquiza\u00e7\u00e3o entre os n\u00f3s. Como rotear requisi\u00e7\u00f5es para o host correto? Uma vez que os dados devem ser particionados entre hosts para garantir escalabilidade, como encontrar o n\u00f3 onde determinado dado est\u00e1 or deveria estar? Identifica\u00e7\u00e3o A identifica\u00e7\u00e3o de objetos precisa ser facilmente determin\u00e1vel pela aplica\u00e7\u00e3o para permitir a recupera\u00e7\u00e3o precisa dos dados. Por exemplo, pode-se dividir faixas de nomes entre os processos. A -- C -- Host1 CA -- E -- Host2 EA -- G -- Host3 ... Esta distribui\u00e7\u00e3o tem tr\u00eas problemas graves. O primeiro, \u00e9 no fato de nomes n\u00e3o serem un\u00edvocos . Neste caso, uma exemplo melhor seria o uso do CPF. 000.000.000-00 -- 111.111.111-00 -- Host1 111.111.111-01 -- 222.222.222-00 -- Host2 222.222.222-01 -- 333.333.333-00 -- Host3 ... O segundo problema, presente tamb\u00e9m no uso de CPF, tem a ver com a distribui\u00e7\u00e3o da carga de trabalho entre os hosts. Nem nomes e nem CPF tem distribui\u00e7\u00e3o uniforme, ent\u00e3o alguns n\u00f3s ficariam mais carregados que outros. O terceiro problema tem a ver com o uso de chaves n\u00e3o gen\u00e9ricas, dependentes da aplica\u00e7\u00e3o. Para este problema, poder\u00edamos usar um identificador auto-increment\u00e1vel, por exemplo, mas em muitas situa\u00e7\u00f5es esta abordagem implicaria em dificuldade para se recuperar os dados: \"qual \u00e9 mesmo o identificador num\u00e9rico do livro How Fascism Works ?\" Para resolver estes tr\u00eas problemas, recorremos a uma abordagem usada na literatura da \u00e1rea, dividindo a identifica\u00e7\u00e3o em duas camadas: Seja i i o identificador do objeto, dado pela aplica\u00e7\u00e3o (e.g., CPF, nome, telefone) Seja h h uma fun\u00e7\u00e3o criptogr\u00e1fica Seja k = h(i) k = h(i) o identificador do objeto i i . Divis\u00e3o da carga Se usarmos, por exemplo, MD5, \u00e9 fato que k k tem distribui\u00e7\u00e3o uniforme no espa\u00e7o de 0 a 2^{160}-1 2^{160}-1 poss\u00edveis valores. Para dividirmos os dados entre os hosts tamb\u00e9m uniformemente, distribua os valores entre os hosts em fun\u00e7\u00e3o de k k . Alguns exemplos de divis\u00e3o s\u00e3o: definia buckets para cada host e atribua o dado com chave k k para bucket k \\% b k \\% b , onde b b \u00e9 o n\u00famero de buckets divida a faixa de valores em b b segmentos e atribua a cada host uma faixa dados 2^n 2^n hosts, atribua ao host 0 < x < 2^n-1 0 < x < 2^n-1 os dados cujas chaves terminem com o valor x x . S\u00e3o v\u00e1rias as formas de se dividir os dados e estas est\u00e3o intimamente ligadas \u00e0 rede sobreposta que se pretende montar e a como o roteamento ser\u00e1 feito. Roteamento Para estudar o desafio do roteamento, nas se\u00e7\u00f5es seguintes estudaremos o Chord, um sistema P2P que surgiu no meio acad\u00eamico mas cujo design influenciou fortemente a ind\u00fastria no desenvolvimento dos bancos dados distribu\u00eddos NOSQL, como Cassandra, Dynamo, e Redis. Estudo de Caso: Chord Chord \u00e9 uma sistema P2P de m\u00faltiplas aplica\u00e7\u00f5es desenvolvido pelos membros do CSAIL , do MIT, e publicado em 2001. Desde ent\u00e3o, inspirou diversos outros sistemas, tornando-se sin\u00f4nimo com P2P. Identifica\u00e7\u00e3o No Chord o problema da indentifica\u00e7\u00e3o dos dados \u00e9 resolvido usando-se chaves de m m bits , geradas por meio de uma fun\u00e7\u00e3o hash criptogr\u00e1fica a partir de chaves que fa\u00e7a sentido para a aplica\u00e7\u00e3o, por exemplo nome, telefone, ou CPF. Como a fun\u00e7\u00e3o hash \u00e9 criptogr\u00e1fica, uma pequena varia\u00e7\u00e3o na entrada implica em grande varia\u00e7\u00e3o na sa\u00edda e, para quem observa apenas a sa\u00edda da fun\u00e7\u00e3o, uma sequ\u00eancia de chaves \u00e9 indistingu\u00edvel de uma sequ\u00eancia aleat\u00f3ria. Divis\u00e3o de carga A cada n\u00f3 \u00e9 atribu\u00eddo um identificador \u00fanico de m m bits , gerado aleatoriamente. Como m m normalmente \u00e9 grande, com mais de uma centena de bits, a probabilidade de dois n\u00f3s terem o mesmo identificar \u00e9 desprez\u00edvel. Al\u00e9m disso, os n\u00f3s se organizam em uma rede sobreposta estruturada na forma de um anel l\u00f3gico , em que os n\u00f3s aparecem ordenadamente de acordo com seus identificadores. A figura a seguir mostra um anel em cujo os n\u00f3s tem identificadores de 8 bits (0 a 253), com cinco n\u00f3s. 4 Assumamos inicialmente que os n\u00f3s s\u00f3 est\u00e3o cientes dos seus vizihos imediatos no anel. Cada chave \u00e9 associada a um n\u00f3, respons\u00e1vel por atender requisi\u00e7\u00f5es de cria\u00e7\u00e3o, consulta, modifica\u00e7\u00e3o e remo\u00e7\u00e3o dos dados relacionados \u00e0quela chave. A pseudo aleatoriedade na gera\u00e7\u00e3o da chave e a aleatoriedade na gera\u00e7\u00e3o dos identificadores de n\u00f3s faz com que a distribui\u00e7\u00e3o de carga entre os n\u00f3s seja uniforme. O dado com chave k k \u00e9 responsabilidade do n\u00f3 com menor identificador i \\geq k i \\geq k , aka, sucessor de k k ( i = suc(k) i = suc(k) ), no anel. Na figura a seguir, \u00e9 apresentado junto a cada n\u00f3 as chaves pelas quais o n\u00f3 \u00e9 respons\u00e1vel. Roteamento Suponha que um cliente solicite ao Chord do exemplo anterior que armazene o valor v v associado \u00e0 chave k k . A solicita\u00e7\u00e3o \u00e9 feita pelo contato a um dos n\u00f3s no sistema, que pode ou n\u00e3o ser o respons\u00e1vel por k k . Caso seja o respons\u00e1vel, a solicita\u00e7\u00e3o \u00e9 executada localmente e uma resposta devolvida ao cliente. Caso contr\u00e1rio, a requisi\u00e7\u00e3o deve repassada ou roteada para o n\u00f3 correto. Na rede estruturada definida at\u00e9 agora, uma op\u00e7\u00e3o \u00f3bvia \u00e9 repassar a requisi\u00e7\u00e3o para um dos vizinhos e assim sucessivamente at\u00e9 que alcance o n\u00f3 correto. Esta solu\u00e7\u00e3o, correta, tem custo da ordem do n\u00famero de n\u00f3s no sistema, O(n) O(n) . Em uma inst\u00e2ncia com milhares de n\u00f3s, O(n) O(n) \u00e9 um custo muito alto, ainda mais se considerarmos que cada salto na rede sobreposta potencialmente cruza toda a Internet, uma vez que, refor\u00e7ando, a proximidade na rede sobreposta n\u00e3o implica em proximidade na rede f\u00edsica abaixo. Observe que o custo em termos de espa\u00e7o para se implementar esta solu\u00e7\u00e3o \u00e9 O(1) O(1) para cada n\u00f3 do sistema. Em outras palavras, cada n\u00f3 mantem uma tabela de rotas com uma ou duas entradas, apontando para seus vizinhos. Com uma rede com milhares de n\u00f3s, uma solu\u00e7\u00e3o O(n) O(n) saltos, onde cada pode levar ao outro lado do planeta , opera\u00e7\u00f5es teriam uma lat\u00eancia muito alta. Para amenizar o custo, Chord prop\u00f5e a cria\u00e7\u00e3o de uma tabela de rotas, tamb\u00e9m conhecida como finger-table , que aponta para n\u00f3s no anel com dist\u00e2ncias que se dobram a cada entrada. A finger-table \u00e9 constru\u00edda da seguinte forma, onde m m \u00e9 a quantidade de bits usados para identificar n\u00f3s no sistema: seja F_p F_p a finger-table do processo p p ; seja F_p[i] F_p[i] a i i -\u00e9sima da tabela; e, F_p[i] = suc(p+2^{i-1}) F_p[i] = suc(p+2^{i-1}) . Observe que nesta tabela, a i i -\u00e9sima entrada aponta para o processo que no que sucede p p pelo menos 2^{i-1} 2^{i-1} , e que esta dist\u00e2ncia de sucess\u00e3o aumenta exponencialmente. Observe tamb\u00e9m que a maior dist\u00e2ncia \u00e9 proporcional a metade do tamanho do anel. Isto quer dizer que o \u00faltimo finger da tabela proporciona um salto de 1/2 1/2 anel, o pen\u00faltimo 1/4 1/4 do anel, o ante-pen\u00faltimo 1/8 1/8 , e assim sucessivamente. Outra forma de se ver esta tabela \u00e9 como proporcionando um salto de pelo menos metade da dist\u00e2ncia restante para o n\u00f3 respons\u00e1vel pela chave, resultando em um roteamento com custo O(log n) O(log n) . Mas como este potencial \u00e9 explorado? Usando-se o seguinte algoritmo de busca pela entrada correta na tabela de roteamento, do ponto de vista do processo p p : seja k k a chave para qual estamos procurando o sucessor; itere pela tabela at\u00e9 achar a primeira entrada cujo valor, i.e., o identificador de um n\u00f3, \u00e9 maior que k k ; se a entrada \u00e9 a primeira da tabela, ent\u00e3o encaminhe a requisi\u00e7\u00e3o para o n\u00f3 apontado, pois ele \u00e9 o sucessor de k k , at\u00e9 onde p p consegue determinar; sen\u00e3o, encaminhe a requisi\u00e7\u00e3o para a entrada anterior, pois o n\u00f3 referenciado est\u00e1 mais pr\u00f3ximo do sucessor para determin\u00e1-lo com seguran\u00e7a. Considere no exemplo a seguir a busca pelo sucessor de 26, iniciada pelo n\u00f3 1. Duas observa\u00e7\u00f5es s\u00e3o importantes aqui. A primeira, \u00e9 que as compara\u00e7\u00f5es para se encontrar a entrada correta, deve respeitar o anel, por exemplo, em um anel com 32 posi\u00e7\u00f5es, por exemplo, 31 < 0 31 < 0 . No seguinte exemplo, considere por exemplo a busca que o n\u00f3 21 faz pelo sucessor de 31; qual deve ser a entrada selecionada? A segunda observa\u00e7\u00e3o \u00e9 que n\u00e3o se pode encaminhar a requisi\u00e7\u00e3o diretamente para o n\u00f3 apontado na entrada encontrada, pois a vis\u00e3o de p p pode ser incompleta para partes distantes do anel. Tente identificar exemplos no anel a seguir onde este comportamento seria errado. A organiza\u00e7\u00e3o dos n\u00f3s em um anel virtual e a distribui\u00e7\u00e3o da responsabilidade dos dados pelo particionamento do espa\u00e7o das chaves de forma correspondente \u00e0s faixas no anel l\u00f3gico \u00e9 a t\u00e9cnica conhecida como espalhamento consistente , do ingl\u00eas, consistent hashing . Churn Apesar do espalhamento consistente ser uma t\u00e9cnica muito \u00fatil, ela n\u00e3o resolve todos os problemas. Ali\u00e1s, v\u00e1rios outros problemas precisam ser resolvidos, sendo o primeiro deles lidar com a entrada e sa\u00edda de n\u00f3s, principalmente por falhas de n\u00f3s e comunica\u00e7\u00e3o. Quando um novo n\u00f3 entra do sistema, ele precisa seguir os seguintes passos: Escolher um novo Identificador I I Identificar o sucessor S S de I I Identificar o antecessor A A de I I Informar A A e S S de sua entrada, para que ajustem suas tabelas de rota. A A e S S propagam a informa\u00e7\u00e3o da entrada de I I para seus vizinhos, permitindo que ajustem suas tabelas de rota. Al\u00e9m disto, a reorganiza\u00e7\u00e3o dos n\u00f3s exige movimenta\u00e7\u00e3o de dados, pois parte dos dados armazenados em S S , com chaves menores que I I , precisam ser copiadas para I I , o novo respons\u00e1vel. As principais quest\u00f5es a serem respondidas durante a movimenta\u00e7\u00e3o dos dados s\u00e3o como manter os dados dispon\u00edveis para inser\u00e7\u00e3o e consulta durante todo o processo, e como minimizar o impacto da reorganiza\u00e7\u00e3o nos n\u00f3s vizinhos ao novo n\u00f3 Quanto \u00e0 primeira quest\u00e3o, pode-se rotear as requisi\u00e7\u00f5es para os dois n\u00f3s respons\u00e1veis, o atual e o novo, e combinar as respostas, mantendo os dados mais recentes. Quanto \u00e0 segunda, uma op\u00e7\u00e3o \u00e9 fazer com que cada novo n\u00f3 assuma diversas posi\u00e7\u00f5es no anel, com identificadores distintos, passando a \"incomodar\" m\u00faltiplos processos, mas de forma mais suave. Embora se possa \"facilmente\" resolver os problemas da entrada de n\u00f3s, os da sa\u00edda s\u00e3o mais complexos, principalmente porqu\u00ea a sa\u00edda acontece geralmente bruscamente, por exemplo por falhas no sistema. Quanto \u00e0 reorganiza\u00e7\u00e3o das tabelas de rota, cada n\u00f3 precisa monitorar os n\u00f3s que figuram em sua tabela e, caso pare\u00e7am indispon\u00edveis, ajustar par apontar para outro n\u00f3. Contudo, caso a suspeita seja indevida, isto pode levar a dados serem consultados e armazenados nos n\u00f3s errados. Tamb\u00e9m com rela\u00e7\u00e3o aos dados, h\u00e1 o problema de n\u00e3o perd\u00ea-los quando o n\u00f3 respons\u00e1vel se torna indispon\u00edvel. O tratamento destes problemas est\u00e1 relacionado e \u00e9 feito pelo replica\u00e7\u00e3o dos dados em m\u00faltiplos n\u00f3s. Isto \u00e9 feito no Chord, por exemplo, da seguinte forma: para cada dado, com chave k k , h\u00e1 r r c\u00f3pias; a primeira c\u00f3pia \u00e9 mantida no sucessor de k k ; a segunda c\u00f3pia, no sucessor do sucessor de k k , e assim por diante; cada escrita \u00e9 feita na primeira c\u00f3pia, respondida, e replicada para as demais c\u00f3pias; cada leitura \u00e9 feita na c\u00f3pia com menor identificador. No caso de falha de uma c\u00f3pia, h\u00e1 r-1 r-1 c\u00f3pias ainda dispon\u00edveis para responder \u00e0 requisi\u00e7\u00e3o, mantendo o sistema dispon\u00edvel a despeito de ( r-1 r-1 ) falhas, no que se chama de degrada\u00e7\u00e3o graciosa . H\u00e1 contudo, um problema introduzido por esta abordagem. Assuma a seguinte sequ\u00eancia de passos, em um sistema com r=2 r=2 . escrita na c\u00f3pia 1; resposta ao cliente; replica\u00e7\u00e3o para c\u00f3pia 2; escrita na c\u00f3pia 1; resposta ao cliente; falha da c\u00f3pia 1; leitura na c\u00f3pia 2. O cliente, ao ler o dado, l\u00ea uma vers\u00e3o antiga do mesmo, inconsistente com a vis\u00e3o que tinha do sistema. De fato, este tipo de sistema \u00e9 chamado de eventualmente consistente pois somente na aus\u00eancia de falhas e de escritas as diversas r\u00e9plicas ser\u00e3o consistentes umas com as outras. Continuemos a sequ\u00eancia: escrita na c\u00f3pia 2; c\u00f3pia 1 volta a funcionar; leitura na c\u00f3pia 1. Neste caso, a c\u00f3pia \"secund\u00e1ria\" 2 tem um dado mais atual, que precisa ser repassado para a c\u00f3pia 1; este movimento de converg\u00eancia de dados \u00e9 conhecido como anti-entropia. Finalmente, continuemos a sequ\u00eancia: escrita na c\u00f3pia 1, por outro cliente. Assim, ambas as c\u00f3pias, 1 e 2, tem dados derivados da primeira escrita, mas feitos \"concorrentemente\", um conflito . Qual dos dois \u00e9 o correto neste contexto? \u00c9 imposs\u00edvel apresentar uma estrat\u00e9gia gen\u00e9rica para resolver esta situa\u00e7\u00e3o, mas alguns sistemas usar\u00e3o uma estrat\u00e9gia do tipo \"a \u00faltima escrita vence\", onde a \u00faltima escrita pode ser determinada em por rel\u00f3gios l\u00f3gicos, vetoriais, tempo, e uma pitada de \"arranjo t\u00e9cnico\" para quebrar empates. O Dynamo, que veremos a seguir, \u00e9 um destes sistemas. Espalhamento Consistente Carga uniforme entre n\u00f3s. Todos os n\u00f3s sabem como rotear requisi\u00e7\u00f5es N\u00famero de saltos m\u00e9dio \u00e9 conhecido. O sistema se adapta a entrada e sa\u00edda de n\u00f3s, por falhas ou n\u00e3o. Refer\u00eancias https://www.cs.cmu.edu/~dga/15-744/S07/lectures/16-dht.pdf Estudo de Caso: DynamoDB DynamoDB \u00e9 o marco fundamental dos bancos de dados NoSQL. No v\u00eddeo a seguir um de seus evangelizadores, descreve rapidamente o banco, os cen\u00e1rios em que deveria ser usado e diversos padr\u00f5es de projeto para modelagem de dados. Enquanto o assiste, alguns pontos devem ser ressaltados sobre o Dynamo de forma espec\u00edfica e os NoSQL de forma geral: surgiram da necessidade de escalabilidade dos bancos de dados, isto \u00e9, da necessidade de lidar com milh\u00f5es e milh\u00f5es de entradas de dados, gerados e processados com baixa lat\u00eancia e alta vaz\u00e3o, a despeito de falhas; maior escalabilidade implica em maior exposi\u00e7\u00e3o a particionamentos da rede em que o sistema roda, que associado \u00e0 necessidade de manuten\u00e7\u00e3o de alta disponibilidade, implica em perda de garantias de consist\u00eancia (veremos o Teorema CAP adiante); Partition keys s\u00e3o as chaves usadas para roteamento dos dados, ou seja, as chaves discutidas anteriormente neste cap\u00edtulo sobre sistema P2P; Sort keys s\u00e3o chaves usadas dentro de cada n\u00f3 para ordenar os dados na hora de gerar as SSTables ( String Sorted Tables ), e se usadas em agregados de valores, s\u00e3o equivalentes ao GROUP BY do SQL; Lambda functions s\u00e3o fun\u00e7\u00f5es para processamento de dados executadas em entradas definidas por um pipeline de processamento sem a defini\u00e7\u00e3o expl\u00edcita de sockets e portas, em um modelo conhecido como Serverless . Este modelo \u00e9 adequado a algumas aplica\u00e7\u00f5es, como o carrinho de compras da Amazon.com, aplica\u00e7\u00e3o para a qual o Dynamodb foi inicialmente desenvolvido. Nesta aplica\u00e7\u00e3o, cada usu\u00e1rio tem um identificador \u00fanico , recuperado no momento em que se loga ao sistema da Amazon. Este identificador \u00fanico \u00e9 a chave de particionamento e os dados s\u00e3o o conte\u00fado do carrinho de compras. Para lidar com falhas, o conte\u00fado do carrinho \u00e9 replicado nos n\u00f3s sucessivos ao respons\u00e1vel pela dupla chave valor. O carrinho \u00e9 modificado atomicamente , isto \u00e9, sobrescrito por inteiro. A replica\u00e7\u00e3o, associada \u00e0s modifica\u00e7\u00f5es at\u00f4micas, potencializa conflitos, que s\u00e3o identificados comparando-se os vetores de vers\u00e3o (rel\u00f3gios vetoriais) associados a cada valor escrito. No caso de conflitos, as m\u00faltiplas c\u00f3pias concorrentes s\u00e3o apresentadas ao usu\u00e1rio na forma de um carrinho de compras com a uni\u00e3o dos itens nos respectivos carrinhos, de forma que o usu\u00e1rio possa corrig\u00ed-lo. Na pior das hip\u00f3teses, uma compra com erros ser\u00e1 feita, e necessitar\u00e1 de uma atividade compensat\u00f3ria para o usu\u00e1rio, como um brinde. Na pr\u00e1tica, muitos sistemas mant\u00e9m os pap\u00e9is de clientes, que requisitam a execu\u00e7\u00e3o de servi\u00e7os, e servidores, que executam as requisi\u00e7\u00f5es, mas distribuem as tarefas dos servidores entre pares para aquela fun\u00e7\u00e3o, sendo efetivamente sistemas h\u00edbridos. Este \u00e9 o caso dos bancos de dados NOSQL, como o Dynamo, que acabamos de estudar, e tamb\u00e9m do Cassandra, que veremos a seguir. Estudo de Caso: Cassandra Outra alternativa \u00e9 fazer com que cada n\u00f3 do sistema conhe\u00e7a todos os outros. Assim, cada requisi\u00e7\u00e3o pode ser diretamente encaminhada ao n\u00f3 respons\u00e1vel por trat\u00e1-la. O custo do roteamento, neste caso, \u00e9 O(1) O(1) , muito mais r\u00e1pido que na abordagem anterior. O custo de armazenamento da tabela de rotas \u00e9, contudo, O(n) O(n) , o que pode ser proibitivo em uma rede com milhares de n\u00f3s, apesar de ser uma solu\u00e7\u00e3o vi\u00e1vel em redes menores. Este \u00e9 o caso do CassandraDB, uma banco de dados distribu\u00eddo baseado no Chord, que estudaremos melhor mais adiante, considerado uma DHT de salto \u00fanico ( single-hop DHT). O CassandraDB foi, sem sombra de d\u00favida, influenciado pelo projeto do DynamoDB, o que \u00e9 facilmente explic\u00e1vel j\u00e1 que um dos criadores do Dynamo foi o arquiteto do Cassandra. Mas em vez de uma c\u00f3pia, o Cassandra largamente expande a funcionalidade do Dynamo ao se inspirar no banco de dados BigTable , do Google. Com isso, o Cassandra se aproxima do modelo relacional, facilitando o desenvolvimento de certas aplica\u00e7\u00f5es, sem perder as caracter\u00edsticas desej\u00e1veis das DHT. A principal caracter\u00edstica neste sentido \u00e9 o modelo h\u00edbrido chave-valor/relacional, em que os valores associados a uma chave s\u00e3o divididos em colunas. A combina\u00e7\u00e3o chave-colunas s\u00e3o denominadas column-families e seu conjunto keyspace . Estas duas estruturas s\u00e3o equivalente \u00e0s tabelas/rela\u00e7\u00f5es e aos bancos de dados, dos bancos de dados relacionais. Uma diferen\u00e7a fundamental entre column-families e rela\u00e7\u00f5es \u00e9 que as \u00faltimas precisam de um esquema pr\u00e9-definido, enquanto que as primeiras n\u00e3o tem um esquema. Isto quer dizer que novas colunas podem ser adicionadas dinamicamente e que nem todas precisam estar presentes para cada chave. De fato, m\u00faltiplos registros com a mesma chave, ou linhas, podem ter conjuntos de colunas diferentes. Para que o correto conjunto de colunas associado a uma chave possa ser apurado, ap\u00f3s m\u00faltiplas escritas com a mesma chave tenham ocorrido, a cada tupla (chave,coluna,valor) \u00e9 associado tamb\u00e9m um timestamp . . Assim, dados uma mesma chave e coluna, o valor v\u00e1lido \u00e9 o com o maior timestamp. Devido a possibilidade de valores serem escritos para diferentes colunas independentemente, valores v\u00e1lidos e inv\u00e1lidos podem ter o mesmo timestamp . Por exemplo, considere os seguintes dados escritos no banco: Chave Coluna \\rightarrow \\rightarrow Valor Timestamp 3 Nome \\rightarrow \\rightarrow Jos\u00e9, Idade \\rightarrow \\rightarrow 30 02:02:2020,13:45:00 3 Idade \\rightarrow \\rightarrow 33 02:02:2020,13:50:00 3 Telefone \\rightarrow \\rightarrow 333444554433 02:02:2020,13:55:00 Uma busca pelos dados associados \u00e0 chave 3 retornar\u00e1 o seguinte resultado: Nome \\rightarrow \\rightarrow Jos\u00e9, Idade \\rightarrow \\rightarrow 33, Telefone \\rightarrow \\rightarrow 333444554433. Para facilitar mais ainda o desenvolvimento, o Cassandra conta com uma linguagem de consulta similar ao SQL (Structured Query Language), a CQL (Cassandra Query Language). Assim, a consulta a estes dados seria mais ou menos como SELECT * FROM dados WHERE key == 3 . 5 H\u00e1 muitos recursos online para se aprender mais se aprender mais sobre como usar o Cassandra, por exemplo, aqui . H\u00e1 tamb\u00e9m diversos projetos de c\u00f3digo livre que o usam e podem ser estudados, por exemplo, o clone de Twiter Twissandra . Mas embora o uso de sistemas gerenciadores de bancos de dados em sistemas distribu\u00eddos seja interessante, aqui nos focaremos em alguns dos aspectos de como estes SGBD s\u00e3o constru\u00eddos. Detalhes de Implementa\u00e7\u00e3o A se\u00e7\u00e3o de tecnologias descreve v\u00e1rias estruturas de dados recorrentemente usadas em implementa\u00e7\u00e3o de bancos de dados como o Cassandra. Outros exemplos P2P \u00e9 terreno f\u00e9rtil e poder\u00edamos passar muito tempo apenas enumerando exemplos interessantes, mas nos limitaremos aqui a dois dos mais atuais. O primeiro \u00e9 o sistema de compartilhamento de arquivos j\u00e1 mencionado na introdu\u00e7\u00e3o , BitTorrent. O que h\u00e1 de mais interessante neste exemplo o fato de haverem diversas implementa\u00e7\u00f5es dos clientes, e.g., \\mu \\mu Torrent, Azureus, Transmission, Vuze, qTorrent, implemenados em diversas linguagens e para diversas plataformas, todos interoper\u00e1veis. Isso \u00e9 um atestado do que uma especifica\u00e7\u00e3o bem feita e aberta pode alcan\u00e7ar. O segundo \u00e9 o sistema que suporta a criptomoeda BitCoin, em que milhares de n\u00f3s armazenam coletivamente o hist\u00f3rico de transa\u00e7\u00f5es de trocas de dono das moedas. Mas em vez de expandir aqui este assunto, deferiremos esta discuss\u00e3o para a se\u00e7\u00e3o BlockChain . Apenas para abrir o apetite, Arquitetura Orientada a Microsservi\u00e7os No dia 3 de Junho de 2020, termo microservice resultava em 6.6 milh\u00f5es de resultados no Google . Isso porqu\u00ea a organiza\u00e7\u00e3o de aplica\u00e7\u00f5es distribu\u00eddas na forma de \"pequenos\" processos, especializados e independentes, que colaboram para implementar um servi\u00e7o maior, se tornou um padr\u00e3o importante no desenvolvimento de novas aplica\u00e7\u00f5es. Exatamente por isso, precisamos come\u00e7ar com um aviso: diversas tecnologias surgiram com grande estrondo, sendo alguns exemplos recentes Docker, Golang, Angular, e JQuery, e embora seja certo que algumas destas encontrar\u00e3o seus nichos, como fizeram antes delas Cobol, C, e SQL, outras deparecer\u00e3o da face da ind\u00fastria; afinal, quem sabe o que \u00e9 Delphi e quem ainda usa JQuery? Este fen\u00f4meno \u00e9 capturado pelas v\u00e1rias fases do hype-cycle da Gartner. 6 A Arquitetura Orientada a Microsservi\u00e7os, tendo atingido o pico das expectativas infladas 7 em 2017, est\u00e1 deslizando na Trough of Desilusionment 7 em 2019. Isto \u00e9, este modelo de desenvolvimento n\u00e3o \u00e9 mais propagandeado como uma bala de prata para todas as aplica\u00e7\u00f5es distribu\u00eddas. Ainda assim, \u00e9 um importante modelo. Mas afinal, o que \u00e9 a arquitetura de microsservi\u00e7os? Em vez de explicar diretamente o que s\u00e3o, pode ser mais f\u00e1cil pensar primeiro termos do que n\u00e3o s\u00e3o, em termoss de sistemas monol\u00edticos. Monolitos Muitas aplica\u00e7\u00f5es seguem o modelo de 3 camadas em que em um dos extremos tem-se a interface com os usu\u00e1rios, materializada normalmente por um navegador, no outro tem-se um SGBD onde s\u00e3o armazenados os dados da aplica\u00e7\u00e3o, e, no meio, a l\u00f3gica do neg\u00f3cio. A camada central, implementada por um \u00fanico processo, que alimenta a interface com o usu\u00e1rio, manipula o modelo de dados, e onde reside a l\u00f3gica do neg\u00f3cio, \u00e9 um monolito . Monolitos seguem um modelo simples e largamente utilizado de desenvolvimento em que v\u00e1rios contribuidores implementam partes distintas da l\u00f3gica, que s\u00e3o compiladas em colocadas em desenvolvimento de forma at\u00f4mica: Desenvolva Teste Implante loop Simples n\u00e3o quer dizer necessariamente eficiente; no caso de atualiza\u00e7\u00f5es de uma parte do sistema, todo o monolito precisa ser trocado, incorrendo em indisponibilidade total do sistema, mesmo das partes n\u00e3o modificadas. Esta dificuldade tende a limitar as janelas de atualiza\u00e7\u00e3o do sistema, o que aumenta no n\u00famero de mudan\u00e7as que ocorrem a cada atualiza\u00e7\u00e3o, o que aumenta o risco de regress\u00f5es e portanto requer mais testes, o que aumenta o intervalo entre janelas de atualiza\u00e7\u00e3o. Al\u00e9m disso, nos caso de bugs, \u00e9 mais dif\u00edcil encontrar o problema, uma vez que fica imposs\u00edvel os desenvolvedores conhecerem todo o sistema. Isso apenas exacerba o problema, o que limita mais ainda as atualiza\u00e7\u00f5es, gerando um ciclo vicioso que mantem desenvolvedores acordados nas madrugadas de sexta para s\u00e1bado quando \u00e9 dia de deploy . Sistemas monol\u00edticos tamb\u00e9m podem ser problem\u00e1ticos quanto \u00e0 escalabilidde, pois quando a capacidade do sistema \u00e9 atingida, ou todo o sistema \u00e9 movido para um host de maior capacidade ou todo o sistema deve ser replicado. Na primeira abordagem, o custo geralmente \u00e9 um impecilho, pois pre\u00e7os de hardware crescem exponencialmente. Al\u00e9m disso, um servidor, por mais parrudo que seja, \u00e9 um Ponto \u00danico de Falha (ou SPOF, do ingl\u00eas single point of failure ). Quanto \u00e0 segunda abordagem, ela traz complexidades na coordena\u00e7\u00e3o das r\u00e9plicas e inefici\u00eancias ao replicar inclusive as partes subutilizadas. Ambas as abordagens tamb\u00e9m esbarram na escalabilidade do banco de dados que lhes serve de backend . Para contornar ou pelo menos minimizar estes problemas, pode-se fragmentar o servi\u00e7o e o banco de dados, o que facilita tanto a escalabilidade vertical quanto horizontal de cada m\u00f3dulo, que \u00e9 menor e mais simples de coordenar, e divide a carga nos bancos de dados; mas isso \u00e9 a troca do serv\u00ed\u00e7o monol\u00edtico por microsservi\u00e7os. Microsservi\u00e7os De acordo com Lewis & Fowler The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. Em outras palavras, com os microsservi\u00e7os, quebra-se o monolito em diferentes processos, \" small autonomous services that work together, modelled around a business domain \", cada um gerenciando os dados relevantes para aquela parte do sistema e, possivelmente, sua pr\u00f3pria intera\u00e7\u00e3o com o usu\u00e1rio. Este modelo tem implica\u00e7\u00f5es diretas no desenvolvimento: cada processo \u00e9 desenvolvido por um time diferente, que mantem controle sobre desenvolvimento, teste, e manuten\u00e7\u00e3o em produ\u00e7\u00e3o, o que \u00e9 fact\u00edvel j\u00e1 que cada servi\u00e7o \u00e9 simples e focado em um problema pequeno e ningu\u00e9m tem que entender em detalhas o funcionamento de todo o sistema. Al\u00e9m disso, quando um servi\u00e7o precisa ser atualizado, todos os demais podem continuar operantes e poss\u00edvel at\u00e9 que m\u00faltiplas vers\u00f5es do mesmo servi\u00e7o sejam executadas concorrentemente, possibilitando atualiza\u00e7\u00f5es sem janelas de manuten\u00e7\u00e3o. Quanto \u00e0 escalabilidade, esta \u00e9 feita indepentendentemente tamb\u00e9m; no exemplo na imagem seguinte, \u00e9 prov\u00e1vel que o servi\u00e7o de acesso ao cat\u00e1logo seja mais utilizado que os demais e portanto merecedor de mais recursos e mais c\u00f3pias. Como se percebe facilmente, o uso de microsservi\u00e7os pode ser relacionado \u00e0s t\u00e9cnicas de processamento paralelo: trate dados diferentes em blocos diferentes (paralelismo de dados ou replica\u00e7\u00e3o) e trate fun\u00e7\u00f5es diferentes em blocos diferentes (paralelismo de tarefas ou sharding ). Como na computa\u00e7\u00e3o paralela, na componentiza\u00e7\u00e3o \u00e9 importante considerar os requisitos das diferentes tarefas em termos de CPU, E/S, e mem\u00f3ria, para que possam escalar independentemente e n\u00e3o gerar gargalos desnecess\u00e1rios. Do Monolito aos Microsservi\u00e7os Com tantas vantagens, suge a d\u00favida se todos os sistemas deveriam ser desenvolvidos usando-se a arquitetura de microsservi\u00e7os. A resposta \u00e9 n\u00e3o , pois como colocado no in\u00edcio desta se\u00e7\u00e3o, n\u00e3o existem balas de prata e se um sistema monol\u00edtico est\u00e1 funcionando para voc\u00ea e n\u00e3o h\u00e1 perspectiva de problemas acometerem (a demanda no sistema n\u00e3o est\u00e1 aumentando, a l\u00f3gica do sistema \u00e9 muito simples, indisponibilidade n\u00e3o te traz preju\u00edzo, voc\u00ea n\u00e3o pode arcar com a refatora\u00e7\u00e3o), ent\u00e3o mantenha seu sistema como est\u00e1. Caso haja a necessidade de evolu\u00e7\u00e3o e o modelo de microsservi\u00e7os pare\u00e7a adequado, existem recomenda\u00e7\u00f5es de como a migra\u00e7\u00e3o pode ser feita. Primeiro, \u00e9 preciso aceitar que o desenvolvimento de microsservi\u00e7os afeta a organiza\u00e7\u00e3o do time de desenvolvimento e que a organiza\u00e7\u00e3o provavelmente refletir\u00e1 a arquitetura. O desenvolvimento, manuten\u00e7\u00e3o e opera\u00e7\u00e3o de microsservi\u00e7os acontece em times pequenos, de 1 a 8 pessoas (\"pizza team\"), dependendo da complexidade do servi\u00e7o; se houver a necessidade de mais pesssoas no time, o escopo do microsservi\u00e7o provavelmente est\u00e1 grande demais; cada componente resolve um problema, bem. Segundo, a mudan\u00e7a n\u00e3o dever\u00e1 acontecer atomicamente. Uma boa estrat\u00e9gia \u00e9 identificar uma parte do sistema que funcionaria bem como microsservi\u00e7o, desenvolv\u00ea-la e modificar o monolito para usar o microsservi\u00e7o. O aprendizado ent\u00e3o \u00e9 usado para encontrar novo candidato e o procedimento \u00e9 iterado at\u00e9 que o monolito seja apenas uma casca e possa tamb\u00e9m ser removido. Mais f\u00e1cil dito que feito, h\u00e1 muita documenta\u00e7\u00e3o orientando o processo. Para saber mais Como esta arquitetura n\u00e3o faz parte ainda do nosso curr\u00edculo, n\u00e3o nos aprofundaremos nela aqui. Felizmente h\u00e1 muito material na Web sobre este modelo, sendo a lista a seguir uma \u00ednfima fra\u00e7\u00e3o. Para uma explica\u00e7\u00e3o geral do que s\u00e3o, assista a Martin Fowler no v\u00eddeo seguinte, assista ou consulte os v\u00e1rios artigos no seu s\u00edtio . Para entender os princ\u00edpios por tr\u00e1s do uso da arquitetura, Para um exemplo importante do uso de microsservi\u00e7os, considere a Netflix, que usa microsservi\u00e7os em larga escala em seus servi\u00e7os. Qu\u00e3o larga? \"...over five hundred services... we don't know how many...\" Apesar de tal uso, ou justamente por causa dele, seus servi\u00e7os mant\u00e9m uma \"...availability of 9.995...\", ou seja, ficam indispon\u00edveis por menos de 16 segundos por ano . Com respeito a estar preparado para falhas, afinal \"... it is not if failures will happen... ... it is when it happens...\", a empresa usa uma abordagem de inje\u00e7\u00e3o de falhas em servi\u00e7os em produ\u00e7\u00e3o. Os diferentes tiposde falhas s\u00e3o injetados por um \" ex\u00e9rcito de macacos do caos \" Para uma vis\u00e3o pr\u00e1tica da implementa\u00e7\u00e3o de microsservi\u00e7os usando AWS, veja TODO SOA - Foco no uso de outras formas de comunica\u00e7\u00e3o para chegar em outras arquiteturas. MOM Publish/Subscribe Message Queues Event Sourcing Stream Processing/Event Sourcing Kafka Overview Se voc\u00ea n\u00e3o pegou a refer\u00eancia, volte uma casa 2 um cap\u00edtulo. \u21a9 Se voc\u00ea n\u00e3o pegou esta refer\u00eancia, n\u00e3o teve inf\u00e2ncia. \u21a9 Neste problema do ICPC, um esquema de nomea\u00e7\u00e3o dos n\u00f3s de um hypercube \u00e9 apresentado; usando este esquema, derive um algoritmo de roteamento em que a dist\u00e2ncia percorrida por qualquer mensagem seja sempre igual ao n\u00famero de dimens\u00f5es do cubo. \u21a9 Observe que as dist\u00e2ncias entre os n\u00f3s no anel foram desenhadas de forma proporcial \u00e0 diferen\u00e7a num\u00e9rica entre os identificadores. \u21a9 Este exemplo \u00e9 meramente ilustrativo e n\u00e3o segue estritamente a sintaxe do CQL. \u21a9 \"The hype cycle is a branded graphical presentation developed and used by the American research, advisory and information technology firm Gartner, for representing the maturity, adoption and social application of specific technologies.\" \u21a9 Peak of Inflated - Expectations Early publicity produces a number of success stories\u2014often accompanied by scores of failures. Some companies take action; most don't. Technology Trigger -- A potential technology breakthrough kicks things off. Early proof-of-concept stories and media interest trigger significant publicity. Often no usable products exist and commercial viability is unproven. Slope of Enlightenment -- More instances of how the technology can benefit the enterprise start to crystallize and become more widely understood. Second- and third-generation products appear from technology providers. More enterprises fund pilots; conservative companies remain cautious. Plateau of Productivity -- Mainstream adoption starts to take off. Criteria for assessing provider viability are more clearly defined. The technology's broad market applicability and relevance are clearly paying off. Trough of Disillusionmen - Interest wanes as experiments and implementations fail to deliver. Producers of the technology shake out or fail. Investment continues only if the surviving providers improve their products to the satisfaction of early adopters. \u21a9 \u21a9","title":"Arquiteturas"},{"location":"teaching/gbc074gsi028/arch/#arquiteturas","text":"","title":"Arquiteturas"},{"location":"teaching/gbc074gsi028/arch/#cliente-servidor","text":"Como brevemente discutido em Fundamentos , quando pensamos em termos de comunica\u00e7\u00e3o entre dois processos usando sockets, em geral pensamos em processos clientes e servidores, onde servidores esperam a conex\u00e3o por parte de clientes e executam as opera\u00e7\u00f5es requisitadas pelos mesmos. Como exemplos desta arquitetura, podemos pensar em um navegador requisitando a um servidor Apache que lhe retorne uma p\u00e1gina Web, ou em um aplicativo m\u00f3vel solicitando ao servidor de aplica\u00e7\u00f5es que dispare uma transfer\u00eancia de fundos. Um exemplo gen\u00e9rico \u00e9 apresentado na figura a seguir. sequenceDiagram activate Servidor activate Cliente note left of Servidor: Cria socket e espera por conex\u00f5es deactivate Servidor Cliente->>+Servidor: Connect? note left of Servidor: Aceita conex\u00e3o Servidor->>-Cliente: Connect! note right of Cliente: Ativo (gerando requisi\u00e7\u00e3o) note left of Servidor: Inativo (esperando requisi\u00e7\u00e3o) Cliente->>+Servidor: Request deactivate Cliente note right of Cliente: Inativo (esperando resposta) note left of Servidor: Ativo (processando requisi\u00e7\u00e3o) Servidor-->>-Cliente: Response activate Cliente note right of Cliente: Ativo (processando resposta note left of Servidor: Inativo (esperando requisi\u00e7\u00e3o) deactivate Cliente O modelo cliente/servidor forma a base da computa\u00e7\u00e3o distribu\u00edda, sobre a qual todos os outros modelos s\u00e3o implementados. Uma das raz\u00f5es \u00e9 hist\u00f3rica: os primeiros sistemas a permitirem a opera\u00e7\u00e3o por m\u00faltiplos usu\u00e1rios, ainda na d\u00e9cada de 60, eram compostos de uma host robusto ao qual se conectavam diversos terminais, essencialmente com teclado e monitor, isto \u00e9, um servidor e v\u00e1rios clientes. Com a redu\u00e7\u00e3o dos computadores, surgiram as primeiras redes de computadores e a necessidade de uma abstra\u00e7\u00e3o para o estabelecimento de comunica\u00e7\u00e3o entre processos em hosts distintos, e assim surgiram os sockets . Com os sockets, vem uma grande flexibilidade, pois um processo n\u00e3o precisa saber como o outro manuseia os dados que lhe cabem, desde que siga um protocolo pr\u00e9-estabelecido na comunica\u00e7\u00e3o. Isto \u00e9, processos podem ser implementado em diferentes linguagens, sistemas operacionais e arquiteturas, desde observadas os cuidados necess\u00e1rios para se obter transpar\u00eancia de acesso . Esta flexibilidade \u00e9 a outra raz\u00e3o do sucesso do modelo cliente/servidor, permitindo que clientes se conectem a servidores para usar seus recursos, que podem ser acessados concorrentemente por diversos clientes. Exemplos cotidianos disto s\u00e3o servidores de bancos de dados, de p\u00e1ginas Web e email. De fato, esta flexibilidade permite que diversas aplica\u00e7\u00f5es continuem operando de forma centralizada, com servidores rodando, por exemplo, em mainframes e clientes rodando de forma emulada por software em computadores pessoais. Contudo, em certas situa\u00e7\u00f5es, esta divis\u00e3o entre clientes e servidores pode ser tornar confusa. Primeiro, porqu\u00ea uma vez estabelecida a conex\u00e3o, n\u00e3o h\u00e1 uma diferencia\u00e7\u00e3o entre quem iniciou e quem aceitou a mesma; s\u00e3o apenas duas pontas do mesmo socket. Segundo, pode ser que o servi\u00e7o relevante sendo prestado, seja prestado por quem estabelece a conex\u00e3o. De fato ambos podem estar prestando servi\u00e7os um para o outro, no que \u00e9 conhecido como P2P. Terceiro, um mesmo processo pode atuar tanto como cliente quanto como servidor, no que \u00e9 conhecido como arquitetura multicamadas, tamb\u00e9m a ser visto adiante. Quarto, usando-se sockets como base, podemos construir outros modelos de comunica\u00e7\u00e3o entre processos, efetivamente colocando camadas na nossa cebola. 1 A seguir, exploraremos as arquiteturas constru\u00eddas sobre cliente/servidor.","title":"Cliente Servidor"},{"location":"teaching/gbc074gsi028/arch/#par-a-par-peer-to-peer-p2p","text":"Nos sistemas que seguem a arquitetura Par-a-Par, ou simplesmente P2P, h\u00e1 uma substitui\u00e7\u00e3o dos pap\u00e9is de clientes e servidores, em que h\u00e1 uma \"hirarquia\" entre os componentes, por uma onde todos os n\u00f3s s\u00e3o pares na execu\u00e7\u00e3o da tarefa em quest\u00e3o. Um exemplo comum destas arquitetura s\u00e3o os sistemas de compartilhamento de arquivos, em que cada n\u00f3 armazena e disponibiliza parte dos dados, bem como acessa os dados disponibilizados por outros n\u00f3s. Como todo sistema distribu\u00eddo, a arquitetura P2P visa agregar poder computacional de m\u00faltiplos n\u00f3s . Mas al\u00e9m disso, pelo n\u00e3o diferencia\u00e7\u00e3o dos componentes, espera-se tolerar falhas de componentes sem paralizar o servi\u00e7o , uma vez que n\u00e3o h\u00e1 um componenente centralizador, detentor \u00fanico de uma certa funcionalidade. Os sistemas P2P tendem portanto a lever a maior disponibilidade. Historicamente, e devido \u00e0s caracter\u00edsticas j\u00e1 mencionadas, os sistemas P2P tem outra caracter\u00edstica muito importante, a alta escalabilidade a que se oferecerem, chegando a n\u00edveis globais. Se pensarmos por exemplo nos sistemas de compartilhamento de arquivos, m\u00fasicas e filmes, raz\u00e3o da fama e inf\u00e2mia da arquitetura, teremos bons exemplos disso. Para que isso seja poss\u00edvel, estes sistemas precisam se tornar auto-gerenci\u00e1veis , pois sistemas globais devem tolerar entrada e sa\u00edda frequente de n\u00f3s (por falhas ou a\u00e7\u00e3o de seus usu\u00e1rios), diferentes dom\u00ednios administrativos , e heterogeneidade na comunica\u00e7\u00e3o. Uma das ferramentas utilizadas para simplificar o trabalho de auto-gerenciamento \u00e9 o conceito de redes sobrepostas .","title":"Par-a-Par (Peer-to-Peer, P2P)"},{"location":"teaching/gbc074gsi028/arch/#rede-sobreposta-overlay","text":"Os componentes de um sistema P2P se organizam em uma rede l\u00f3gica, sobreposta \u00e0 rede f\u00edsica. Nesta rede l\u00f3gica, os processos estabelecem canais de comunica\u00e7\u00e3o tipicamente na forma de conex\u00f5es TCP/IP. Por serem ignorantes \u00e0 topologia f\u00edsica da rede e usarem a pilha de comunica\u00e7\u00e3o IP, as redes sobrepostas s\u00e3o mais simples e ao mesmo tempo mais poderosas. Nestas redes s\u00e3o executados diversos algoritmos, como de descoberta de n\u00f3s, roteamento de pacotes e de otimiza\u00e7\u00e3o de rotas pelo descarte e cria\u00e7\u00e3o de conex\u00f5es. Uma vez que as conex\u00f5es na rede sobreposta n\u00e3o correspondem a conex\u00f5es f\u00edsicas, como se pode ver na seguinte figura, vizinhos em um rede sobreposta n\u00e3o necessariamente correspondem a vizinhos na rede f\u00edsica e vice-versa. Isto tamb\u00e9m implica que a otimiza\u00e7\u00e3o da rota l\u00f3gica n\u00e3o necessariamente leva \u00e0 otimiza\u00e7\u00e3o da rota f\u00edsica. Todo A figura n\u00e3o mostra hosts, apenas roteadores. Trocar por figura em com hosts, roteadores, e processos nos hosts. Dependendo em como esta rede \u00e9 organizada (ou n\u00e3o), a mesma \u00e9 classificada como estruturada ou n\u00e3o-estruturada .","title":"Rede Sobreposta (Overlay)"},{"location":"teaching/gbc074gsi028/arch/#tabelas-de-espalhamento-distribuidas-dht","text":"A versatilidade dos sistemas P2P os levaram a ser amplamente estudados e aplicados, sendo que entre as aplica\u00e7\u00f5es mais bem sucedidas est\u00e3o as Tabelas de Espalhamento Distribu\u00edds (DHT, do ingl\u00eas, Distributed Hash Tables ). As tabelas de espalhamento (tamb\u00e9m conhecidas como mapas, dicion\u00e1rios, arrays associativos) tem caracter\u00edsticas que a tornam adequadas ao armazenamento de dados a v\u00e1rios cen\u00e1rios. Em ess\u00eancia, estas tabelas s\u00e3o fun\u00e7\u00f5es que mapeiam uma chave para um valor, uma fun\u00e7\u00e3o f f tal que f(K): V \\cup f(K): V \\cup {null} K K : Universo de chaves V V : Universo de valores isto \u00e9, f(k) = v, k\\in K, v \\in V f(k) = v, k\\in K, v \\in V ou v = v = null. Na pr\u00e1tica, s\u00e3o estruturas de dados adapt\u00e1veis, com um API muito simples, e com opera\u00e7\u00f5es de tempo (mais ou menos) constante para fazer CRUD de pares chave/valor. Tanto K K quanto V V s\u00e3o blobs de dados, isto \u00e9, sem nenhuma forma distinta, e por isso podem ser usadas para resolver uma gama de problemas. API put(k,v) put(k,v) : if k \\rightarrow w k \\rightarrow w then return w w else k \\rightarrow v k \\rightarrow v ; return \\emptyset \\emptyset update(k,v) update(k,v) : if k \\rightarrow w k \\rightarrow w then return w w else return \\emptyset \\emptyset get(k) get(k) : if k \\rightarrow w k \\rightarrow w then return w w else return \\emptyset \\emptyset del(k) del(k) : if k \\rightarrow w k \\rightarrow w then return w w else k \\rightarrow v k \\rightarrow v ; return \\emptyset \\emptyset k k e v v s\u00e3o blobs execu\u00e7\u00e3o O(1) O(1) Se as tabelas de espalhamento s\u00e3o estruturas de dados \u00fateis, uma vers\u00e3o distribu\u00edda seria ainda mais \u00fatil, principalmente porqu\u00ea ela poderia ser tolerante a falhas e ter escalabilidade linear . \u00c9 justamente desta idea que surgem as DHT, literalmente tabelas de espalhamento distribu\u00eddas, estruturas de dados que mant\u00e9m a mesma API e funcionalidades de tabelas de espalhamento, mas que agrega capacidades de diversos hosts . Dentre os desafios na implementa\u00e7\u00e3o de uma DHT est\u00e3o O que usar como chave? Uma DHT deve ser vers\u00e1til para ser utilizada para v\u00e1rios fins, ent\u00e3o a chave precisa ser independente da aplica\u00e7\u00e3o. Como dividir a carga entre hosts? \u00c9 preciso balancear a carga para que um lado da rede n\u00e3o se torne mais importante que o outro e para n\u00e3o levar a uma hierarquiza\u00e7\u00e3o entre os n\u00f3s. Como rotear requisi\u00e7\u00f5es para o host correto? Uma vez que os dados devem ser particionados entre hosts para garantir escalabilidade, como encontrar o n\u00f3 onde determinado dado est\u00e1 or deveria estar?","title":"Tabelas de Espalhamento Distribu\u00eddas (DHT)"},{"location":"teaching/gbc074gsi028/arch/#arquitetura-orientada-a-microsservicos","text":"No dia 3 de Junho de 2020, termo microservice resultava em 6.6 milh\u00f5es de resultados no Google . Isso porqu\u00ea a organiza\u00e7\u00e3o de aplica\u00e7\u00f5es distribu\u00eddas na forma de \"pequenos\" processos, especializados e independentes, que colaboram para implementar um servi\u00e7o maior, se tornou um padr\u00e3o importante no desenvolvimento de novas aplica\u00e7\u00f5es. Exatamente por isso, precisamos come\u00e7ar com um aviso: diversas tecnologias surgiram com grande estrondo, sendo alguns exemplos recentes Docker, Golang, Angular, e JQuery, e embora seja certo que algumas destas encontrar\u00e3o seus nichos, como fizeram antes delas Cobol, C, e SQL, outras deparecer\u00e3o da face da ind\u00fastria; afinal, quem sabe o que \u00e9 Delphi e quem ainda usa JQuery? Este fen\u00f4meno \u00e9 capturado pelas v\u00e1rias fases do hype-cycle da Gartner. 6 A Arquitetura Orientada a Microsservi\u00e7os, tendo atingido o pico das expectativas infladas 7 em 2017, est\u00e1 deslizando na Trough of Desilusionment 7 em 2019. Isto \u00e9, este modelo de desenvolvimento n\u00e3o \u00e9 mais propagandeado como uma bala de prata para todas as aplica\u00e7\u00f5es distribu\u00eddas. Ainda assim, \u00e9 um importante modelo. Mas afinal, o que \u00e9 a arquitetura de microsservi\u00e7os? Em vez de explicar diretamente o que s\u00e3o, pode ser mais f\u00e1cil pensar primeiro termos do que n\u00e3o s\u00e3o, em termoss de sistemas monol\u00edticos.","title":"Arquitetura Orientada a Microsservi\u00e7os"},{"location":"teaching/gbc074gsi028/arch/#monolitos","text":"Muitas aplica\u00e7\u00f5es seguem o modelo de 3 camadas em que em um dos extremos tem-se a interface com os usu\u00e1rios, materializada normalmente por um navegador, no outro tem-se um SGBD onde s\u00e3o armazenados os dados da aplica\u00e7\u00e3o, e, no meio, a l\u00f3gica do neg\u00f3cio. A camada central, implementada por um \u00fanico processo, que alimenta a interface com o usu\u00e1rio, manipula o modelo de dados, e onde reside a l\u00f3gica do neg\u00f3cio, \u00e9 um monolito . Monolitos seguem um modelo simples e largamente utilizado de desenvolvimento em que v\u00e1rios contribuidores implementam partes distintas da l\u00f3gica, que s\u00e3o compiladas em colocadas em desenvolvimento de forma at\u00f4mica: Desenvolva Teste Implante loop Simples n\u00e3o quer dizer necessariamente eficiente; no caso de atualiza\u00e7\u00f5es de uma parte do sistema, todo o monolito precisa ser trocado, incorrendo em indisponibilidade total do sistema, mesmo das partes n\u00e3o modificadas. Esta dificuldade tende a limitar as janelas de atualiza\u00e7\u00e3o do sistema, o que aumenta no n\u00famero de mudan\u00e7as que ocorrem a cada atualiza\u00e7\u00e3o, o que aumenta o risco de regress\u00f5es e portanto requer mais testes, o que aumenta o intervalo entre janelas de atualiza\u00e7\u00e3o. Al\u00e9m disso, nos caso de bugs, \u00e9 mais dif\u00edcil encontrar o problema, uma vez que fica imposs\u00edvel os desenvolvedores conhecerem todo o sistema. Isso apenas exacerba o problema, o que limita mais ainda as atualiza\u00e7\u00f5es, gerando um ciclo vicioso que mantem desenvolvedores acordados nas madrugadas de sexta para s\u00e1bado quando \u00e9 dia de deploy . Sistemas monol\u00edticos tamb\u00e9m podem ser problem\u00e1ticos quanto \u00e0 escalabilidde, pois quando a capacidade do sistema \u00e9 atingida, ou todo o sistema \u00e9 movido para um host de maior capacidade ou todo o sistema deve ser replicado. Na primeira abordagem, o custo geralmente \u00e9 um impecilho, pois pre\u00e7os de hardware crescem exponencialmente. Al\u00e9m disso, um servidor, por mais parrudo que seja, \u00e9 um Ponto \u00danico de Falha (ou SPOF, do ingl\u00eas single point of failure ). Quanto \u00e0 segunda abordagem, ela traz complexidades na coordena\u00e7\u00e3o das r\u00e9plicas e inefici\u00eancias ao replicar inclusive as partes subutilizadas. Ambas as abordagens tamb\u00e9m esbarram na escalabilidade do banco de dados que lhes serve de backend . Para contornar ou pelo menos minimizar estes problemas, pode-se fragmentar o servi\u00e7o e o banco de dados, o que facilita tanto a escalabilidade vertical quanto horizontal de cada m\u00f3dulo, que \u00e9 menor e mais simples de coordenar, e divide a carga nos bancos de dados; mas isso \u00e9 a troca do serv\u00ed\u00e7o monol\u00edtico por microsservi\u00e7os.","title":"Monolitos"},{"location":"teaching/gbc074gsi028/arch/#microsservicos","text":"De acordo com Lewis & Fowler The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. Em outras palavras, com os microsservi\u00e7os, quebra-se o monolito em diferentes processos, \" small autonomous services that work together, modelled around a business domain \", cada um gerenciando os dados relevantes para aquela parte do sistema e, possivelmente, sua pr\u00f3pria intera\u00e7\u00e3o com o usu\u00e1rio. Este modelo tem implica\u00e7\u00f5es diretas no desenvolvimento: cada processo \u00e9 desenvolvido por um time diferente, que mantem controle sobre desenvolvimento, teste, e manuten\u00e7\u00e3o em produ\u00e7\u00e3o, o que \u00e9 fact\u00edvel j\u00e1 que cada servi\u00e7o \u00e9 simples e focado em um problema pequeno e ningu\u00e9m tem que entender em detalhas o funcionamento de todo o sistema. Al\u00e9m disso, quando um servi\u00e7o precisa ser atualizado, todos os demais podem continuar operantes e poss\u00edvel at\u00e9 que m\u00faltiplas vers\u00f5es do mesmo servi\u00e7o sejam executadas concorrentemente, possibilitando atualiza\u00e7\u00f5es sem janelas de manuten\u00e7\u00e3o. Quanto \u00e0 escalabilidade, esta \u00e9 feita indepentendentemente tamb\u00e9m; no exemplo na imagem seguinte, \u00e9 prov\u00e1vel que o servi\u00e7o de acesso ao cat\u00e1logo seja mais utilizado que os demais e portanto merecedor de mais recursos e mais c\u00f3pias. Como se percebe facilmente, o uso de microsservi\u00e7os pode ser relacionado \u00e0s t\u00e9cnicas de processamento paralelo: trate dados diferentes em blocos diferentes (paralelismo de dados ou replica\u00e7\u00e3o) e trate fun\u00e7\u00f5es diferentes em blocos diferentes (paralelismo de tarefas ou sharding ). Como na computa\u00e7\u00e3o paralela, na componentiza\u00e7\u00e3o \u00e9 importante considerar os requisitos das diferentes tarefas em termos de CPU, E/S, e mem\u00f3ria, para que possam escalar independentemente e n\u00e3o gerar gargalos desnecess\u00e1rios.","title":"Microsservi\u00e7os"},{"location":"teaching/gbc074gsi028/arch/#do-monolito-aos-microsservicos","text":"Com tantas vantagens, suge a d\u00favida se todos os sistemas deveriam ser desenvolvidos usando-se a arquitetura de microsservi\u00e7os. A resposta \u00e9 n\u00e3o , pois como colocado no in\u00edcio desta se\u00e7\u00e3o, n\u00e3o existem balas de prata e se um sistema monol\u00edtico est\u00e1 funcionando para voc\u00ea e n\u00e3o h\u00e1 perspectiva de problemas acometerem (a demanda no sistema n\u00e3o est\u00e1 aumentando, a l\u00f3gica do sistema \u00e9 muito simples, indisponibilidade n\u00e3o te traz preju\u00edzo, voc\u00ea n\u00e3o pode arcar com a refatora\u00e7\u00e3o), ent\u00e3o mantenha seu sistema como est\u00e1. Caso haja a necessidade de evolu\u00e7\u00e3o e o modelo de microsservi\u00e7os pare\u00e7a adequado, existem recomenda\u00e7\u00f5es de como a migra\u00e7\u00e3o pode ser feita. Primeiro, \u00e9 preciso aceitar que o desenvolvimento de microsservi\u00e7os afeta a organiza\u00e7\u00e3o do time de desenvolvimento e que a organiza\u00e7\u00e3o provavelmente refletir\u00e1 a arquitetura. O desenvolvimento, manuten\u00e7\u00e3o e opera\u00e7\u00e3o de microsservi\u00e7os acontece em times pequenos, de 1 a 8 pessoas (\"pizza team\"), dependendo da complexidade do servi\u00e7o; se houver a necessidade de mais pesssoas no time, o escopo do microsservi\u00e7o provavelmente est\u00e1 grande demais; cada componente resolve um problema, bem. Segundo, a mudan\u00e7a n\u00e3o dever\u00e1 acontecer atomicamente. Uma boa estrat\u00e9gia \u00e9 identificar uma parte do sistema que funcionaria bem como microsservi\u00e7o, desenvolv\u00ea-la e modificar o monolito para usar o microsservi\u00e7o. O aprendizado ent\u00e3o \u00e9 usado para encontrar novo candidato e o procedimento \u00e9 iterado at\u00e9 que o monolito seja apenas uma casca e possa tamb\u00e9m ser removido. Mais f\u00e1cil dito que feito, h\u00e1 muita documenta\u00e7\u00e3o orientando o processo. Para saber mais Como esta arquitetura n\u00e3o faz parte ainda do nosso curr\u00edculo, n\u00e3o nos aprofundaremos nela aqui. Felizmente h\u00e1 muito material na Web sobre este modelo, sendo a lista a seguir uma \u00ednfima fra\u00e7\u00e3o. Para uma explica\u00e7\u00e3o geral do que s\u00e3o, assista a Martin Fowler no v\u00eddeo seguinte, assista ou consulte os v\u00e1rios artigos no seu s\u00edtio . Para entender os princ\u00edpios por tr\u00e1s do uso da arquitetura, Para um exemplo importante do uso de microsservi\u00e7os, considere a Netflix, que usa microsservi\u00e7os em larga escala em seus servi\u00e7os. Qu\u00e3o larga? \"...over five hundred services... we don't know how many...\" Apesar de tal uso, ou justamente por causa dele, seus servi\u00e7os mant\u00e9m uma \"...availability of 9.995...\", ou seja, ficam indispon\u00edveis por menos de 16 segundos por ano . Com respeito a estar preparado para falhas, afinal \"... it is not if failures will happen... ... it is when it happens...\", a empresa usa uma abordagem de inje\u00e7\u00e3o de falhas em servi\u00e7os em produ\u00e7\u00e3o. Os diferentes tiposde falhas s\u00e3o injetados por um \" ex\u00e9rcito de macacos do caos \" Para uma vis\u00e3o pr\u00e1tica da implementa\u00e7\u00e3o de microsservi\u00e7os usando AWS, veja TODO SOA - Foco no uso de outras formas de comunica\u00e7\u00e3o para chegar em outras arquiteturas. MOM Publish/Subscribe Message Queues Event Sourcing Stream Processing/Event Sourcing Kafka Overview Se voc\u00ea n\u00e3o pegou a refer\u00eancia, volte uma casa 2 um cap\u00edtulo. \u21a9 Se voc\u00ea n\u00e3o pegou esta refer\u00eancia, n\u00e3o teve inf\u00e2ncia. \u21a9 Neste problema do ICPC, um esquema de nomea\u00e7\u00e3o dos n\u00f3s de um hypercube \u00e9 apresentado; usando este esquema, derive um algoritmo de roteamento em que a dist\u00e2ncia percorrida por qualquer mensagem seja sempre igual ao n\u00famero de dimens\u00f5es do cubo. \u21a9 Observe que as dist\u00e2ncias entre os n\u00f3s no anel foram desenhadas de forma proporcial \u00e0 diferen\u00e7a num\u00e9rica entre os identificadores. \u21a9 Este exemplo \u00e9 meramente ilustrativo e n\u00e3o segue estritamente a sintaxe do CQL. \u21a9 \"The hype cycle is a branded graphical presentation developed and used by the American research, advisory and information technology firm Gartner, for representing the maturity, adoption and social application of specific technologies.\" \u21a9 Peak of Inflated - Expectations Early publicity produces a number of success stories\u2014often accompanied by scores of failures. Some companies take action; most don't. Technology Trigger -- A potential technology breakthrough kicks things off. Early proof-of-concept stories and media interest trigger significant publicity. Often no usable products exist and commercial viability is unproven. Slope of Enlightenment -- More instances of how the technology can benefit the enterprise start to crystallize and become more widely understood. Second- and third-generation products appear from technology providers. More enterprises fund pilots; conservative companies remain cautious. Plateau of Productivity -- Mainstream adoption starts to take off. Criteria for assessing provider viability are more clearly defined. The technology's broad market applicability and relevance are clearly paying off. Trough of Disillusionmen - Interest wanes as experiments and implementations fail to deliver. Producers of the technology shake out or fail. Investment continues only if the surviving providers improve their products to the satisfaction of early adopters. \u21a9 \u21a9","title":"Do Monolito aos Microsservi\u00e7os"},{"location":"teaching/gbc074gsi028/basics/","text":"Fundamentos A pedra fundamental da constru\u00e7\u00e3o de sistemas distribu\u00eddos \u00e9 a capacidade de comunica\u00e7\u00e3o entre seus componentes. No mundo de hoje, isto quer dizer que os hosts dos componentes devem possuir interfaces de rede e que estas interfaces estejam ligadas a uma rede com capacidade de roteamento de dados, estabelecendo um canal de comunica\u00e7\u00e3o entre os componentes. Al\u00e9m do canal, \u00e9 tamb\u00e9m necess\u00e1rio que se estabele\u00e7a um protocolo de comunica\u00e7\u00e3o , que define as regras para que a comunica\u00e7\u00e3o aconte\u00e7a, por exemplo, a gram\u00e1tica para forma\u00e7\u00e3o de mensagens. Tamb\u00e9m importantes, de um ponto de vista pr\u00e1tico do desenvolvimento, s\u00e3o os conceitos de concorr\u00eancia e paralelismo. Afinal, um componente pode necessitar manter v\u00e1rias \"conversas\" em paralelo com m\u00faltiplos outros componentes. Neste cap\u00edtulo, revisaremos de forma r\u00e1pida tanto conceitos de redes de computadores quanto de concorr\u00eancia e paralelismo. Canais e Protocolos de Comunica\u00e7\u00e3o Um canal de comunica\u00e7\u00e3o \u00e9 o meio pelo qual os elementos da conversa entre os componentes do sistema distribu\u00eddo s\u00e3o transmitidos e o protocolo s\u00e3o as regras codificam tal conversa. Por exemplo, quando voc\u00ea fala com uma pessoa, cara-a-cara, o meio de comunica\u00e7\u00e3o \u00e9 o ar e o protocolo utilizado \u00e9 a linguagem conhecida pelas duas partes, o Portugu\u00eas por exemplo. Na pr\u00e1tica, canais de comunica\u00e7\u00e3o podem ter diversas formas e caracter\u00edsticas, por exemplo: Ponto-a-ponto Eficiente Caro para muitos n\u00f3s Roteamento trivial Compartilhado Colis\u00f5es Menor custo Roteamento mais complicado Nas redes atuais, pode se dizer que o meio mais utilizado \u00e9 provido pela arquitetura Ethernet , que trata da comunica\u00e7\u00e3o n\u00f3s usando um barramento compartilhado . Sobre este meio, s\u00e3o usados protocolos para, por exemplo, Controle de acesso ao meio Transmiss\u00e3o de mensagens Evitar e tratar colis\u00f5es As redes Ethernet, contudo, cobrem pequenas \u00e1reas e para se ter conversas \"mais interessantes\", \u00e9 necess\u00e1rio que se conecte diversas destas redes. A conversa ent\u00e3o \u00e9 feita por meio de intermedi\u00e1rios, ** gateways ** que conectam duas ou mais redes, permitindo que mensagens de um interlocutor sejam roteadas para o outro, via tais intermedi\u00e1rios. Um exemplo interessante das quest\u00f5es ligadas \u00e0 manuten\u00e7\u00e3o da conversa entre dois pontos \u00e9 a decis\u00e3o sobre o uso de comuta\u00e7\u00e3o de pacotes ( packet switching ) ou de circuitos ( circuit switching ). Comuta\u00e7ao de pacotes Dados divididos em pacotes Cada pacote viaja independentemente Pacotes s\u00e3o perdidos Lat\u00eancia vari\u00e1vel Circuit switching Caminho dedicado Recursos reservados Pacotes de tamanho fixo Lat\u00eancia constante Outro fator importante \u00e9 o MTU, o tamanho m\u00e1ximo de um pacote em determinada rede. \u00c9 necess\u00e1rio entender que qualquer quantidade de dados maior que o MTU precisar\u00e1 ser dividida em m\u00faltiplos pacotes. Tamb\u00e9m \u00e9 importante perceber que redes s\u00e3o heterog\u00eaneas, e que o v\u00e1rios segmentos no caminho entre origem e destino podem ter MTU diferentes, levando \u00e0 fragmenta\u00e7\u00e3o de pacotes em tr\u00e2nsito e, possivelmente, entrega desordenada dos mesmos. Finalmente, h\u00e1 a quest\u00e3o importante \u00e9 relativa \u00e0 confiabilidade na transmiss\u00e3o dos elementos da conversa, isto \u00e9, se a rede deve garantir ou n\u00e3o que algo \"dito\" por um interlocutor deve garantidamente ser \"ouvido\" pelo outro, ou se a mensagem pode ser perdida no meio. Felizmente boa parte da complexidade da resolu\u00e7\u00e3o destas quest\u00f5es \u00e9 abstra\u00edda do desenvolvedor dos sistemas distribu\u00eddos, isto \u00e9, voc\u00ea , lhe cabendo apenas a decis\u00e3o de qual protocolo utilizar. Nas redes atuais, a conversa em componentes ser\u00e1 feita, em algum n\u00edvel, por meio dos protocolos da arquitetura Internet . A Internet A Internet tem este nome por usar o protocolo de interconex\u00e3o de redes indepententes, o internetworking protocol , ou IP. Para a aplica\u00e7\u00e3u usando o IP, todas as redes se comportam com uma \u00fanica e coerente rede, exceto por alguns detalhes. Os elementos que conectam as diversas redes s\u00e3o denominados roteadores e fazem um melhor esfor\u00e7o para encaminhar os pacotes de dados do remetente ao destinat\u00e1rio. Se voc\u00ea se lembrar da pilha de protocolos de comunica\u00e7\u00e3o de refer\u00eancia OSI, lembrar\u00e1 que h\u00e1 sete camadas na mesma. Cada camada \u00e9 respons\u00e1vel pela comunica\u00e7\u00e3o em um n\u00edvel e serve de funda\u00e7\u00e3o para a funcionalidade da camada de cima. Cada camada tem um cabe\u00e7alho ( header ) e uma carga ( payload ) e o conjunto de cabe\u00e7alho + carga de uma camada \u00e9 considerado carga da camada inferior. Assim, embora tenha-se a impress\u00e3o de que cada camada conversa com a equivalente do outro lado da comunica\u00e7\u00e3o, na pr\u00e1tica, a comunica\u00e7\u00e3o desce e sobe a pilha. Bits Frames/quadros; controle de fluxo; acesso ao meio. Datagramas/pacotes; roteamento Controle de fluxo; fim a fim; confiabilidade; tcp e udp Streams/fluxos; conex\u00f5es l\u00f3gicas; restart; checkpoint; http, ssl Objetos; json, xml; criptografia Aplica\u00e7\u00f5es; http, pop, ftp Embora o IP se refira estritamente ao protocolo da camada 3 da pilha, nos referimos \u00e0 pilha que usa este protocolo como a pilha IP. Comparada \u00e0 pilha OSI, a IP \u00e9 mais simples, como se v\u00ea na figura. Como usu\u00e1rios da pilha IP, temos que entender como a camada 3 funciona, mas dificilmente interagiremos com algo al\u00e9m da camada 4, a camada de transporte . Como se v\u00ea, as camadas 5 e 6 n\u00e3o est\u00e3o presentes na pilha IP e as funcionalidades correspondentes s\u00e3o implementadas na camada 7, de aplica\u00e7ao. Contudo, n\u00e3o tema! Estas funcionalidades podem se normalmente implementadas por meio de frameworks ou do middleware em uso. Alguns exemplos de tais funcionalidades s\u00e3o (De)Serializa\u00e7\u00e3o Nomeamento Criptografia Replica\u00e7\u00e3o Invoca\u00e7\u00e3o remota de procedimentos A grande vantagem desta abordagem \u00e9 que se pode implementar exatamente e somente as funcionalidades desejadas. Este caracter\u00edstica \u00e9 conhecida como o argumento fim-a-fim no projeto de sistemas ; uma an\u00e1lise recente deste argumento foi feita aqui . No princ\u00edpio, era o Socket Na pr\u00e1tica, para implementarmos a comunica\u00e7\u00e3o entre processos, usamos sockets . Para se definir um socket a partir de um host \u00e9 necess\u00e1rio identificar o outro fim da comunica\u00e7\u00e3o, isto \u00e9, o outro host , ou melhor, uma de suas interfaces de rede. Os sockets s\u00e3o ent\u00e3o a abstra\u00e7\u00e3o dos canais de comunica\u00e7\u00e3o, mas como dito antes, \u00e9 necess\u00e1rio definir tamb\u00e9m os protocolos usados por estes sockets. O primeiro protocolo \u00e9 o de endere\u00e7amento, que define qual pilha de protocolos usar, na camada 3. No caso da pilha IP, usa-se o protocolo AF_INET ou PF_INET. Escolhido o protocolo, cada interface tem um endere\u00e7o MAC, na camada 2, que o identifica entre as interfaces na mesma rede local, e cada interface tem um endere\u00e7o IPv4/IPv6 de 32/128 bits, que o indentifica entre todos os hosts na Internet 1 . Mas dentro de um host , podem haver diversas aplica\u00e7\u00f5es sendo executadas. Como identificar exatamente com qual se quer conversar? Isto \u00e9 feito pela defini\u00e7\u00e3o uma porta: Porta: 16 bits IANA (Internet Assigned Numbers Authority) Bem conhecidas -- 0-1023 Propriet\u00e1rias -- 49151 Din\u00e2micas -- 65535 Tamb\u00e9m \u00e9 necess\u00e1rio definir tamb\u00e9m o protocolo de transporte dos dados, na camada 4. Novamente, no caso da pilha IP, pode-se usar TCP ( SOCK_STREAM ) ou UPD ( SOCK_DGRAM ). A API usada para estabelecer a conversa via socket tem v\u00e1rias chamadas, que devem ser executadas na ordem certa no processo iniciando a conversa e naquele que aceita participar da mesma. Comecemos estudando o TCP. TCP O fluxograma da cria\u00e7\u00e3o de um socket TCP \u00e9 apresentado na seguinte figura: stateDiagram-v2 Servidor --> Entrada/Sa\u00edda Cliente --> Entrada/Sa\u00edda Entrada/Sa\u00edda --> sc state Servidor { ss: Cria socket sb: Associa porta sl: Escuta conex\u00f5es sa: Aceita conex\u00f5es ss --> sb sb --> sl sl --> sa } state Entrada/Sa\u00edda { leitura --> escrita escrita --> leitura } state Cliente { cs: Cria socket cc: Inicia conex\u00e3o cs --> cc } state sc: Fecha conex\u00e3o Estabelecido o socket, o mesmo pode ser usado como arquivo , isto \u00e9, lendo-se e escrevendo-se bytes. O que exatamente deve ser escrito e como o que \u00e9 lido deve ser interpretado \u00e9 o protocolo da camada 7, sua responsabilidade . Vejamos um exemplo do uso de sockets, em Python. O seguinte arquivo pode ser nomeado, por exemplo, server.py , mas n\u00e3o pode, de forma alguma, ser nomeado socket.py . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #server.py #!/usr/bin/python # This is server.py file import socket # Import socket module s = socket . socket () # Create a socket object host = socket . gethostname () # Get local machine name port = 12345 # Reserve a port for your service. s . bind (( host , port )) # Bind to the port s . listen ( 5 ) # Now wait for client connections. while True : c , addr = s . accept () # Establish connection with client. print ( 'Got connection from' , addr ) c . send ( 'Thank you for connecting' . encode ()) c . close () # Close the connection Para execut\u00e1-lo, execute o seguinte comando em um terminal. 1 python server.py Em outro terminal, execute um dos dois comandos a seguir 2 : 1 telnet localhost 12345 1 netcat localhost 12345 O que est\u00e1 acontecendo aqui \u00e9 um processo criou um socket e ficou aguardando uma conex\u00e3o, usando o c\u00f3digo em Python. Tanto o telnet quando o netcat s\u00e3o programas gen\u00e9ricos para se conversar com outro processo usando TCP/IP. Aqui, estes programas simplesmente se conectaram e imprimiram o que quer que o primeiro processo lhes tenha enviado, assumindo que correspondia a uma string, o que neste caso \u00e9 correto. Simples, n\u00e3o \u00e9 mesmo? Em geral, denominamos o processo que fica aguardando a conex\u00e3o de servidor e o processo que se conecta de cliente . Isto por qu\u00ea, em geral, o servidor executa alguma tarefa, serve, o cliente, embora isto n\u00e3o seja necessariamente verdade. Por completude, vamos tamb\u00e9m escrever o c\u00f3digo do cliente, agora que voc\u00ea j\u00e1 sabe que o servidor funciona. Do lado cliente, estabelece-se uma conex\u00e3o apontando-se para onde est\u00e1 o servidor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #client.py #!/usr/bin/python # This is client.py file import socket # Import socket module s = socket . socket () # Create a socket object host = socket . gethostname () # Get local machine name port = 12345 # Reserve a port for your service. s . connect (( host , port )) data = s . recv ( 1024 ) print ( data . decode ()) s . close () # Close the socket when done E para se executar o cliente, fa\u00e7a: 1 python client.py Observe que o socket.close() encerra a conex\u00e3o do lado de quem invoca. Na contraparte, invoca\u00e7\u00f5es a socket.recv() retornam com 0 bytes lidos. A t\u00edtulo de compara\u00e7\u00e3o, em Java, a cria\u00e7\u00e3o do socket do lado do servidor seria muito mais simples, consistindo apenas em: 1 Socket s = new ServerSocket ( port ); O cliente em Java tamb\u00e9m \u00e9 simplificado. 1 Socket s = new Socket ( hostname , port ); Exerc\u00edcio: M\u00faltiplos Pacotes Fa\u00e7amos agora uma modifica\u00e7\u00e3o no c\u00f3digo do servidor para que envie n\u00e3o uma, mas duas mensagens para o cliente. Isto \u00e9, modifique seu servidor assim 1 2 3 4 ... c . send ( 'Thank you for connecting' . encode ()) c . send ( 'Come back often' . encode ()) ... Agora execute novamente o cliente e veja o que acontece. Consegue explicar o fen\u00f4meno? Modifiquemos o cliente agora, para que tenha dois recv , assim. 1 2 3 4 5 6 7 8 ... print ( \"1\" ) data = s . recv ( 1024 ) print ( data . decode ()) print ( \"2\" ) data = s . recv ( 1024 ) print ( data . decode ()) ... E agora, o que acontece? A sa\u00edda \u00e9 como esperava? Como explica este fen\u00f4meno e como poderia corrig\u00ed-lo? Exerc\u00edcio: Ping-Pong Modifique cliente e servidor tal que o cliente envie uma mensagem passada na linha de comando ao servidor e fique esperando uma resposta, e tal que o servidor fique esperando uma mensagem e ent\u00e3o solicite ao operador que digite uma resposta e a envie para o cliente. O loop continua at\u00e9 que o usu\u00e1rio digite SAIR, e a conex\u00e3o seja encerrada. Terminal 1 Terminal 2 python server.py python client.py Esperando conex\u00e3o. conectando-se ao servidor Conectado Conectado Esperando mensagem Digite mensagem: lalala Mensagem enviada Mensagem recebida: lalala Esperando resposta Digite resposta: lelele Resposta enviada. Resposta recebida: lelele Digite mensagem: SAIR Desconectando. Conex\u00e3o encerrada. Esperando conex\u00e3o. Observe que para ler do teclado em Python 2 voc\u00ea deve usar x = raw_input () , enquanto que em Python 3 seria x = input () . Al\u00e9m disso, em Python 2, voc\u00ea deve remover as invoca\u00e7\u00f5es para encode e decode . UDP No exemplo anterior, usamos o protocolo TCP (o padr\u00e3o da API). Caso quis\u00e9ssemos usar UDP, precisar\u00edamos nos atentar a alguns detalhes. A cria\u00e7\u00e3o do socket \u00e9 feita explicitando-se o uso de datagramas : s = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) Um servidor UDP n\u00e3o executa listen ou accept e, em Python, simplesmente executa data , addr = sock . recvfrom ( 4096 ) para receber o datagrama, onde data \u00e9 o conte\u00fado recebido e addr o endere\u00e7o de quem enviou o datagrama. Neste caso, um mesmo socket \u00e9 usado para manter comunica\u00e7\u00e3o com m\u00faltiplos interlocutores. Para enviar uma resposta a um interlocutor em espec\u00edfico, addr \u00e9 usado: sent = sock . sendto ( data , addr ) , onde sent \u00e9 a quantidade de bytes enviados. Al\u00e9m deste detalhe, \u00e9 importante manter em mente outras caracter\u00edsticas do UDP: falta de ordem falta de confiabilidade menos dados lidos que enviados. mais dados lidos que enviados (pode acontecer tamb\u00e9m no TCP) Com tantas dificuldades para se usar o UDP, fica a quest\u00e3o: para que serve UDP? Exerc\u00edcio: Ping-Pong UDP Modifique o c\u00f3digo do exerc\u00edcio Ping-Pong para usar UDP em vez de TCP na comunica\u00e7\u00e3o entre n\u00f3s. Execute m\u00faltiplos clientes ao mesmo tempo. Como o seu servidor lida com isso? Modifique-o para mandar um \"eco\" da mensagem recebida de volta ao remetente. IP-Multicast Imagine que voc\u00ea tenha que enviar um stream de v\u00eddeo para um destinat\u00e1rio, mostrando como voc\u00ea est\u00e1 jogando o mais novo jogo da velha no mercado. Qual protocolo de transporte voc\u00ea usaria? TCP, provavelmente, j\u00e1 que garante a entrega ordenada dos pacotes do v\u00eddeo. Como voc\u00ea j\u00e1 sabe, o TCP envia confirma\u00e7\u00f5es de pacotes recebidos e usa uma janela deslizante para determinar quais pacotes reenviar, o que pode causar interrup\u00e7\u00f5es na execu\u00e7\u00e3o do v\u00eddeo. Al\u00e9m do mais, as pessoas provavelmente preferir\u00e3o perder alguns quadros que perder a sincronia com sua excitante partida. Parece que uma op\u00e7\u00e3o melhor seria ent\u00e3o usar UDP, correto? Imagine agora que os mesmos dados devam ser enviados para m\u00faltiplos destinat\u00e1rios (voc\u00ea est\u00e1 ficando famoso!) Com m\u00faltiplos destinat\u00e1rios, m\u00faltiplos controles precisariam ser mantidos no TCP, o que pode se tornar custoso; mais uma raz\u00e3o para usar UDP! Para terminar, lhe darei uma raz\u00e3o final: IP-Multicast! Multicast, em oposi\u00e7\u00e3o ao Unicast, \u00e9 a capacidade de enviar mensagens para um grupo de destinat\u00e1rios, em vez de apenas um. IP-Multicast \u00e9 uma implementa\u00e7\u00e3o desta ideia, usando umaa configura\u00e7\u00e3o espec\u00edfica do UDP, associada a recursos dos comutadores de rede, para otimizar o envio dos mesmos dados a m\u00faltiplos destinat\u00e1rios. Grupos s\u00e3o identificados por endere\u00e7os IP especiais, conhecidos como Classe D (224.0.0.0-239.255.255.255), e propagados pela rede. A seguinte tabela descreve os usos das sub-faixas de endere\u00e7os. 3 Endere\u00e7o Uso 224.0.0.0-224.0.0.255 Multicast local - Usado por protocolos L2, como EIGRP e OSPF 224.0.1.0-224.0.1.255 Multicast roteaddo - Usado por protocolos L3 232.0.0.0-232.255.255.255 Source Specific Multicast - Receptores definem fontes confi\u00e1veis 233.0.0.0-233.255.255.255 Reservado para detentores Autonomous Systems 239.0.0.0-239.255.255.255 Reservado para IANA Resto Uso geral Quando um pacote \u00e9 enviado para o endere\u00e7o do grupo, todos os membros do grupo recebem tal mensagem. Melhor dizendo, todos os membros podem receber a mensagem, mas como estamos falando de UDP, \u00e9 poss\u00edvel que alguns n\u00e3o recebam . Al\u00e9m disso, n\u00e3o h\u00e1 garantia qualquer sobre a ordem de recep\u00e7\u00e3o das mensagens . Apenas refor\u00e7ando, IP-Multicast s\u00f3 funciona com UDP, pois lidar com retransmiss\u00f5es em um grupo grande levaria a um estado imenso sendo mantido na origem dos dados. Outro ponto importante \u00e9 que pelo podencial desestabilizador do IP-Multicast, ele \u00e9 normalemente limitado \u00e0 pequenas se\u00e7\u00f5es das redes. Mas experimentemos com esta tecnologia na pr\u00e1tica. Criemos um programa que criar Socket UDP , associa-o a um grupo , e recebe pacotes destinados ao grupo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // MReceiver.java import java.io.* ; import java.net.* ; public class MReceiver { public static void main ( String [] args ) { byte [] inBuf = new byte [ 256 ] ; try { MulticastSocket socket = new MulticastSocket ( 8888 ); InetAddress address = InetAddress . getByName ( \"224.2.2.3\" ); socket . joinGroup ( address ); while ( true ) { DatagramPacket inPacket = new DatagramPacket ( inBuf , inBuf . length ); socket . receive ( inPacket ); String msg = new String ( inBuf , 0 , inPacket . getLength ()); System . out . println ( \"From \" + inPacket . getAddress () + \" Msg : \" + msg ); } } catch ( IOException ioe ) { System . out . println ( ioe ); } } } Instancie m\u00faltiplos processos deste, na mesma m\u00e1quina e em m\u00e1quinas distintas. Agora criemos um programa que envia pacotes para o dito grupo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // MSender.java import java.io.* ; import java.net.* ; public class MSender { public static void main ( String [] args ) { byte [] outBuf ; final int PORT = 8888 ; try { DatagramSocket socket = new DatagramSocket (); long counter = 0 ; InetAddress address = InetAddress . getByName ( \"224.2.2.3\" ); while ( true ) { counter ++ ; outBuf = ( \"Multicast numero \" + counter + \" \" + address ). getBytes (); DatagramPacket outPacket = new DatagramPacket ( outBuf , outBuf . length , address , PORT ); socket . send ( outPacket ); try { Thread . sleep ( 500 ); } catch ( InterruptedException ie ) {} } } catch ( IOException ioe ) { System . out . println ( ioe ); } } } Observe como a mesma mensagem \u00e9 recebida pelos v\u00e1rios membros e que como diferentes fontes tem seus pacotes recebidos. A t\u00edtulo de curiosidade, IP-Multicast tamb\u00e9m est\u00e1 presente em IPv6, mas com algumas pequenas diferen\u00e7as IP-Multicast em IPv6 4 In IPv6, the left-most bits of an address are used to determine its type. For a multicast address, the first 8 bits are all ones, i.e. FF00::/8. Further, bit 113-116 represent the scope of the address, which can be either one of the following 4: Global, Site-local, Link-local, Node-local. In addition to unicast and multicast, IPv6 also supports anycast, in which a packet can be sent to any member of the group, but need not be sent to all members.'' Exerc\u00edcio: IP-Multicast Implemente e teste o seguinte sevidor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import socket import struct MCAST_GRP = '224.1.1.1' MCAST_PORT = 5007 sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM , socket . IPPROTO_UDP ) sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , 1 ) sock . bind (( MCAST_GRP , MCAST_PORT )) mreq = struct . pack ( \"=4sl\" , socket . inet_aton ( MCAST_GRP ), socket . INADDR_ANY ) #4 bytes (4s) seguidos de um long (l), usando ordem nativa (=) sock . setsockopt ( socket . IPPROTO_IP , socket . IP_ADD_MEMBERSHIP , mreq ) while True : print ( sock . recv ( 10240 ) . decode ()) Implemente e teste o seguinte cliente. 1 2 3 4 5 6 7 8 import socket MCAST_GRP = '224.1.1.1' MCAST_PORT = 5007 sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM , socket . IPPROTO_UDP ) sock . setsockopt ( socket . IPPROTO_IP , socket . IP_MULTICAST_TTL , 2 ) sock . sendto ( input () . encode (), ( MCAST_GRP , MCAST_PORT )) Refer\u00eancias UDP em Python UDP em Python Multicast em Java Multicast em Python Multiprograma\u00e7\u00e3o e Multithreading em Sistemas Distribu\u00eddos \u00c9 imposs\u00edvel pensar em sistemas distribu\u00eddos sem pensar em concorr\u00eancia na forma de m\u00faltiplos processos executando, normalmente, em hosts distintos. De fato, os exemplos que apresentamos at\u00e9 agora consistem todos em um processo cliente requisitando a\u00e7\u00f5es de algum processo servidor. Apesar disso, a intera\u00e7\u00e3o entre tais processos aconteceu sempre de forma sincronizada, lock-step , em que o cliente requisitava o servi\u00e7o e ficava bloqueado esperando a resposta do servidor, para ent\u00e3o prosseguir em seu processamento, e o servidor fica bloqueado esperando requisi\u00e7\u00f5es, que atende e ent\u00e3o volta a dormir. Este cen\u00e1rio, apresentado na figura a seguir, mostra que apesar do uso de processadores distintos e da concorr\u00eancia na execu\u00e7\u00e3o dos processos, temos um baixo grau de efetivo paralelismo. sequenceDiagram activate Cliente note left of Cliente: Ativo (gerando requisi\u00e7\u00e3o) note right of Servidor: Inativo (esperando requisi\u00e7\u00e3o) Cliente->>+Servidor: Request deactivate Cliente note left of Cliente: Inativo (esperando resposta) note right of Servidor: Ativo (processando requisi\u00e7\u00e3o) Servidor-->>-Cliente: Response activate Cliente note left of Cliente: Ativo (processando resposta note right of Servidor: Inativo (esperando requisi\u00e7\u00e3o) deactivate Cliente Para usarmos melhor os recursos dispon\u00edveis, tanto do lado dos clientes quanto servidores, uma das raz\u00f5es de ser da computa\u00e7\u00e3o distribu\u00edda, temos ent\u00e3o que pensar em termos eventos sendo disparados entre os componentes, que devem ser tratados assim que recebidos ou t\u00e3o logo haja recursos para faz\u00ea-lo. Estes eventos correspondem tanto a requisi\u00e7\u00f5es quanto a respostas (efetivamente tornando dif\u00edcil a distin\u00e7\u00e3o). Al\u00e9m disso, sempre que poss\u00edvel, um componente n\u00e3o deve ficar exclusivamente esperando por eventos, aproveitando a chance executar outras tarefas at\u00e9 que eventos sejam recebidos. Dada que processos interagem com a rede usando sockets, cuja opera\u00e7\u00e3o de leitura \u00e9 bloqueante, para aumentar a concorr\u00eancia em um processo, precisamos falar de multi-threading. H\u00e1 duas raz\u00f5es claras para estudarmos multi-threading. A primeira, de ordem pr\u00e1tica, \u00e9 a discutida acima: permitir o desenvolvimento de componentes que utilizem \"melhormente\" os recursos em um host. A segunda, did\u00e1tica, \u00e9 o fato que muitos dos problemas que aparecem em programa\u00e7\u00e3o multi-thread, aparecem em programa\u00e7\u00e3o multi-processo (como nos sistemas distribu\u00eddos), apenas em um grau de complexidade maior. Para relembrar, h\u00e1 v\u00e1rias diferen\u00e7as entre threads e processos, mas a abstra\u00e7\u00e3o \u00e9 essencialmente a mesma: Processo Thread Inst\u00e2ncia de um programa \"Processo leve\" Estado do processo Estado do thread Fun\u00e7\u00e3o main \"qualquer\" fun\u00e7\u00e3o Mem\u00f3ria privada ao processo Compartilha estado do processo que os cont\u00e9m C\u00f3digo, Stack, Heap, descritores (e.g, file descriptors), controle de acesso Stack, vari\u00e1veis locais IPC - Inter process communication IPC -- Inter process communication Sistema operacional Diferentes implementa\u00e7\u00f5es Posix, C++, Java, ... Vejamos como o uso de m\u00faltiplos threads podem melhorar o desenvolvimento de sistemas distribu\u00eddos na pr\u00e1tica. Considere os exemplos de clientes e servidores vistos anteriormente . Imagine que em vez do servi\u00e7o simples feito no exemplo, o servidor retorne uma p\u00e1gina Web. Detalhes do protocolo seguido por navegadores e servidores ser\u00e3o vistos mais tarde. Por agora, considere apenas que uma requi\u00e7\u00e3o GET arquivo.html ser\u00e1 enviada para o servidor que ler\u00e1 o arquivo especificado do sistema de arquivos; como voc\u00ea sabe, ler um arquivo \u00e9 uma opera\u00e7\u00e3o lenta e que n\u00e3o requer CPU. Cliente multithreaded Do ponto de vista do cliente, a vantagem do uso de m\u00faltiplos threads s\u00e3o claras: permite lidar com v\u00e1rias tarefas concorrentemente , por exemplo solicitar CSS, HTML e imagens concorrentemente, escondendo lat\u00eancia das v\u00e1rias opera\u00e7\u00f5es, e permite organizar c\u00f3digo em blocos/m\u00f3dulos. Se voc\u00ea usar o console de desenvolvimento do navegador, ver\u00e1 que trinta e seis requisi\u00e7\u00f5es s\u00e3o feitas para carregar a p\u00e1gina www.google.com ; um n\u00famero muito maior \u00e9 feito na carga de www.bing.com . Bug Estender Servidor multithreaded Single-threaded H\u00e1 diversas possibilidades de uso de threads em servidores. A mais simples \u00e9 usar apenas um, com temos feito at\u00e9 agora: o cliente envia a requisi\u00e7\u00e3o para o servidor o servidor aceita a conex\u00e3o em seu \u00fanico thread uma tarefa \u00e9 gerada para ler o arquivo o arquivo \u00e9 lido, de forma bloqueante, e uma resposta para o cliente \u00e9 preparada a resposta \u00e9 enviada para o cliente, de forma bloqueante a requisi\u00e7\u00e3o \u00e9 descartada o thread do servidor volta a esperar uma nova requisi\u00e7\u00e3o Thread per request Outra op\u00e7\u00e3o \u00e9 criar um novo thread para cada nova requisi\u00e7\u00e3o, levando a m\u00faltiplos threads atendendo a m\u00faltiplas requisi\u00e7\u00f5es concorrentemente. Desta forma, quando um thread \u00e9 bloqueado para leitura de arquivos do disco, outros clientes podem continuar sendo atendidos. Contudo, o n\u00famero de threads que se pode criar em um SO \u00e9 limitado. Al\u00e9m disso, a cria\u00e7\u00e3o e destrui\u00e7\u00e3o de threads \u00e9 cara e por isso devemos evitar este processo. Thread pool Assim, temos uma outra op\u00e7\u00e3o que tamb\u00e9m usa m\u00faltiplos threads, que usa pools de threads para lidar com as requi\u00e7\u00f5es. No cerne desta abordagem, junto com um pool de threads, fica uma fila bloquenante thread-safe , isto \u00e9, que se mantem correta mesmo quando m\u00faltiplos threads operam nela tanto para inserir quanto remover tarefas, e que bloqueia os threads que tentam inserir quando a fila est\u00e1 cheia ou remover quando ela est\u00e1 vazia. Um thread principal \u00e9 encarregado de receber as requisi\u00e7\u00f5es e colocar na fila bloqueante; se a fila fica cheia, o thread principal fica bloqueado esperando por espa\u00e7o, fazendo com que novas conex\u00f5es tenham que esperar. Os threads do pool removem uma tarefa da fila, a tratam e, ao final do atendimento, pegam nova requisi\u00e7\u00e3o na fila, em um loop infinito; se a fila se esvazia, os threads ficam bloqueados esperando novas requisi\u00e7\u00f5es. \u00c9 poss\u00edvel refinar mais este modelo, quebrando o processamento em v\u00e1rios pools, no que \u00e9 conhecido como Staged Event-Driven Architecture , SEDA. Nesta abordagem, cada est\u00e1gio , por ter seu pr\u00f3prio pool , pode ser escalado individualmente de acordo com a demanda do est\u00e1gio. Esta abordagem tamb\u00e9m \u00e9 \u00fatil quando m\u00faltiplas partes da tarefa consistem em E/S. Uma extrapola\u00e7\u00e3o que pode ser feita aqui, refor\u00e7ando a observa\u00e7\u00e3o que problemas (e solu\u00e7\u00f5es) de sistemas distribu\u00eddos s\u00e3o refletidos em n\u00edvel de processamento paralelo e concorrente, \u00e9 que a uma arquitetura SEDA lembra em muito a arquitetura de micro-servi\u00e7os . Para aprender mais sobre SEDA, v\u00e1 aqui . TODO Problemas com multithreading Embora a ideia de usar m\u00faltiplos threads seja resolver problemas, faz\u00ea-lo efetivamente n\u00e3o trivial. Vejamos, por exemplo, o problema de definir afinidade entre threads, isto \u00e9, de definir quais threads compartilham o mesmo estado de forma que threads afins sejam colocados nos mesmos processadores e compartilhem as mesmas mem\u00f3rias. Isto torna muito mais f\u00e1cil e eficiente o controle de concorr\u00eancia, do ponto de vista do SO e hardware. A realidade, contudo, \u00e9 outra e simplesmente criar m\u00faltiplos threads n\u00e3o garante paralelismo perfeito, pois o SO \u00e9 quem \u00e9 respons\u00e1vel por escalonar os mesmos, e \u00e9 dif\u00edcil determinar (se existir) uma configura\u00e7\u00e3o \u00f3tima em termos de afinidade que seja tamb\u00e9m eficiente. Memes bonitinhos \u00e0 parte, precisamos lidar com estado compartilhado e enfrentar condi\u00e7\u00f5es de corrida de forma a n\u00e3o levar a inconsist\u00eancias na executa\u00e7\u00e3o de tarefas, nos referindo a inconsist\u00eancia aqui como qualquer desvio no comportamento do programa daquilo que foi especificado pelo desenvolvedor. Para isso, usamos as primitivas de controle de concorr\u00eancia que estudaram em SO, que tamb\u00e9m tem seus problemas em potencial, como deadlocks e inani\u00e7\u00e3o . Veja o seguinte v\u00eddeo para uma an\u00e1lise de diversos pontos importantes no uso de multithreads. Estado em Servidores A quest\u00e3o das regi\u00f5es cr\u00edticas no servidor est\u00e1 intimamente relacionada \u00e0 quest\u00e3o da manuten\u00e7\u00e3o de estado nos servidores. Quanto a este respeito, podemos classificar servidores como stateful e stateless , dois termos que ouvir\u00e3o frequentemente enquanto trabalhando com SD. O \"state\" nos dois nomes se refere ao estado mantido por um servi\u00e7o para atender a requisi\u00e7\u00f5es. Caso mantenha estado, por exemplo informando em quais arquivos o cliente est\u00e1 interessado, fica mais f\u00e1cil para o servidor continuar o trabalho feito em requisi\u00e7\u00f5es anteriores. Imagine por exemplo que um cliente esteja acessando linhas em um banco de dados, de forma paginada: a cada requisi\u00e7\u00e3o, o cliente recebe n n novas linhas para processar e, quando estiver pronto, requisite n n novas linhas. Imagine qu\u00e3o infeficiente seria se o servidor seguisse o seguinte flxo: receba requisi\u00e7\u00e3o informando a \u00faltima linha lida recalcule todas as respostas para consulta salte at\u00e9 a linha informada pelo cliente retorne as pr\u00f3ximas n n linhas para o cliente feche o resultado da consulta. Se em vez disso o servidor mantiver um mapa com consultas recentes, em que a chave seja algum identificador do cliente e o valor uma vis\u00e3o dos resultados; a cada nova requisi\u00e7\u00e3o, basta o servidor preparar rapidamente uma nova resposta. Em contrapartida, considere que m\u00faltiplos clientes fazem consultas concorrentemente: quanto recurso seria necess\u00e1rio para que o servidor mantenha a vis\u00e3o de todos os clientes? Tamb\u00e9m a complexidade do servidor aumenta, uma vez que ele precisa manter as respostas a novas requisi\u00e7\u00f5es consistentes com as respostas anteriores e portanto, caso o servi\u00e7o seja implementado por m\u00faltiplos servidores acess\u00edveis ao cliente, o estado deve ser compartilhado por tais servidores. Al\u00e9m disso, imagine que o cliente resolva n\u00e3o fazer mais requisi\u00e7\u00f5es, por exemplo por ter encontrado o que procurava: por quanto tempo o servidor deve manter a vis\u00e3o aberta? Voc\u00ea j\u00e1 deve ter adivinhado que no primeiro exemplo temos um servidor stateless e no segundo um stateful , e percebido que cada um tem suas vantagens e desvantagens. Vejamos mais algumas. Informa\u00e7\u00e3o sobre Sess\u00e3o Essencialmente, o servidor stateless n\u00e3o mantem informa\u00e7\u00e3o sobre a sess\u00e3o do cliente e requer que a cada nova requisi\u00e7\u00e3o, quaisquer informa\u00e7\u00f5es necess\u00e1rias para realizar a tarefa requisitada sejam novamente fornecidas ao servidor. No caso stateful , o servidor pode se lembrar, como no exemplo anterior, at\u00e9 onde o trabalho j\u00e1 foi executado, quais arquivos o cliente manipulou (e mant\u00ea-los abertos), qual o endere\u00e7o o cliente e enviar-lhe notifica\u00e7\u00f5es importantes (e.g., \"Novo dado inserido!\"). Tratamento de falhas Enquanto servidores stateful obviamente levam a melhor desempenho no happy path (contanto que recursos suficientes sejam providos), no caso de falhas, servi\u00e7os stateless tendem a voltar ao ar mais rapidamente, uma vez que n\u00e3o h\u00e1 estado que precise ser recuperado. Pela mesma raz\u00e3o, clientes que percebem que um servidor falhou, podem rapidamente se dirigirem a outros servidores e continuar suas requisi\u00e7\u00f5es de onde estavam, uma vez que s\u00e3o detentores de toda a informa\u00e7\u00e3o necess\u00e1ria para o pr\u00f3ximo passo do processamento. Lidar com falhas tamb\u00e9m introduz outro requisito aos servidores: mem\u00f3ria est\u00e1vel. Para que possa o recuperar o estado anterior \u00e0 falha, o servidor precisa colocar o estado em algum lugar que independa do processo para se manter, por exemplo, nvRAM , SSD ou spindles . A perda deste estado implicaria na incapacidade de prover o servi\u00e7o corretamente. Um projeto stateless n\u00e3o depende deste estado e por isso pode ser mais rapidamente recuperado, replicado ou substitu\u00eddo. Qual \u00e9 melhor? N\u00e3o surpreendentemente, a resposta para \"qual abordagem \u00e9 melhor, stateful ou stateless ?\" \u00e9 depende . Ambos as op\u00e7\u00f5es tem suas vantagens e desvantagens e para algums servi\u00e7os apenas uma op\u00e7\u00e3o ser\u00e1 vi\u00e1vel. Se seu servi\u00e7o precisa manter estado (um SGBD, por exemplo), ele ter\u00e1 que manter estado, mesmo que n\u00e3o sobre clientes. Veja um pequeno comparativo das caracter\u00edsticas das duas abordagens. Stateless Stateful Resultado depende da entrada Depende do hist\u00f3rico de entradas Qualquer servidor pode atender Mesmo servidor deve atender N\u00e3o promete notificar o cliente Assina contrato com o cliente Repete opera\u00e7\u00f5es Aproveita resultados anteriores N\u00e3o fica inconsistente com rela\u00e7\u00e3o ao cliente Pode ficar inconsistente se perder estado ou conex\u00e3o feita com outro servidor re-autentica\u00e7\u00e3o (mesmo que simplficada) a cada requisi\u00e7\u00e3o Autentica no come\u00e7o da sess\u00e3o Leia mais Uma vis\u00e3o interessante sobre estado \u00e9 apresentada em On stateless software design . Observe que n\u00e3o necessariamente eu concordo com tudo o que est\u00e1 escrito aqui, principalmente a quest\u00e3o sobre stateful ser sempre mais complexo. A discrep\u00e2ncia de vis\u00e3o est\u00e1 no fato de parte da complexidade ser levada para o cliente, no caso dos servidores stateless , mas n\u00e3o necessariamente ser eliminada. 1 [Sobre IO n\u00e3o bloqueante em Java.](https://www.developer.com/java/data/understanding-asynchronous-socket-channels-in-java.html) Multithread na pr\u00e1tica POSIX POSIX Threads ou PThreads, s\u00e3o uma defini\u00e7\u00e3o aberta de como threads devem funcionar em sistemas operacionais. V\u00e1rias implementa\u00e7\u00f5es desta especifica\u00e7\u00e3o est\u00e3o dispon\u00edveis tanto para sistemas Unix, compat\u00edveis com especifi\u00e7\u00f5es POSIX, mas tamb\u00e9m para Windows, via subsistemas. Al\u00e9m disso, mesmo implementa\u00e7\u00f5es n\u00e3o POSIX tem funcionalidade equivalentes e, por este motivo, entender POSIX servir\u00e1 de base para entender quaisquer API para programa\u00e7\u00e3o multi-threaded . Fun\u00e7\u00e3o de entrada Para se definir um thread , \u00e9 necess\u00e1rio definir uma fun\u00e7\u00e3o de entrada, que ser\u00e1 para o thread como a fun\u00e7\u00e3o main \u00e9 para o processo em si. No exemplo a seguir a fun\u00e7\u00e3o foi definida com retorno void * e com \u00fanico par\u00e2metro tambem void * ; esta \u00e9 uma obrigatoriedade para fun\u00e7\u00f5es de entrata PThread. Observe contudo que void * pode ser tratado como um blob para mascarar outros tipos de dado, por exemplo um vetor, um enumera\u00e7\u00e3o ou uma struct . 1 2 3 4 5 6 7 8 9 10 11 #include <stdio.h> #include <stdlib.h> #include <pthread.h> int thread_count ; void * hello ( void * rank ) { long my_rank = ( long ) rank ; printf ( \"Hello from thread %ld of %d \\n \" , my_rank , thread_count ); return NULL ; } Cria\u00e7\u00e3o Um thread \u00e9 criado pela fun\u00e7\u00e3o pthread_create , que coloca em um pthread_t um handle para o thread . A fun\u00e7\u00e3o recebe como par\u00e2metros op\u00e7\u00f5es para configura\u00e7\u00e3o, a fun\u00e7\u00e3o de entrada, e o par\u00e2metro do tipo void * . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main ( int argc , char * argv []) { long thread ; pthread_t * thread_handles ; if ( argc < 2 ) { printf ( \"usage: %s <number of threads>\" , argv [ 0 ]); return 1 ; } thread_count = strtol ( argv [ 1 ], NULL , 10 ); thread_handles = malloc ( thread_count * sizeof ( pthread_t )); for ( thread = 0 ; thread < thread_count ; thread ++ ) pthread_create ( & thread_handles [ thread ], NULL , hello , ( void * ) thread ); printf ( \"Hello from the main thread \\n \" ); Destrui\u00e7\u00e3o O handle do thread deve ser alocado previamente \u00e0 fun\u00e7\u00e3o de cria\u00e7\u00e3o e liberado ap\u00f3s o fim da execu\u00e7\u00e3o do thread . \u00c9 poss\u00edvel esperar pelo fim da execu\u00e7\u00e3o usando o pthread_join , que recebe como par\u00e2metro o handle do thread e um ponteiro para onde o resultado da fun\u00e7\u00e3o de entrada deve ser colocado, do tipo void ** . 1 2 3 4 for ( thread = 0 ; thread < thread_count ; thread ++ ) pthread_join ( thread_handles [ thread ], NULL ); free ( thread_handles ); Execu\u00e7\u00e3o Para executar um programa PThread, compile com 1 gcc -pthread teste.c -o teste e execute com 1 ./teste 5 e observe que a sa\u00edda das threads \u00e9 ordenada . Agora experimente 1 ./teste 200 Observe que a sa\u00edda \u00e9 desordenada (pode ser necess\u00e1rio executar m\u00faltiplas vezes ou aumentar de 200 para, digamos, 1000 para observar a desordem. Isto acontece porqu\u00ea a execu\u00e7\u00e3o das threads independe da ordem de cria\u00e7\u00e3o. De fato, usando PThreads, temos pouco controle sobre os threads que criamos. Mas isto n\u00e3o quer dizer que estamos \"\u00f3rf\u00e3os\" de API; v\u00e1rias outras opera\u00e7\u00f5es podem ser executadas, e podem ser encontradas a partir do manual de pthread_create . Alguns exemplos interessantes: pthread_tryjoin - espera thread terminar pthread_exit - termina a thread e retorna resultado An implicit call to pthread_exit() is made when a thread other than the thread in which main() was first invoked returns from the start routine that was used to create it. The function's return value serves as the thread's exit status. Manual de pthread_exit . pthread_attr_setaffinity_np * - ajusta afinidade dos threads. Java outro , Em Java, h\u00e1 essencialmente duas formas de se conseguir concorr\u00eancia. A primeira \u00e9 via inst\u00e2ncias expl\u00edcitas da classe Thread e, a segunda, via abstra\u00e7\u00f5es de mais alto n\u00edvel, os Executors . Aqui exploraremos formas de se obter concorr\u00eancia em Java, isto \u00e9, exploraremos como iniciar m\u00faltiplas linhas de execu\u00e7\u00e3o de instru\u00e7\u00f5es, que podem ou n\u00e3o, ser executadas em paralelo. Al\u00e9m de formas de definir as linhas de execu\u00e7\u00e3o, Java prov\u00ea diversas estruturas para comunica\u00e7\u00e3o e coordena\u00e7\u00e3o destas linhas, desde de a vers\u00e3o 5 da linguagem, no pacote java.util.concurrent . Ciclo de vida H\u00e1 duas formas b\u00e1sicas de definir um novo thread em Java, via extens\u00e3o da classe Thread , como no primeiro exemplo, ou ou via implementa\u00e7\u00e3o da interface Runnable , como no segundo, a seguir. Exemplo 1: Thread 1 2 3 4 5 6 7 8 9 10 public class HelloThread extends Thread { public void run () { System . out . println ( \"Hello from a thread!\" ); } public static void main ( String args [] ) { Thread t = new HelloThread (); t . start (); } } Exemplo 1: Runnable 1 2 3 4 5 6 7 8 9 10 public class HelloRunnable implements Runnable { public void run () { System . out . println ( \"Hello from a thread!\" ); } public static void main ( String args [] ) { Thread t = new Thread ( new HelloRunnable ()); t . start (); } } Observe que nos dois exemplos, um m\u00e9todo run() \u00e9 implementado com o c\u00f3digo a ser executado pelo thread . Em nenhum dos exemplos, contudo, o m\u00e9todo \u00e9 invocado diretamente. Em vez disto, o m\u00e9todo start() , sim, \u00e9 invocado. Isto ocorre porqu\u00ea antes de executar as instru\u00e7\u00f5es definidas pelo pelo programador no m\u00e9todo run() , a m\u00e1quina virtual precisa executar alguma \"m\u00e1gica\" por baixo dos panos como, por exemplo, solicitar ao sistema operacional a cria\u00e7\u00e3o de um thread do SO, que servir\u00e1 de hospedeiro para o thread Java. Isto acontece dentro do start() , que em algum ponto de sua execu\u00e7\u00e3o levar\u00e1 \u00e0 invoca\u00e7\u00e3o do m\u00e9todo run() . A classe Thread tamb\u00e9m prov\u00ea uma s\u00e9rie de m\u00e9todos que permitem gerenciar a vida do thread criado. Por exemplo, o m\u00e9todo de classe ( static ) Thread.sleep() permite bloquear um thread por um determinado per\u00edodo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class HelloRunnable implements Runnable { public void run () { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . println ( \"Hello at instant \" + i ); try { Thread . sleep ( 1000 ); } catch ( InterruptedException ie ) { System . out . println ( \"awoken\" ); } } } public static void main ( String args [] ) { Thread t = new Thread ( new HelloRunnable ()); t . start (); } } Observe que a chamada a sleep() est\u00e1 dentro de um bloco try/catch . Isto \u00e9 necess\u00e1rio pois \u00e9 permitido \u00e0 JVM acordar o thread em qualquer instante, antes ou ap\u00f3s o tempo especificado. Assim, embora normalmente o tempo \"dormido\" seja pr\u00f3ximo ao especificado, se h\u00e1 requisitos de precis\u00e3o, \u00e9 necess\u00e1rio que o thread , ao acordar, verifique se j\u00e1 dormiu o suficiente. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class HelloRunnable implements Runnable { public void run () { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . println ( \"Hello at instant \" + i ); long before = System . currentTimeMillis (); long timeout = 1000 ; while ( before + timeout > System . currentTimeMillis ()) { try { Thread . sleep ( Math . max ( 0 , System . currentTimeMillis () - ( before + timeout ))); } catch ( InterruptedException ie ) { System . out . println ( \"awoken\" ); } } } } public static void main ( String args [] ) { Thread t = new Thread ( new HelloRunnable ()); t . start (); } } Quando um thread est\u00e1 sendo executado, outros podem ter que esperar at\u00e9 que complete. Por exemplo, no caso de um navegador Web, o thread que faz a renderiza\u00e7\u00e3o da p\u00e1gina n\u00e3o pode come\u00e7ar a trabalhar enquanto o thread que solicitou o HTML do servidor n\u00e3o receber sua resposta. Um thread indica a inten\u00e7\u00e3o de esperar por outro usando o m\u00e9todo join() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class HelloRunnable implements Runnable { public void run () { Random rand = new Random (); for ( int i = 0 ; i < 10 ; i ++ ) { System . out . println ( \"Hello at instant \" + i ); long before = System . currentTimeMillis (); long timeout = 901 + rand . nextInt ( 200 ); while ( before + timeout > System . currentTimeMillis ()) { try { Thread . sleep ( Math . max ( 0 , System . currentTimeMillis () - ( before + timeout ))); } catch ( InterruptedException ie ) { System . out . println ( \"awoken\" ); } } } } public static void main ( String args [] ) { Thread t = new Thread ( new HelloRunnable ()); //t.setDaemon(true); t . start (); try { t . join (); //t.join(10000); } catch ( InterruptedException ie ) { System . out . println ( \"Waiting was interrupted\" ); } if ( t . isAlive ()) System . out . println ( \"Got tired of waiting\" ); else System . out . println ( \"Wait is over\" ); } } Invocar t.join() far\u00e1 com que o thread principal espere indefinidamente at\u00e9 que t termine de executar. Caso seja necess\u00e1rio limitar o tempo de espera, o tempo pode ser especificado como na linha comentada. Caso a espera termine por causa de um timeout , \u00e9 poss\u00edvel testar o estado atual do thread com Thread.isAlive() . Outro m\u00e9todo interessante, Thread.setDaemon() , especifica que o thread pode ser terminado quando a thread principal terminar. Descomente a invoca\u00e7\u00e3o e teste o efeito. Exerc\u00edcio Fa\u00e7amos um exerc\u00edcio simples do uso de threads . Considere a classe e siga as instru\u00e7\u00f5es abaixo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Counter { private int c = 0 ; public int increment () { return ++ c ; } public int decrement () { return -- c ; } public int value () { return c ; } } Instancie um programa que gere 10 threads . Todos os threads devem compartilhar uma mesma inst\u00e2ncia de Counter Cada thread deve executar um loop em que incrementa o valor do contador 20 vezes a cada vez, imprime o resultado precedido do identificador do thread (use Thread.getName() ou Thread.currentThread().getName() ) A thread principal deve esperar todas as outras terminarem antes de terminar (use Thread.join() ). Analise a sa\u00edda do programa observando a ordem de execu\u00e7\u00e3o dos threads . An\u00e1lise \u00c9 f\u00e1cil observar que a sa\u00edda do programa \u00e9 aleat\u00f3ria nos identificadores e tende a ser incremental nos contadores, mas nem sempre isso \u00e9 verdade. Isso acontece porqu\u00ea a execu\u00e7\u00e3o dos threads \u00e9 n\u00e3o determin\u00edstica; uma vez que estejam prontos para executar, cabe ao escalonador do sistema operacional a decis\u00e3o sobre qual processo e em qual processador dever\u00e1 executar. Bug Melhorar explica\u00e7\u00e3o abaixo Al\u00e9m de extens\u00e3o de Thread e implementa\u00e7\u00e3o de Runnable , Java disponibiliza tamb\u00e9m Executor como abstra\u00e7\u00e3o de mais alto n\u00edvel para execu\u00e7\u00e3o de tarefas concorrentes. Executor ExecutorService ScheduledExecutorService 1 2 3 Executor e = ...; Runnable r = ...; e . execute ( r ); Executors normalmente implementam thread pools , que podem ser de diferentes tipos. O mais simples \u00e9 o de tamanho fixo em que h\u00e1 um n\u00famero inicial de threads criados e que, no caso de algum ser terminado, por exemplo por causa de uma exce\u00e7\u00e3o n\u00e3o tratada, cria substitutos para manter o n\u00famero constante. Executor e = java . util . concurrent . Executors . newFixedThreadPool (); newCachedThreadPool() - expandable thread pool newSingleThreadExecutor() - single task at a time e outras vers\u00f5es ForkJoinPool 1 2 3 4 5 if (my portion of the work is small enough) do the work directly else split my work into two pieces invoke the two pieces and wait for the results Coordena\u00e7\u00e3o Como visto no exerc\u00edcio anterior, a execu\u00e7\u00e3o de threads \u00e9 n\u00e3o determin\u00edstica. Contudo, estas execu\u00e7\u00f5es frequentemente precisam ser coordenadas para que n\u00e3o pisem uns nos calcanhares dos outros, por exemplo, decidindo quem deve ser o pr\u00f3ximo a entrar em uma regi\u00e3o cr\u00edtica ou ser\u00e1 o respons\u00e1vel por uma tarefa. Em Java, esta coordena\u00e7\u00e3o pode ser feita por diversas abstra\u00e7\u00f5es: synchronized , Lock , vari\u00e1veis at\u00f4micas, ... synchronized Ao definir m\u00e9todos como synchronized , garante-se que os mesmos nunca ser\u00e3o executados concorrentemente. Observe a classe a seguir, que modifica o contador do exerc\u00edcio anterior. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class SynchronizedCounter { private int c = 0 ; public synchronized int increment () { return ++ c ; } public synchronized int decrement () { return -- c ; } public synchronized int value () { return c ; } } Caso dois threads invoquem os m\u00e9todos increment e decrement ao mesmo tempo, por exemplo, a JVM far\u00e1 com que um dos threads pare sua execu\u00e7\u00e3o at\u00e9 que o outro tenha completado a invoca\u00e7\u00e3o. Isto n\u00e3o quer dizer que executar o exerc\u00edcio anterior com esta vers\u00e3o do contador n\u00e3o levar\u00e1 a sa\u00eddas com incrementos completamente sequenciais, pois um thread poderia parar de ser executado logo ap\u00f3s incrementar o contador, depois de terminado o m\u00e9todo increment , e s\u00f3 voltar a executar depois que outro tenha incrementado e impresso na tela o valor obtido. O que quer dizer \u00e9 que, mesmo que sa\u00eddas estranhas existam, cada opera\u00e7\u00e3o foi executada integralmente antes da opera\u00e7\u00e3o seguinte. Exerc\u00edcio Modifique o c\u00f3digo do exerc\u00edcio anterior para usar a vers\u00e3o synchronized do contador. Depois de execut\u00e1-lo, adicione um println(\"Dentro: \" + c) dentro do m\u00e9todo de incremento para verificar que estas sa\u00eddas acontecem ordenadamente. synchronized funciona porqu\u00ea limita a concorr\u00eancia, e \u00e9 problem\u00e1tico exatamente pela mesma raz\u00e3o. Por isso, \u00e9 essencial que o synchronized seja o mais limitado poss\u00edvel em termos de escopo, o que nos leva ao uso de synchronized em blocos de c\u00f3digo menores que m\u00e9todos. Por exemplo: 1 2 3 4 5 6 7 8 9 10 11 12 public class Namer { String lastName = null ; int nameCount = 0 ; public void addName ( String name ) { lastName = name ; synchronized ( this ) { nameCount ++ ; } nameList . add ( name ); } } Neste caso, blocos sincronizados no mesmo objeto , n\u00e3o s\u00e3o executados concorrentemente, mas outros blocos sim. Exerc\u00edcio Neste exerc\u00edcio, use dois objetos para travar o acesso a dois contadores. Instancie um programa com dois threads tal que: executem um loop 1000 vezes em que o primeiro thread primeiro invoca inc1 e depois inc2 o segundo thread primeiro invoca inc2 e depois inc1 ambos os threads imprimem o valor de c1 e c2 An\u00e1lise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class MsLunch { private long c1 = 0 ; private long c2 = 0 ; private Object lock1 = new Object (); private Object lock2 = new Object (); public void inc1 () { synchronized ( lock1 ) { c1 ++ ; } } public void inc2 () { synchronized ( lock2 ) { c2 ++ ; } } } Sinaliza\u00e7\u00e3o Usados corretamente, o bloco synchronized \u00e9 executado de forma at\u00f4mica, isto \u00e9, indivis\u00edvel. Algumas opera\u00e7\u00f5es muito simples s\u00e3o naturalmente at\u00f4micas, e n\u00e3o precisam ser \"protegidas\" pelo synchronized . Por exemplo, leituras e escritas de tipos b\u00e1sicos como int , char e byte , mas n\u00e3o long ou double , pois usam mais de uma palavra em algumas arquiteturas, ou vari\u00e1veis declaradas volatile . Usando estas vari\u00e1veis, \u00e9 poss\u00edvel coordenar threads , como no exemplo a seguir. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 boolean condicao = false ; ... public void espereCondicao () { while ( ! condicao ) {} System . out . println ( \"condicao alcancada.\" ); } ... public void satisfacaCondicao () { condicao = true ; } Embora correta, esta abordagem, conhecida como espera ocupada , n\u00e3o \u00e9 eficiente pois o desperdi\u00e7a computa\u00e7\u00e3o. Felizmente, em Java, todos os objetos implementam os m\u00e9todos wait e notify/notifyAll , que podem ser usados para sincronizar eficientemente threads . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Sync { Object synch = new Object (); boolean condicao = false ; public void espereCondicao () { while ( ! condicao ) { try { synchronized ( synch ){ synch . wait (); } } catch ( InterruptedException e ) {} } System . out . println ( \"Condicao alcancada\" ); } ... public void satisfacaCondicao () { condicao = true ; synchronized ( synch ){ synch . notifyAll (); } } } Neste exemplo, a execu\u00e7\u00e3o da fun\u00e7\u00e3o espereCondicao \u00e9 \"pausada\" por synch . wait () at\u00e9 que uma notifica\u00e7\u00e3o seja enviada via sync . notifiyAll () , na fun\u00e7\u00e3o satisfa\u00e7aCondicao . Observe que estas opera\u00e7\u00f5es s\u00f3 podem ocorrer dentro de blocos sincronizados na vari\u00e1vel usada na sinaliza\u00e7\u00e3o. Locks Outras abstra\u00e7\u00f5es para coordena\u00e7\u00e3o de threads est\u00e3o dispon\u00edveis no pacote java.util.concurrent . As mais simples delas s\u00e3o java.util.concurrent.locks.Lock e java.util.concurrent.locks.ReentrantLock . Veja um exemplo de uso, notando o idioma de uso dentro de block try/catch/finally , que garante que o lock ser\u00e1 liberado a despeito de exce\u00e7\u00f5es no bloco. 1 2 3 4 5 6 7 Lock l = new ReentrantLock (); l . lock (); try { // access the resource protected by this lock } finally { l . unlock (); } Como bem sabido, o uso dos \"locks\" em ordens diferentes pode levar a um deadlock pois um ciclo de depend\u00eancias pode ser formado entre locks, detentores de locks e interessados em locks. O grafo de depend\u00eancia seguinte exemplifica o cen\u00e1rio, em que o thread T1 obteve o lock2 e tenta obter o lock1, e o thread T2 obteve o lock1 e tenta obter o lock2. graph LR T1 --> lock1 --> T2 --> lock2 --> T1 Estruturas thread-safe Finalmente, Java tamb\u00e9m disponibiliza estruturas de dados que podem ser acessadas concorrentemente por m\u00faltiplos threads sem risco de corrup\u00e7\u00e3o, denominadas thread-safe . BlockingQueue - bloquei threads se n\u00e3o houver elementos na filq. ConcurrentMap/ConcurrentHashMap - opera\u00e7\u00f5es at\u00f4micas; if (!m.containsKey(k)) m.put(k,v); vOld = m.putIfAbsent(k,v); Tipos At\u00f4micos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.util.concurrent.atomic.AtomicInteger ; class AtomicCounter { private AtomicInteger c = new AtomicInteger ( 0 ); public void increment () { c . incrementAndGet (); } public void decrement () { c . decrementAndGet (); } public int value () { return c . get (); } } ThreadLocal 1 2 3 4 5 6 7 8 9 private static ThreadLocal < Integer > myId = new ThreadLocal < Integer > () { public Integer initialValue () { return new Random (). nexInt (); } }; public static Integer getMyId () { return myId . get (); } Leia mais Para aprender mais, muito mais sobre concorr\u00eancia em Java, \u00f3timas refer\u00eancias s\u00e3o: Java Concurrency in Practice The Well-Grounded Java Developer Concorr\u00eancia em Java Futures e Promises Locks Tipos At\u00f4micos Python Em Python, como seria de se esperar, h\u00e1 v\u00e1rias formas de se trabalhar com threads . A seguir s\u00e3o apresentados dois exemplos, usando o pacote thread ou threading . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/python import thread import time # Define a function for the thread def print_time ( threadName , delay ): count = 0 while count < 5 : time . sleep ( delay ) count += 1 print \" %s : %s \" % ( threadName , time . ctime ( time . time ()) ) # Create two threads as follows try : thread . start_new_thread ( print_time , ( \"Thread-1\" , 2 , ) ) thread . start_new_thread ( print_time , ( \"Thread-2\" , 4 , ) ) except : print \"Error: unable to start thread\" while True : pass Ou 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/bin/python import threading import time exitFlag = 0 class myThread ( threading . Thread ): def __init__ ( self , threadID , name , counter ): threading . Thread . __init__ ( self ) self . threadID = threadID self . name = name self . counter = counter def run ( self ): print \"Starting \" + self . name print_time ( self . name , self . counter , 5 ) print \"Exiting \" + self . name def print_time ( threadName , counter , delay ): while counter : if exitFlag : threadName . exit () time . sleep ( delay ) print \" %s : %s \" % ( threadName , time . ctime ( time . time ())) counter -= 1 # Create new threads thread1 = myThread ( 1 , \"Thread-1\" , 1 ) thread2 = myThread ( 2 , \"Thread-2\" , 2 ) # Start new Threads thread1 . start () thread2 . start () print \"Exiting Main Thread\" Leia mais Threads em Python Exerc\u00edcio - Anel Multithread Usando uma linguagem de alto-n\u00edvel como C/C++/Java, escrever um programa que crie 30 threads e fa\u00e7a com que uma mensagem circule entre os mesmos. A mensagem \u00e9 uma string aleat\u00f3ria de pelo menos 80 caracteres. A cada vez que um thread recebe a mensagem ele a imprime, modifica o primeiro caractere min\u00fasculo para mai\u00fasculo, caso exista, dorme por 1 segundo, e repassa a mensagem. Quando todos os caracteres forem mai\u00fasculos, o processo repassa a mensagem e ent\u00e3o termina. Antes de terminar, o processo deve imprimir a mensagem resultante. Endere\u00e7os IP n\u00e3o p\u00fablicos n\u00e3o server como identificadores \u00fanicos na Internet. \u21a9 Se o segundo comando n\u00e3o funcionar, tente nc em vez de netcat . \u21a9 Understanding IP Multicast \u21a9 IP-Multicast em IPv6 \u21a9","title":"Fundamentos"},{"location":"teaching/gbc074gsi028/basics/#fundamentos","text":"A pedra fundamental da constru\u00e7\u00e3o de sistemas distribu\u00eddos \u00e9 a capacidade de comunica\u00e7\u00e3o entre seus componentes. No mundo de hoje, isto quer dizer que os hosts dos componentes devem possuir interfaces de rede e que estas interfaces estejam ligadas a uma rede com capacidade de roteamento de dados, estabelecendo um canal de comunica\u00e7\u00e3o entre os componentes. Al\u00e9m do canal, \u00e9 tamb\u00e9m necess\u00e1rio que se estabele\u00e7a um protocolo de comunica\u00e7\u00e3o , que define as regras para que a comunica\u00e7\u00e3o aconte\u00e7a, por exemplo, a gram\u00e1tica para forma\u00e7\u00e3o de mensagens. Tamb\u00e9m importantes, de um ponto de vista pr\u00e1tico do desenvolvimento, s\u00e3o os conceitos de concorr\u00eancia e paralelismo. Afinal, um componente pode necessitar manter v\u00e1rias \"conversas\" em paralelo com m\u00faltiplos outros componentes. Neste cap\u00edtulo, revisaremos de forma r\u00e1pida tanto conceitos de redes de computadores quanto de concorr\u00eancia e paralelismo.","title":"Fundamentos"},{"location":"teaching/gbc074gsi028/basics/#canais-e-protocolos-de-comunicacao","text":"Um canal de comunica\u00e7\u00e3o \u00e9 o meio pelo qual os elementos da conversa entre os componentes do sistema distribu\u00eddo s\u00e3o transmitidos e o protocolo s\u00e3o as regras codificam tal conversa. Por exemplo, quando voc\u00ea fala com uma pessoa, cara-a-cara, o meio de comunica\u00e7\u00e3o \u00e9 o ar e o protocolo utilizado \u00e9 a linguagem conhecida pelas duas partes, o Portugu\u00eas por exemplo. Na pr\u00e1tica, canais de comunica\u00e7\u00e3o podem ter diversas formas e caracter\u00edsticas, por exemplo: Ponto-a-ponto Eficiente Caro para muitos n\u00f3s Roteamento trivial Compartilhado Colis\u00f5es Menor custo Roteamento mais complicado Nas redes atuais, pode se dizer que o meio mais utilizado \u00e9 provido pela arquitetura Ethernet , que trata da comunica\u00e7\u00e3o n\u00f3s usando um barramento compartilhado . Sobre este meio, s\u00e3o usados protocolos para, por exemplo, Controle de acesso ao meio Transmiss\u00e3o de mensagens Evitar e tratar colis\u00f5es As redes Ethernet, contudo, cobrem pequenas \u00e1reas e para se ter conversas \"mais interessantes\", \u00e9 necess\u00e1rio que se conecte diversas destas redes. A conversa ent\u00e3o \u00e9 feita por meio de intermedi\u00e1rios, ** gateways ** que conectam duas ou mais redes, permitindo que mensagens de um interlocutor sejam roteadas para o outro, via tais intermedi\u00e1rios. Um exemplo interessante das quest\u00f5es ligadas \u00e0 manuten\u00e7\u00e3o da conversa entre dois pontos \u00e9 a decis\u00e3o sobre o uso de comuta\u00e7\u00e3o de pacotes ( packet switching ) ou de circuitos ( circuit switching ). Comuta\u00e7ao de pacotes Dados divididos em pacotes Cada pacote viaja independentemente Pacotes s\u00e3o perdidos Lat\u00eancia vari\u00e1vel Circuit switching Caminho dedicado Recursos reservados Pacotes de tamanho fixo Lat\u00eancia constante Outro fator importante \u00e9 o MTU, o tamanho m\u00e1ximo de um pacote em determinada rede. \u00c9 necess\u00e1rio entender que qualquer quantidade de dados maior que o MTU precisar\u00e1 ser dividida em m\u00faltiplos pacotes. Tamb\u00e9m \u00e9 importante perceber que redes s\u00e3o heterog\u00eaneas, e que o v\u00e1rios segmentos no caminho entre origem e destino podem ter MTU diferentes, levando \u00e0 fragmenta\u00e7\u00e3o de pacotes em tr\u00e2nsito e, possivelmente, entrega desordenada dos mesmos. Finalmente, h\u00e1 a quest\u00e3o importante \u00e9 relativa \u00e0 confiabilidade na transmiss\u00e3o dos elementos da conversa, isto \u00e9, se a rede deve garantir ou n\u00e3o que algo \"dito\" por um interlocutor deve garantidamente ser \"ouvido\" pelo outro, ou se a mensagem pode ser perdida no meio. Felizmente boa parte da complexidade da resolu\u00e7\u00e3o destas quest\u00f5es \u00e9 abstra\u00edda do desenvolvedor dos sistemas distribu\u00eddos, isto \u00e9, voc\u00ea , lhe cabendo apenas a decis\u00e3o de qual protocolo utilizar. Nas redes atuais, a conversa em componentes ser\u00e1 feita, em algum n\u00edvel, por meio dos protocolos da arquitetura Internet .","title":"Canais e Protocolos de Comunica\u00e7\u00e3o"},{"location":"teaching/gbc074gsi028/basics/#a-internet","text":"A Internet tem este nome por usar o protocolo de interconex\u00e3o de redes indepententes, o internetworking protocol , ou IP. Para a aplica\u00e7\u00e3u usando o IP, todas as redes se comportam com uma \u00fanica e coerente rede, exceto por alguns detalhes. Os elementos que conectam as diversas redes s\u00e3o denominados roteadores e fazem um melhor esfor\u00e7o para encaminhar os pacotes de dados do remetente ao destinat\u00e1rio. Se voc\u00ea se lembrar da pilha de protocolos de comunica\u00e7\u00e3o de refer\u00eancia OSI, lembrar\u00e1 que h\u00e1 sete camadas na mesma. Cada camada \u00e9 respons\u00e1vel pela comunica\u00e7\u00e3o em um n\u00edvel e serve de funda\u00e7\u00e3o para a funcionalidade da camada de cima. Cada camada tem um cabe\u00e7alho ( header ) e uma carga ( payload ) e o conjunto de cabe\u00e7alho + carga de uma camada \u00e9 considerado carga da camada inferior. Assim, embora tenha-se a impress\u00e3o de que cada camada conversa com a equivalente do outro lado da comunica\u00e7\u00e3o, na pr\u00e1tica, a comunica\u00e7\u00e3o desce e sobe a pilha. Bits Frames/quadros; controle de fluxo; acesso ao meio. Datagramas/pacotes; roteamento Controle de fluxo; fim a fim; confiabilidade; tcp e udp Streams/fluxos; conex\u00f5es l\u00f3gicas; restart; checkpoint; http, ssl Objetos; json, xml; criptografia Aplica\u00e7\u00f5es; http, pop, ftp Embora o IP se refira estritamente ao protocolo da camada 3 da pilha, nos referimos \u00e0 pilha que usa este protocolo como a pilha IP. Comparada \u00e0 pilha OSI, a IP \u00e9 mais simples, como se v\u00ea na figura. Como usu\u00e1rios da pilha IP, temos que entender como a camada 3 funciona, mas dificilmente interagiremos com algo al\u00e9m da camada 4, a camada de transporte . Como se v\u00ea, as camadas 5 e 6 n\u00e3o est\u00e3o presentes na pilha IP e as funcionalidades correspondentes s\u00e3o implementadas na camada 7, de aplica\u00e7ao. Contudo, n\u00e3o tema! Estas funcionalidades podem se normalmente implementadas por meio de frameworks ou do middleware em uso. Alguns exemplos de tais funcionalidades s\u00e3o (De)Serializa\u00e7\u00e3o Nomeamento Criptografia Replica\u00e7\u00e3o Invoca\u00e7\u00e3o remota de procedimentos A grande vantagem desta abordagem \u00e9 que se pode implementar exatamente e somente as funcionalidades desejadas. Este caracter\u00edstica \u00e9 conhecida como o argumento fim-a-fim no projeto de sistemas ; uma an\u00e1lise recente deste argumento foi feita aqui .","title":"A Internet"},{"location":"teaching/gbc074gsi028/basics/#no-principio-era-o-socket","text":"Na pr\u00e1tica, para implementarmos a comunica\u00e7\u00e3o entre processos, usamos sockets . Para se definir um socket a partir de um host \u00e9 necess\u00e1rio identificar o outro fim da comunica\u00e7\u00e3o, isto \u00e9, o outro host , ou melhor, uma de suas interfaces de rede. Os sockets s\u00e3o ent\u00e3o a abstra\u00e7\u00e3o dos canais de comunica\u00e7\u00e3o, mas como dito antes, \u00e9 necess\u00e1rio definir tamb\u00e9m os protocolos usados por estes sockets. O primeiro protocolo \u00e9 o de endere\u00e7amento, que define qual pilha de protocolos usar, na camada 3. No caso da pilha IP, usa-se o protocolo AF_INET ou PF_INET. Escolhido o protocolo, cada interface tem um endere\u00e7o MAC, na camada 2, que o identifica entre as interfaces na mesma rede local, e cada interface tem um endere\u00e7o IPv4/IPv6 de 32/128 bits, que o indentifica entre todos os hosts na Internet 1 . Mas dentro de um host , podem haver diversas aplica\u00e7\u00f5es sendo executadas. Como identificar exatamente com qual se quer conversar? Isto \u00e9 feito pela defini\u00e7\u00e3o uma porta: Porta: 16 bits IANA (Internet Assigned Numbers Authority) Bem conhecidas -- 0-1023 Propriet\u00e1rias -- 49151 Din\u00e2micas -- 65535 Tamb\u00e9m \u00e9 necess\u00e1rio definir tamb\u00e9m o protocolo de transporte dos dados, na camada 4. Novamente, no caso da pilha IP, pode-se usar TCP ( SOCK_STREAM ) ou UPD ( SOCK_DGRAM ). A API usada para estabelecer a conversa via socket tem v\u00e1rias chamadas, que devem ser executadas na ordem certa no processo iniciando a conversa e naquele que aceita participar da mesma. Comecemos estudando o TCP.","title":"No princ\u00edpio, era o Socket"},{"location":"teaching/gbc074gsi028/basics/#tcp","text":"O fluxograma da cria\u00e7\u00e3o de um socket TCP \u00e9 apresentado na seguinte figura: stateDiagram-v2 Servidor --> Entrada/Sa\u00edda Cliente --> Entrada/Sa\u00edda Entrada/Sa\u00edda --> sc state Servidor { ss: Cria socket sb: Associa porta sl: Escuta conex\u00f5es sa: Aceita conex\u00f5es ss --> sb sb --> sl sl --> sa } state Entrada/Sa\u00edda { leitura --> escrita escrita --> leitura } state Cliente { cs: Cria socket cc: Inicia conex\u00e3o cs --> cc } state sc: Fecha conex\u00e3o Estabelecido o socket, o mesmo pode ser usado como arquivo , isto \u00e9, lendo-se e escrevendo-se bytes. O que exatamente deve ser escrito e como o que \u00e9 lido deve ser interpretado \u00e9 o protocolo da camada 7, sua responsabilidade . Vejamos um exemplo do uso de sockets, em Python. O seguinte arquivo pode ser nomeado, por exemplo, server.py , mas n\u00e3o pode, de forma alguma, ser nomeado socket.py . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #server.py #!/usr/bin/python # This is server.py file import socket # Import socket module s = socket . socket () # Create a socket object host = socket . gethostname () # Get local machine name port = 12345 # Reserve a port for your service. s . bind (( host , port )) # Bind to the port s . listen ( 5 ) # Now wait for client connections. while True : c , addr = s . accept () # Establish connection with client. print ( 'Got connection from' , addr ) c . send ( 'Thank you for connecting' . encode ()) c . close () # Close the connection Para execut\u00e1-lo, execute o seguinte comando em um terminal. 1 python server.py Em outro terminal, execute um dos dois comandos a seguir 2 : 1 telnet localhost 12345 1 netcat localhost 12345 O que est\u00e1 acontecendo aqui \u00e9 um processo criou um socket e ficou aguardando uma conex\u00e3o, usando o c\u00f3digo em Python. Tanto o telnet quando o netcat s\u00e3o programas gen\u00e9ricos para se conversar com outro processo usando TCP/IP. Aqui, estes programas simplesmente se conectaram e imprimiram o que quer que o primeiro processo lhes tenha enviado, assumindo que correspondia a uma string, o que neste caso \u00e9 correto. Simples, n\u00e3o \u00e9 mesmo? Em geral, denominamos o processo que fica aguardando a conex\u00e3o de servidor e o processo que se conecta de cliente . Isto por qu\u00ea, em geral, o servidor executa alguma tarefa, serve, o cliente, embora isto n\u00e3o seja necessariamente verdade. Por completude, vamos tamb\u00e9m escrever o c\u00f3digo do cliente, agora que voc\u00ea j\u00e1 sabe que o servidor funciona. Do lado cliente, estabelece-se uma conex\u00e3o apontando-se para onde est\u00e1 o servidor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #client.py #!/usr/bin/python # This is client.py file import socket # Import socket module s = socket . socket () # Create a socket object host = socket . gethostname () # Get local machine name port = 12345 # Reserve a port for your service. s . connect (( host , port )) data = s . recv ( 1024 ) print ( data . decode ()) s . close () # Close the socket when done E para se executar o cliente, fa\u00e7a: 1 python client.py Observe que o socket.close() encerra a conex\u00e3o do lado de quem invoca. Na contraparte, invoca\u00e7\u00f5es a socket.recv() retornam com 0 bytes lidos. A t\u00edtulo de compara\u00e7\u00e3o, em Java, a cria\u00e7\u00e3o do socket do lado do servidor seria muito mais simples, consistindo apenas em: 1 Socket s = new ServerSocket ( port ); O cliente em Java tamb\u00e9m \u00e9 simplificado. 1 Socket s = new Socket ( hostname , port ); Exerc\u00edcio: M\u00faltiplos Pacotes Fa\u00e7amos agora uma modifica\u00e7\u00e3o no c\u00f3digo do servidor para que envie n\u00e3o uma, mas duas mensagens para o cliente. Isto \u00e9, modifique seu servidor assim 1 2 3 4 ... c . send ( 'Thank you for connecting' . encode ()) c . send ( 'Come back often' . encode ()) ... Agora execute novamente o cliente e veja o que acontece. Consegue explicar o fen\u00f4meno? Modifiquemos o cliente agora, para que tenha dois recv , assim. 1 2 3 4 5 6 7 8 ... print ( \"1\" ) data = s . recv ( 1024 ) print ( data . decode ()) print ( \"2\" ) data = s . recv ( 1024 ) print ( data . decode ()) ... E agora, o que acontece? A sa\u00edda \u00e9 como esperava? Como explica este fen\u00f4meno e como poderia corrig\u00ed-lo? Exerc\u00edcio: Ping-Pong Modifique cliente e servidor tal que o cliente envie uma mensagem passada na linha de comando ao servidor e fique esperando uma resposta, e tal que o servidor fique esperando uma mensagem e ent\u00e3o solicite ao operador que digite uma resposta e a envie para o cliente. O loop continua at\u00e9 que o usu\u00e1rio digite SAIR, e a conex\u00e3o seja encerrada. Terminal 1 Terminal 2 python server.py python client.py Esperando conex\u00e3o. conectando-se ao servidor Conectado Conectado Esperando mensagem Digite mensagem: lalala Mensagem enviada Mensagem recebida: lalala Esperando resposta Digite resposta: lelele Resposta enviada. Resposta recebida: lelele Digite mensagem: SAIR Desconectando. Conex\u00e3o encerrada. Esperando conex\u00e3o. Observe que para ler do teclado em Python 2 voc\u00ea deve usar x = raw_input () , enquanto que em Python 3 seria x = input () . Al\u00e9m disso, em Python 2, voc\u00ea deve remover as invoca\u00e7\u00f5es para encode e decode .","title":"TCP"},{"location":"teaching/gbc074gsi028/basics/#udp","text":"No exemplo anterior, usamos o protocolo TCP (o padr\u00e3o da API). Caso quis\u00e9ssemos usar UDP, precisar\u00edamos nos atentar a alguns detalhes. A cria\u00e7\u00e3o do socket \u00e9 feita explicitando-se o uso de datagramas : s = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) Um servidor UDP n\u00e3o executa listen ou accept e, em Python, simplesmente executa data , addr = sock . recvfrom ( 4096 ) para receber o datagrama, onde data \u00e9 o conte\u00fado recebido e addr o endere\u00e7o de quem enviou o datagrama. Neste caso, um mesmo socket \u00e9 usado para manter comunica\u00e7\u00e3o com m\u00faltiplos interlocutores. Para enviar uma resposta a um interlocutor em espec\u00edfico, addr \u00e9 usado: sent = sock . sendto ( data , addr ) , onde sent \u00e9 a quantidade de bytes enviados. Al\u00e9m deste detalhe, \u00e9 importante manter em mente outras caracter\u00edsticas do UDP: falta de ordem falta de confiabilidade menos dados lidos que enviados. mais dados lidos que enviados (pode acontecer tamb\u00e9m no TCP) Com tantas dificuldades para se usar o UDP, fica a quest\u00e3o: para que serve UDP? Exerc\u00edcio: Ping-Pong UDP Modifique o c\u00f3digo do exerc\u00edcio Ping-Pong para usar UDP em vez de TCP na comunica\u00e7\u00e3o entre n\u00f3s. Execute m\u00faltiplos clientes ao mesmo tempo. Como o seu servidor lida com isso? Modifique-o para mandar um \"eco\" da mensagem recebida de volta ao remetente.","title":"UDP"},{"location":"teaching/gbc074gsi028/basics/#ip-multicast","text":"Imagine que voc\u00ea tenha que enviar um stream de v\u00eddeo para um destinat\u00e1rio, mostrando como voc\u00ea est\u00e1 jogando o mais novo jogo da velha no mercado. Qual protocolo de transporte voc\u00ea usaria? TCP, provavelmente, j\u00e1 que garante a entrega ordenada dos pacotes do v\u00eddeo. Como voc\u00ea j\u00e1 sabe, o TCP envia confirma\u00e7\u00f5es de pacotes recebidos e usa uma janela deslizante para determinar quais pacotes reenviar, o que pode causar interrup\u00e7\u00f5es na execu\u00e7\u00e3o do v\u00eddeo. Al\u00e9m do mais, as pessoas provavelmente preferir\u00e3o perder alguns quadros que perder a sincronia com sua excitante partida. Parece que uma op\u00e7\u00e3o melhor seria ent\u00e3o usar UDP, correto? Imagine agora que os mesmos dados devam ser enviados para m\u00faltiplos destinat\u00e1rios (voc\u00ea est\u00e1 ficando famoso!) Com m\u00faltiplos destinat\u00e1rios, m\u00faltiplos controles precisariam ser mantidos no TCP, o que pode se tornar custoso; mais uma raz\u00e3o para usar UDP! Para terminar, lhe darei uma raz\u00e3o final: IP-Multicast! Multicast, em oposi\u00e7\u00e3o ao Unicast, \u00e9 a capacidade de enviar mensagens para um grupo de destinat\u00e1rios, em vez de apenas um. IP-Multicast \u00e9 uma implementa\u00e7\u00e3o desta ideia, usando umaa configura\u00e7\u00e3o espec\u00edfica do UDP, associada a recursos dos comutadores de rede, para otimizar o envio dos mesmos dados a m\u00faltiplos destinat\u00e1rios. Grupos s\u00e3o identificados por endere\u00e7os IP especiais, conhecidos como Classe D (224.0.0.0-239.255.255.255), e propagados pela rede. A seguinte tabela descreve os usos das sub-faixas de endere\u00e7os. 3 Endere\u00e7o Uso 224.0.0.0-224.0.0.255 Multicast local - Usado por protocolos L2, como EIGRP e OSPF 224.0.1.0-224.0.1.255 Multicast roteaddo - Usado por protocolos L3 232.0.0.0-232.255.255.255 Source Specific Multicast - Receptores definem fontes confi\u00e1veis 233.0.0.0-233.255.255.255 Reservado para detentores Autonomous Systems 239.0.0.0-239.255.255.255 Reservado para IANA Resto Uso geral Quando um pacote \u00e9 enviado para o endere\u00e7o do grupo, todos os membros do grupo recebem tal mensagem. Melhor dizendo, todos os membros podem receber a mensagem, mas como estamos falando de UDP, \u00e9 poss\u00edvel que alguns n\u00e3o recebam . Al\u00e9m disso, n\u00e3o h\u00e1 garantia qualquer sobre a ordem de recep\u00e7\u00e3o das mensagens . Apenas refor\u00e7ando, IP-Multicast s\u00f3 funciona com UDP, pois lidar com retransmiss\u00f5es em um grupo grande levaria a um estado imenso sendo mantido na origem dos dados. Outro ponto importante \u00e9 que pelo podencial desestabilizador do IP-Multicast, ele \u00e9 normalemente limitado \u00e0 pequenas se\u00e7\u00f5es das redes. Mas experimentemos com esta tecnologia na pr\u00e1tica. Criemos um programa que criar Socket UDP , associa-o a um grupo , e recebe pacotes destinados ao grupo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // MReceiver.java import java.io.* ; import java.net.* ; public class MReceiver { public static void main ( String [] args ) { byte [] inBuf = new byte [ 256 ] ; try { MulticastSocket socket = new MulticastSocket ( 8888 ); InetAddress address = InetAddress . getByName ( \"224.2.2.3\" ); socket . joinGroup ( address ); while ( true ) { DatagramPacket inPacket = new DatagramPacket ( inBuf , inBuf . length ); socket . receive ( inPacket ); String msg = new String ( inBuf , 0 , inPacket . getLength ()); System . out . println ( \"From \" + inPacket . getAddress () + \" Msg : \" + msg ); } } catch ( IOException ioe ) { System . out . println ( ioe ); } } } Instancie m\u00faltiplos processos deste, na mesma m\u00e1quina e em m\u00e1quinas distintas. Agora criemos um programa que envia pacotes para o dito grupo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // MSender.java import java.io.* ; import java.net.* ; public class MSender { public static void main ( String [] args ) { byte [] outBuf ; final int PORT = 8888 ; try { DatagramSocket socket = new DatagramSocket (); long counter = 0 ; InetAddress address = InetAddress . getByName ( \"224.2.2.3\" ); while ( true ) { counter ++ ; outBuf = ( \"Multicast numero \" + counter + \" \" + address ). getBytes (); DatagramPacket outPacket = new DatagramPacket ( outBuf , outBuf . length , address , PORT ); socket . send ( outPacket ); try { Thread . sleep ( 500 ); } catch ( InterruptedException ie ) {} } } catch ( IOException ioe ) { System . out . println ( ioe ); } } } Observe como a mesma mensagem \u00e9 recebida pelos v\u00e1rios membros e que como diferentes fontes tem seus pacotes recebidos. A t\u00edtulo de curiosidade, IP-Multicast tamb\u00e9m est\u00e1 presente em IPv6, mas com algumas pequenas diferen\u00e7as IP-Multicast em IPv6 4 In IPv6, the left-most bits of an address are used to determine its type. For a multicast address, the first 8 bits are all ones, i.e. FF00::/8. Further, bit 113-116 represent the scope of the address, which can be either one of the following 4: Global, Site-local, Link-local, Node-local. In addition to unicast and multicast, IPv6 also supports anycast, in which a packet can be sent to any member of the group, but need not be sent to all members.'' Exerc\u00edcio: IP-Multicast Implemente e teste o seguinte sevidor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import socket import struct MCAST_GRP = '224.1.1.1' MCAST_PORT = 5007 sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM , socket . IPPROTO_UDP ) sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , 1 ) sock . bind (( MCAST_GRP , MCAST_PORT )) mreq = struct . pack ( \"=4sl\" , socket . inet_aton ( MCAST_GRP ), socket . INADDR_ANY ) #4 bytes (4s) seguidos de um long (l), usando ordem nativa (=) sock . setsockopt ( socket . IPPROTO_IP , socket . IP_ADD_MEMBERSHIP , mreq ) while True : print ( sock . recv ( 10240 ) . decode ()) Implemente e teste o seguinte cliente. 1 2 3 4 5 6 7 8 import socket MCAST_GRP = '224.1.1.1' MCAST_PORT = 5007 sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM , socket . IPPROTO_UDP ) sock . setsockopt ( socket . IPPROTO_IP , socket . IP_MULTICAST_TTL , 2 ) sock . sendto ( input () . encode (), ( MCAST_GRP , MCAST_PORT ))","title":"IP-Multicast"},{"location":"teaching/gbc074gsi028/basics/#referencias","text":"UDP em Python UDP em Python Multicast em Java Multicast em Python","title":"Refer\u00eancias"},{"location":"teaching/gbc074gsi028/basics/#multiprogramacao-e-multithreading-em-sistemas-distribuidos","text":"\u00c9 imposs\u00edvel pensar em sistemas distribu\u00eddos sem pensar em concorr\u00eancia na forma de m\u00faltiplos processos executando, normalmente, em hosts distintos. De fato, os exemplos que apresentamos at\u00e9 agora consistem todos em um processo cliente requisitando a\u00e7\u00f5es de algum processo servidor. Apesar disso, a intera\u00e7\u00e3o entre tais processos aconteceu sempre de forma sincronizada, lock-step , em que o cliente requisitava o servi\u00e7o e ficava bloqueado esperando a resposta do servidor, para ent\u00e3o prosseguir em seu processamento, e o servidor fica bloqueado esperando requisi\u00e7\u00f5es, que atende e ent\u00e3o volta a dormir. Este cen\u00e1rio, apresentado na figura a seguir, mostra que apesar do uso de processadores distintos e da concorr\u00eancia na execu\u00e7\u00e3o dos processos, temos um baixo grau de efetivo paralelismo. sequenceDiagram activate Cliente note left of Cliente: Ativo (gerando requisi\u00e7\u00e3o) note right of Servidor: Inativo (esperando requisi\u00e7\u00e3o) Cliente->>+Servidor: Request deactivate Cliente note left of Cliente: Inativo (esperando resposta) note right of Servidor: Ativo (processando requisi\u00e7\u00e3o) Servidor-->>-Cliente: Response activate Cliente note left of Cliente: Ativo (processando resposta note right of Servidor: Inativo (esperando requisi\u00e7\u00e3o) deactivate Cliente Para usarmos melhor os recursos dispon\u00edveis, tanto do lado dos clientes quanto servidores, uma das raz\u00f5es de ser da computa\u00e7\u00e3o distribu\u00edda, temos ent\u00e3o que pensar em termos eventos sendo disparados entre os componentes, que devem ser tratados assim que recebidos ou t\u00e3o logo haja recursos para faz\u00ea-lo. Estes eventos correspondem tanto a requisi\u00e7\u00f5es quanto a respostas (efetivamente tornando dif\u00edcil a distin\u00e7\u00e3o). Al\u00e9m disso, sempre que poss\u00edvel, um componente n\u00e3o deve ficar exclusivamente esperando por eventos, aproveitando a chance executar outras tarefas at\u00e9 que eventos sejam recebidos. Dada que processos interagem com a rede usando sockets, cuja opera\u00e7\u00e3o de leitura \u00e9 bloqueante, para aumentar a concorr\u00eancia em um processo, precisamos falar de multi-threading. H\u00e1 duas raz\u00f5es claras para estudarmos multi-threading. A primeira, de ordem pr\u00e1tica, \u00e9 a discutida acima: permitir o desenvolvimento de componentes que utilizem \"melhormente\" os recursos em um host. A segunda, did\u00e1tica, \u00e9 o fato que muitos dos problemas que aparecem em programa\u00e7\u00e3o multi-thread, aparecem em programa\u00e7\u00e3o multi-processo (como nos sistemas distribu\u00eddos), apenas em um grau de complexidade maior. Para relembrar, h\u00e1 v\u00e1rias diferen\u00e7as entre threads e processos, mas a abstra\u00e7\u00e3o \u00e9 essencialmente a mesma: Processo Thread Inst\u00e2ncia de um programa \"Processo leve\" Estado do processo Estado do thread Fun\u00e7\u00e3o main \"qualquer\" fun\u00e7\u00e3o Mem\u00f3ria privada ao processo Compartilha estado do processo que os cont\u00e9m C\u00f3digo, Stack, Heap, descritores (e.g, file descriptors), controle de acesso Stack, vari\u00e1veis locais IPC - Inter process communication IPC -- Inter process communication Sistema operacional Diferentes implementa\u00e7\u00f5es Posix, C++, Java, ... Vejamos como o uso de m\u00faltiplos threads podem melhorar o desenvolvimento de sistemas distribu\u00eddos na pr\u00e1tica. Considere os exemplos de clientes e servidores vistos anteriormente . Imagine que em vez do servi\u00e7o simples feito no exemplo, o servidor retorne uma p\u00e1gina Web. Detalhes do protocolo seguido por navegadores e servidores ser\u00e3o vistos mais tarde. Por agora, considere apenas que uma requi\u00e7\u00e3o GET arquivo.html ser\u00e1 enviada para o servidor que ler\u00e1 o arquivo especificado do sistema de arquivos; como voc\u00ea sabe, ler um arquivo \u00e9 uma opera\u00e7\u00e3o lenta e que n\u00e3o requer CPU.","title":"Multiprograma\u00e7\u00e3o e Multithreading em Sistemas Distribu\u00eddos"},{"location":"teaching/gbc074gsi028/basics/#cliente-multithreaded","text":"Do ponto de vista do cliente, a vantagem do uso de m\u00faltiplos threads s\u00e3o claras: permite lidar com v\u00e1rias tarefas concorrentemente , por exemplo solicitar CSS, HTML e imagens concorrentemente, escondendo lat\u00eancia das v\u00e1rias opera\u00e7\u00f5es, e permite organizar c\u00f3digo em blocos/m\u00f3dulos. Se voc\u00ea usar o console de desenvolvimento do navegador, ver\u00e1 que trinta e seis requisi\u00e7\u00f5es s\u00e3o feitas para carregar a p\u00e1gina www.google.com ; um n\u00famero muito maior \u00e9 feito na carga de www.bing.com . Bug Estender","title":"Cliente multithreaded"},{"location":"teaching/gbc074gsi028/basics/#servidor-multithreaded","text":"","title":"Servidor multithreaded"},{"location":"teaching/gbc074gsi028/basics/#multithread-na-pratica","text":"","title":"Multithread na pr\u00e1tica"},{"location":"teaching/gbc074gsi028/comm/","text":"Communica\u00e7\u00e3o O desenvolvimento de sistemas distribu\u00eddos usando diretamente Sockets como forma de comunica\u00e7\u00e3o entre componentes n\u00e3o \u00e9 para os fracos de cora\u00e7\u00e3o. Sua grande vantagem est\u00e1 no acesso baixo n\u00edvel \u00e0 rede , e todo o ganho de desempenho que isso pode trazer. Suas desvantagens, entretanto, s\u00e3o v\u00e1rias: interface de \"arquivo\" para se ler e escrever bytes; controle de fluxo de \"objetos\" \u00e9 por conta da aplica\u00e7\u00e3o, isto \u00e9, a aplica\u00e7\u00e3o precisa sinalizar quantos bytes ser\u00e3o escritos de um lado, para que o outro saiba quanto ler para obter um \"objeto\" correto; logo, a serializa\u00e7\u00e3o e desserializa\u00e7\u00e3o de objetos \u00e9 tamb\u00e9m por conta da aplica\u00e7\u00e3o; tratamento de desconex\u00f5es e eventuais reconex\u00f5es tamb\u00e9m \u00e9 gerenciado pela aplica\u00e7\u00e3o e nem a t\u00e3o famosa confiabilidade do TCP ajuda. Enquanto se poderia argumentar que algumas destas desvantagens podem ser descartadas em fun\u00e7\u00e3o da discuss\u00e3o de incluir ou n\u00e3o API na comunica\u00e7\u00e3o fim-a-fim , \u00e9 certo que algumas funcionalidades s\u00e3o ub\u00edquas em aplica\u00e7\u00f5es distribu\u00eddas. Aqui discutiremos algumas destas funcionalidades e como podem e s\u00e3o implementadas por frameworks de comunica\u00e7\u00e3o de mais alto n\u00edvel. Representa\u00e7\u00e3o de dados Exceto por aplica\u00e7\u00f5es muito simples, processos em um sistema distribu\u00eddos trocam dados complexos, por exemplo estruturas ou classes com diversos campos, incluindo valores num\u00e9ricos de diversos tipos, strings e vetores de bytes, com diversos n\u00edveis de aninhamento e somando v\u00e1rios KB. Neste cen\u00e1rio, v\u00e1rios fatores precisam ser levados em considera\u00e7\u00e3o na hora de colocar esta estrutura no fio , por exemplo: Diferentes linguagens de programa\u00e7\u00e3o usadas para desenvolver os componentes. tipos com defini\u00e7\u00e3o imprecisa, por exemplo \"inteiro\": 8: 16, 32, 64 ou bits? paradigmas distintos: classe x estrutura conjunto de caracteres diferentes: ASCII x UTF Arquiteturas diferentes. ordem dos bytes little endian? x64 IA-32 big endian? IP SPARC (< V9) Motorola PowerPC bi-endian? ARM, MIPS, IA-64 representa\u00e7\u00e3o de ponto flutuante alinhamento de bytes Sistemas operacionais diferentes crlf (DOS) x lf (Unix) fragmenta\u00e7\u00e3o Representa\u00e7\u00e3o Textual Uma abordagem comumente usada \u00e9 a representa\u00e7\u00e3o em formato textual \"amig\u00e1vel a humanos\". Veja o exemplo de como o protocolo HTTP requisita e recebe uma p\u00e1gina HTML. 1 2 3 4 5 6 telnet www.google.com 80 Trying 187.72.192.217... Connected to www.google.com. Escape character is '^]'. GET / HTTP/1.1 host: www.google.com As linhas 5 e 6 s\u00e3o entradas pelo cliente para requisitar a p\u00e1gina raiz do s\u00edtio www.google.com . A linha 7, vazia, indica ao servidor que a requisi\u00e7\u00e3o est\u00e1 terminada. Em resposta a esta requisi\u00e7\u00e3o, o servidor envia o seguinte, em que as primeiras linhas trazem metadados da p\u00e1gina requisitada e, ap\u00f3s a linha em branco, vem a resposta em HTML \u00e0 requisi\u00e7\u00e3o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 HTTP/1.1 302 Found Location: http://www.google.com.br/?gws_rd=cr & ei=HTDqWJ3BDYe-wATs_a3ACA Cache-Control: private Content-Type: text/html; charset=UTF-8 P3P: CP=\"This is not a P3P policy! See https://www.google.com/support/accounts/answer/151657?hl=en for more info.\" Date: Sun, 09 Apr 2017 12:59:09 GMT Server: gws Content-Length: 262 X-XSS-Protection: 1; mode=block X-Frame-Options: SAMEORIGIN Set-Cookie: NID=100=NB_AruuFWL0hXk2-h7VDduHO_UkjAr6RaqgG7VbccTsfLzFfhxEKx21Xpa2EH7IgshgczE9vU4W1TyKsa07wQeuZosl5DbyZluR1ViDRf0C-5lRpd9cCpCD5JXXjy-UE; expires=Mon, 09-Oct-2017 12:59:09 GMT; path=/; domain=.google.com; HttpOnly < HTML >< HEAD >< meta http-equiv = \"content-type\" content = \"text/html;charset=utf-8\" > < TITLE > 302 Moved </ TITLE ></ HEAD >< BODY > < H1 > 302 Moved </ H1 > The document has moved < A HREF = \"http://www.google.com.br/?gws_rd=cr&amp;ei=HTDqWJ3BDYe-wATs_a3ACA\" > here </ A > . </ BODY ></ HTML > Representa\u00e7\u00f5es textuais s\u00e3o usadas em diversos protocolos como SMTP, POP, e telnet. Algumas destas representa\u00e7\u00f5es seguem padr\u00f5es formalizados, o que facilita a gera\u00e7\u00e3o e interpreta\u00e7\u00e3o dos dados. Dois padr\u00f5es bem conhecidas s\u00e3o XML e JSON. XML \u00e9 o acr\u00f4nimo para Extensible Markup Language , ou seja, uma linguagem marca\u00e7\u00e3o que pode ser estendida para representar diferentes tipos de informa\u00e7\u00e3o. A HTML, por exemplo, \u00e9 uma inst\u00e2ncia de XML destinada \u00e0 representa\u00e7\u00e3o de hipertexto (A bem da verdade, XML foi uma generaliza\u00e7\u00e3o de HTML). Por exemplo, para representarmos os dados relativos \u00e0 uma pessoa, podemos ter uma inst\u00e2ncia XML assim: 1 2 3 4 5 6 7 8 9 <person> <name> John Doe </name> <id> 112234556 </id> <email> jdoe@example.com </email> <telephones> <telephone type= \"mobile\" > 123 321 123 </telephone> <telephone type= \"home\" > 321 123 321 </telephone> </telephones> </person> Uma das grandes vantagens do uso de XML \u00e9 a possibilidade de se formalizar o que pode ou n\u00e3o estar em um arquivo para um certo dom\u00ednio utilizando um XML Domain Object Model . H\u00e1, por exemplo, modelos para representa\u00e7\u00e3o de documentos de texto, governos eletr\u00f4nicos, representa\u00e7\u00e3o de conhecimento, etc . Sua maior desvantagem \u00e9 que \u00e9 muito verborr\u00e1gico e por vezes complicado de se usar, abrindo alas para o seu mais famoso concorrente, JSON. JSON \u00e9 o acr\u00f4nimo de Javascript Object Notation , isto \u00e9, o formato para representa\u00e7\u00e3o de objetos da linguagem Javascript. Devido \u00e0 sua simplicidade e versatilidade, entretanto, foi adotado como forma de representa\u00e7\u00e3o de dados em sistemas desenvolvidos nas mais diferentes linguagens. O mesmo exemplo visto anteriormente, em XML, \u00e9 representado em JSON assim: 1 2 3 4 5 6 7 8 9 { \"name\" : \"John Doe\" , \"id\" : 112234556 , \"email\" : \"jdoe@example.com\" , \"telephones\" : [ { \"type\" : \"mobile\" , \"number\" : \"123 321 123\" }, { \"type\" : \"home\" , \"number\" : \"321 123 321\" }, ] } Em Python, por exemplo, JSON s\u00e3o gerados e interpretados nativamente, sem a necessidade de frameworks externos, facilitando seu uso. Mas de fato, a op\u00e7\u00e3o final por XML ou JSON \u00e9 quest\u00e3o de prefer\u00eancia, uma vez que os dois formatos s\u00e3o, de fato, equivalentes na quest\u00e3o da representa\u00e7\u00e3o de informa\u00e7\u00e3o. Outros formatos, bin\u00e1rios, oferecem vantagens no uso de espa\u00e7o para armazenar e transmitir dados, e por isso s\u00e3o frequentemente usados como forma de serializa\u00e7\u00e3o de dados em sistemas distribu\u00eddos, isto \u00e9, na transforma\u00e7\u00e3o de TAD para sequ\u00eancias de bytes que seguir\u00e3o \"no fio\". ASN.1 (Abstract Syntax Notation), pela ISO XDR (eXternal Data Representation) Java serialization Google Protocol Buffers Thrift ASN.1 e XDR s\u00e3o de interesse hist\u00f3rico, mas n\u00e3o os discutiremos aqui. Quanto \u00e0 serializa\u00e7\u00e3o feita nativamente pelo Java, por meio de ObjectOutputStreams , como neste exemplo , embora seja tentadora para quem usa Java, \u00e9 necess\u00e1rio saber que ela \u00e9 restrita \u00e0 JVM e que usa muito espa\u00e7o, embora minimize riscos de uma desserializa\u00e7\u00e3o para uma classe diferente. Nos foquemos nas autras alternativas listadas, ProtoBuffers e Thrift, que podem levar a representa\u00e7\u00f5es bin\u00e1rias e textuais. ProtoBuffers Nas palavras dos criadores , Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data. Por meio de protobuffers, \u00e9 poss\u00edvel estruturar dados e gerar o c\u00f3digo correspondente em diversas linguagens, for forma compartilh\u00e1vel entre as mesmas. Veja o exemplo a seguir, que especifica os dados referentes a uma pessoa. Observe a presen\u00e7a de campos de preenchimento opcional ( optional ), de enumera\u00e7\u00f5es ( enum ), e de cole\u00e7\u00f5es ( repeated ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 message Person { required string name = 1 ; required int32 id = 2 ; optional string email = 3 ; enum PhoneType { MOBILE = 0 ; HOME = 1 ; WORK = 2 ; } message PhoneNumber { required string number = 1 ; optional PhoneType type = 2 [ default = HOME ]; } repeated PhoneNumber phone = 4 ; } Com tal defini\u00e7\u00e3o \u00e9 poss\u00edvel gerar c\u00f3digo como o seguinte, em C++, que serializa os dados para escrita em um arquivo... 1 2 3 4 5 6 Person person ; person . set_name ( \"John Doe\" ); person . set_id ( 1234 ); person . set_email ( \"jdoe@example.com\" ); fstream output ( \"myfile\" , ios :: out | ios :: binary ); person . SerializeToOstream ( & output ); e l\u00ea do arquivo e desserializa para hidratar um novo objeto. 1 2 3 4 5 fstream input ( \"myfile\" , ios :: in | ios :: binary ); Person person ; person . ParseFromIstream ( & input ); cout << \"Name: \" << person . name () << endl ; cout << \"E-mail: \" << person . email () << endl ; De acordo com benchmarks do pr\u00f3prio projeto , a opera\u00e7\u00e3o em XML seria mais ordens de grandeza mais lenta e ocuparia mais espa\u00e7o. When this message is encoded to the protocol buffer binary format, it would probably be 28 bytes long and take around 100-200 nanoseconds to parse. The XML version is at least 69 bytes if you remove whitespace, and would take around 5,000-10,000 nanoseconds to parse. Thrift TODO Thrift como forma de representa\u00e7\u00e3o de dados. Invoca\u00e7\u00e3o Remota de Procedimentos - RPC Em 1984, Birrel e Nelson 1 introduziram o mecanismo de Invoca\u00e7\u00e3o Remota de Procedimentos ( Remote Procedure Calls ), que permite que processos fa\u00e7am, pasmem, invoca\u00e7\u00f5es de procedimentos remotos! \u00d3bvio, a inova\u00e7\u00e3o n\u00e3o est\u00e1 na capacidade de uma m\u00e1quina conversar com outra, mas em como esta conversa acontece, do ponto de vista do programador. Por exemplo, RPC permita que se procure a substring \"teste\" dentro da string apontada por a , a partir da posi\u00e7\u00e3o 3, usando x = substring(a,3,\"teste\"); , mas com o invocador da fun\u00e7\u00e3o em um processo e a implementa\u00e7\u00e3o da fun\u00e7\u00e3o propriamente dita, em outro, possivelmente em outra m\u00e1quina. Stubs Antes de nos aprofundarmos, vejamos como uma invoca\u00e7\u00e3o de fun\u00e7\u00f5es acontece normalmente dentro de um \u00fanico processo 2 . O c\u00f3digo x = substring(a,3,\"teste\"); , que procura \"teste\" em *a , \u00e9 traduzido nos seguintes passos em linguagem de m\u00e1quina: coloque o endere\u00e7o de \"teste\" na pilha coloque 3 na pilha coloque o valor de a na pilha coloque o endere\u00e7o de retorno na pilha (junto com outros dados de controle) salte para substring ajustando o instruction pointer ... procure substring ... coloque o resultado no acumulador limpe a pilha salte de volta recuperando o endere\u00e7o de retorno da pilha e ajustando o IP coloque resultado em x Se o que queremos \u00e9 colocar o c\u00f3digo da fun\u00e7\u00e3o substring em um outro processo e execut\u00e1-lo como se estiv\u00e9ssemos no mesmo processo que faz a invoca\u00e7\u00e3o, precisamos pensar em v\u00e1rias quest\u00f5es relativas ao fluxo mostrado acima. Claramente n\u00e3o podemos usar o mesmo fluxo para invocar uma fun\u00e7\u00e3o, mas precisamos de c\u00f3digo de simule a invoca\u00e7\u00e3o local mas que, por baixo do cap\u00f4, use sockets para se comunicar com o processo remoto. Estq simula\u00e7\u00e3o usar\u00e1 c\u00f3digo extra, que finge implementar substring para o invocador mas delega ao c\u00f3digo remoto o trabalho real da busca. Este c\u00f3digo extra \u00e9 conhecido como stub , ou para ser mais preciso, stub cliente , que faz parte do processo invocando a opera\u00e7\u00e3o, e stub servidor, que faz parte do processo executando a opera\u00e7\u00e3o invocada 3 . Assim, o cliente invoca fun\u00e7\u00e3o no stub cliente, achando que \u00e9 a fun\u00e7\u00e3o que quer executar. Stub cliente faz o marshaling 4 dos par\u00e2metros e usa o SO para transferir os dados via rede para o stub servidor. Quando recebe a resposta do servidor, o stub cliente retorna a mesma resposta, como se tivesse calculado localmente. Stub cliente Implementa uma fun\u00e7\u00e3o substring(char*, int, char*) que abre socket para servidor envia par\u00e2metros especifica fun\u00e7\u00e3o espera resposta retorna resultado J\u00e1 o stub servidor fica esperando o contato do cliente. Quando acontece, faz o \"unmarshalling\" dos dados, invoca a fun\u00e7\u00e3o localmente na aplica\u00e7\u00e3o servidor e pega o resultado, que retona ao cliente. Stub servidor espera conex\u00e3o recebe par\u00e2metros recebe especifica\u00e7\u00e3o da fun\u00e7\u00e3o invoca fun\u00e7\u00e3o localmente envia resultado para cliente Transpar\u00eancia \u00c9 para o programador a grande vantagem do uso de RPC, pois se pode escrever c\u00f3digo distribu\u00eddo \"igual\" ao centralizado, certo? Isto \u00e9, interface baseada em procedimentos e sem a necessidade de detalhar portas, sockets, e representa\u00e7\u00e3o de dados . Ou seja, tudo \u00e9 transparente! Como j\u00e1 discutimos, v\u00e1rios fatores trabalham contra a transpar\u00eancia em sistemas distribu\u00eddos . Em espec\u00edfico quanto \u00e0 transpar\u00eancia dada pelo RPC, tamb\u00e9m temos limita\u00e7\u00f5es. O problema \u00e9 que h\u00e1 uma distin\u00e7\u00e3o clara em pelo menos dois processos e se pensarmos no c\u00f3digo descrito acima, temos que entender que processos independentes n\u00e3o compartilham um espa\u00e7o de endere\u00e7amento, e processos independentes n\u00e3o compartilham uma pilha. Assim, como fica a passagem de par\u00e2metro por refer\u00eancia , uma vez que o stub servidor n\u00e3o pode usar endere\u00e7os do espa\u00e7o de endere\u00e7amento do cliente? Algumas abordagens para simular a passagem por refer\u00eancia s\u00e3o poss\u00edveis. Por exemplo, o valor apontado pelo ponteiro \u00e9 passado para o servidor , que armazena o valor e alguma posi\u00e7\u00e3o de mem\u00f3ria e passa o endere\u00e7o de tal posi\u00e7\u00e3o para a fun\u00e7\u00e3o invocada. Contudo, a modifica\u00e7\u00e3o do valor pela fun\u00e7\u00e3o n\u00e3o reflete imediatamente no invocador; tais valores tem que ser copiados novamente e usados para sobrescrever o valor original no cliente. Al\u00e9m disso, esta abordagem s\u00f3 \u00e9 poss\u00edvel se o valor apontado for delimitado, o que nem sempre \u00e9 f\u00e1cil de determinar. Por exemplo, se o ponteiro for para o primeiro elemento de uma lista, o que deve ser copiado para o servidor? S\u00f3 o primeiro elemento? Toda a lista? Como ensinar para o framework RPC o que \u00e9 \"toda\" a lista? Java \"resolve\" o problema da passagem de par\u00e2metro por refer\u00eancia passando todo o grafo do objeto passado como par\u00e2metro para o servidor. Isto \u00e9, al\u00e9m de serializar o objeto apontado no par\u00e2metro, se o mesmo aponta para outros objetos, estes tamb\u00e9m ser\u00e3o serializados e transferidos; o servidor ir\u00e1 ent\u00e3o reconstruir todo o grafo e passar para o m\u00e9todo sendo invocado. \u00c9 muito f\u00e1cil ver que esta abordagem pode se tornar invi\u00e1vel rapidamente. Quando for o caso, Java permite marcar objetos como remotos e, em vez de serializar este objeto e enviar para o servidor, envia informa\u00e7\u00e3o suficiente para que o servidor possa invocar m\u00e9todos em tal objeto no cliente, tornando nebulosa a defini\u00e7\u00e3o de quem \u00e9 quem. Outros fatores tamb\u00e9m trabalham contra a transpar\u00eancia para o desenvolvedor. Vejamos alguns Descoberta de Servi\u00e7os Por exemplo, mesmo que o socket seja ocultado, ele ainda existe e precisa de informa\u00e7\u00f5es sobre onde se conectar (endere\u00e7o e porta), que de alguma forma deve ser passada para o framework de RPC. Esta informa\u00e7\u00e3o pode ser configurada a priori por um administrador de sistemas, mas requer atualiza\u00e7\u00f5es sempre que a localiza\u00e7\u00e3o do servi\u00e7o for alterada ou novos servidores adicionados. Mais interessante seria um mecanismo que permitisse uma indire\u00e7\u00e3o para o servi\u00e7o; o pr\u00f3prio DNS pode ser uma op\u00e7\u00e3o inicial, mas um servi\u00e7o dedicado pode ser mais apropriado, pois permite descobrir servi\u00e7os e n\u00e3o apenas servidores. Birrel e Nelson propuseram um servi\u00e7o de P\u00e1ginas Amarelas , no qual clientes podem questionar quem oferece um certo servi\u00e7o e serem redirecionados automaticamente. Esta abordagem tem seus pr\u00f3prios problemas, como por exemplo determinar quem administra o servi\u00e7o para incluir novos servidores. E como determinar qual servi\u00e7o acessar, caso hajam m\u00faltiplas op\u00e7\u00f5es de servidores . Apesar dos problemas, p\u00e1ginas amarelas foram usadas em abordagens muito mais recentes para descobertas de servi\u00e7os, por exemplo Web Services Discovery , que permite a descoberta de Web Services em escala global, e Java Remote Object Registry que permite a descoberta de objetos remotos Java. Tratamento de Exce\u00e7\u00f5es Uma vez que a invoca\u00e7\u00e3o \u00e9 remota, h\u00e1 sempre o risco de problemas de comunica\u00e7\u00e3o entre cliente e servidor. Logo, \u00e9 necess\u00e1ria a introdu\u00e7\u00e3o de c\u00f3digo para tratamento de erros deste tipo, o que absolutamente n\u00e3o era necess\u00e1rio no caso do c\u00f3digo centralizado. Assim, o que era um simples x = substring(a,3,\"teste\"); passa para algo assim (em uma linguagem fict\u00edcia): 1 2 3 4 5 6 7 8 9 10 11 12 13 int x = - 2 ; try { x = substring ( a , 3 , \"teste\" ); ` } catch ( CommunicationFailureException cfe ) { log_error ( \"Como pode substring falhar? Desespero!!!\" ); } if ( x == - 2 ) system_exit ( - 2 ) else if ( x == - 1 ) //n\u00e3o achou else //achou \"teste\" na posi\u00e7\u00e3o x O que nos leva novamente ao ponto sobre n\u00e3o haver transpar\u00eancia total em sistemas distribu\u00eddos... e esta falta de transpar\u00eancia pode ser muito mais complicada do que simplesmente adicionar try e catch ao seu c\u00f3digo. Mais que isso, imagine que a opera\u00e7\u00e3o sendo executada altere algum estado no servidor. Se esta fosse uma operac\u00e3o local, cada invoca\u00e7\u00e3o da opera\u00e7\u00e3o corresponderia a exatamente uma execu\u00e7\u00e3o da opera\u00e7\u00e3o, na aus\u00eancia de falhas. No caso de falhas, se o processo quebra como um todo, no seu rein\u00edcio, pode-se identificar se a opera\u00e7\u00e3o foi ou n\u00e3o executada e aplicar a\u00e7\u00f5es corretivas. Mas e no caso remoto? Reexecu\u00e7\u00f5es No caso da opera\u00e7\u00e3o distribu\u00edda, se o servidor quebra, isso levar\u00e1 a um erro ser percebido do lado do cliente como uma falha na conex\u00e3o . Se o cliente havia invocado uma opera\u00e7\u00e3o mas percebeu o erro antes de receber uma confirma\u00e7\u00e3o de sua execu\u00e7\u00e3o, isto pode indicar que: (i) ou a requisi\u00e7\u00e3o nunca foi recebida pelo servidor e, portanto, n\u00e3o foi executada, (ii) ou a execu\u00e7\u00e3o foi recebida e executada, mas a resposta n\u00e3o foi enviada. O cliente tem que tratar o erro, mas como? Se a opera\u00e7\u00e3o precisa ser executada a qualquer custo , o cliente pode retent\u00e1-la quando conseguir novo contato com o servidor (ou mesmo com outro). Neste caso, se o que de fato aconteceu foi a situa\u00e7\u00e3o (i), ent\u00e3o retentar garantir\u00e1 que a opera\u00e7\u00e3o seja executada pelo servidor, mesmo que v\u00e1rias tentativas sejam necess\u00e1rias. Contudo, se o que o ocorreu foi a situa\u00e7\u00e3o (ii), ent\u00e3o reenviar a opera\u00e7\u00e3o levar\u00e1 a mesma a ser executada m\u00faltiplas vezes, o que pode ou n\u00e3o ser ok. Esta abordagem \u00e9 garantir\u00e1 que a execu\u00e7\u00e3o acontece pelo menos 1 vez . Imagine que a opera\u00e7\u00e3o se tratasse de uma transfer\u00eancia de saldo, ou a encomenda de de um caminh\u00e3o carregado de algum produto caro. Neste caso, reexecutar n\u00e3o parece ser uma op\u00e7\u00e3o. Neste caso, talvez a melhor op\u00e7\u00e3o seja n\u00e3o retentar a opera\u00e7\u00e3o, o que levar\u00e1 a zero execu\u00e7\u00f5es na situa\u00e7\u00e3o (ii) e uma execu\u00e7\u00e3o na situa\u00e7\u00e3o, ou seja, a no m\u00e1ximo uma execu\u00e7\u00e3o. Uma situa\u00e7\u00e3o em que esta abordagem \u00e9 claramente prefer\u00edvel \u00e9 a entrega de quadros em um stream de v\u00eddeo ou \u00e1udio, devido \u00e0 import\u00e2ncia da opera\u00e7\u00e3o ser atrelada ao momento de sua execu\u00e7\u00e3o. Nenhuma destas abordagens \u00e9 igual ao que \u00e9 garantido na vers\u00e3o centralizada e que \u00e9 provelmente o que todo desenvolvedor desejaria para suas invoca\u00e7\u00f5es de m\u00e9todos, que fossem executados exatamente uma vez. Garantir esta sem\u00e2ntica na comunica\u00e7\u00e3o \u00e9 muito dif\u00edcil, pois \u00e9 imposs\u00edvel ter certeza de que uma mensagem n\u00e3o foi processada pelo servidor ainda. De fato, \u00e9 imposs\u00edvel ter certeza se o servidor falhou; pode ter sido apenas uma falha na comunica\u00e7\u00e3o. Quantidade de execu\u00e7\u00f5es No m\u00e1ximo uma - n\u00e3o retentar Exatamente uma - impedir que falhas aconte\u00e7am :/ Pelo menos uma - retentar at\u00e9 ter confirma\u00e7\u00e3o Como \u00e9 imposs\u00edvel evitar falhas, se uma opera\u00e7\u00e3o deve executada, ela deve ser retentada. Mas ela n\u00e3o pode ser repetida, ent\u00e3o a alternativa \u00e9 tornar as opera\u00e7\u00f5es idempotentes , o que quer dizer que o efeito desejado \u00e9 alcan\u00e7ado pela primeira execu\u00e7\u00e3o e que execu\u00e7\u00f5es seguintes n\u00e3o alteram o estado. Opera\u00e7\u00f5es idempotentes M\u00faltiplas execu\u00e7\u00f5es tem o mesmo efeito uma execu\u00e7\u00e3o. Exemplo: x = 10 Anti-exemplo: x = x+1 . Infelizmente n\u00e3o \u00e9 trivial programar para idempot\u00eancia, principalmente se o servidor for acessado concorrentemente por m\u00faltiplos clientes, tornando seu estado uam regi\u00e3o cr\u00edtica. Concorr\u00eancia no servidor \u00c9 importante notar que um servidor n\u00e3o est\u00e1 obrigado a atender requisi\u00e7\u00f5es de somente um cliente. Logo, se m\u00faltiplos clientes acessam o mesmo servidor, o estado do servidor ser\u00e1 \"compartilhado\" pelos v\u00e1rios clientes e passos s\u00e3o necess\u00e1rios para que o comportamento no acesso deste estado seja coerente com a especifica\u00e7\u00e3o. Pense por exemplo em um servidor que conta o n\u00famero de acessos feitos por clientes. O incremento do contador deve ser considerado uma regi\u00e3o cr\u00edtica, caso m\u00faltiplos threads tratem as requisi\u00e7\u00f5es dos clientes, o que j\u00e1 vimos ser uma boa idia. Claro que dificilmente seu servidor seria algo t\u00e3o simples assim. Em vez disso, ele provavelmente executar\u00e1 l\u00f3gicas complicadas, como por exemplo, armazenar o estado de contas banc\u00e1rias e, neste caso, as fun\u00e7\u00f5es expostas por RPC incluir\u00edam a opera\u00e7\u00e3o transferir saldo de A para B , o que nos leva a mais um problema interessante, o do risco de reexecu\u00e7\u00f5es. Al\u00e9m disso, o servidor provavelmente suportar\u00e1 diversas opera\u00e7\u00f5es e por isso dever\u00e1 identificar qual a opera\u00e7\u00e3o sendo requisitada. Isto \u00e9 feito por um dispatcher , que demultiplexa as opera\u00e7\u00f5es requisitadas; o dispatcher pode, em algumas arquiteturas, ser independente do skeleton em si. Frameworks H\u00e1 diversas op\u00e7\u00f5e de frameworks para RPC, com diferentes caracter\u00edsticas, focos, e garantias. Alguns s\u00e3o parte da linguagem e outros s\u00e3o implementados como bibliotecas. Alguns suportam m\u00faltiplas linguagens e alguns apenas uma. Suporte a RPC na linguagem Sem RPC: C, C++, Java < 5.0 (1.5), Python Com RPC: Java, Go, Erlang, Scala, Haskell Ambientes heterog\u00eaneos: Thrift, gRPC, Akka, SOAP Frameworks mais modernos permitem escolher a forma de serializa\u00e7\u00e3o dos dados, se leg\u00edvel para humanos ou bin\u00e1rio, se o transporte \u00e9 via HTTP ou protocolo mais baixo n\u00edvel, se os dados trafegam abertamente ou se faz uso de comunica\u00e7\u00e3o criptografada (SSL). Outros permitem escolher sem\u00e2ntica de execu\u00e7\u00e3o entre no m\u00e1ximo uma e pelo menos uma , e h\u00e1 at\u00e9 quem prometa exatamente uma . Mas todos os frameworks tem algumas caracter\u00edsticas em comum e uma delas \u00e9 o uso de uma Linguagem de Defini\u00e7\u00e3o de Interface (IDL). Interface Definition Language - IDL Uma IDL \u00e9 a linguagem pela qual desenvolvedor define quais as opera\u00e7\u00f5es (fun\u00e7\u00f5es, procedimentos, m\u00e9todos) ser\u00e3o acess\u00edveis via RPC e quais os seus operandos. H\u00e1 v\u00e1rias IDL definidas, para os diversos frameworks dispon\u00edveis. A imagem a seguir mostra um exemplo gen\u00e9rico da cria\u00e7\u00e3o cliente e servidor usando um framework RPC gen\u00e9rico, inclusive o processamento da defini\u00e7\u00e3o feita em IDL do servi\u00e7o e a jun\u00e7\u00e3o deste c\u00f3digo gerado ao c\u00f3digo escrito pelo desenvolvedor. O fluxo de processamento \u00e9 o seguinte: Arquivo em IDL \u00e9 compilado por um compilador IDL e gera diversos arquivos: stub cliente - c\u00f3digo que implementa a interface, com c\u00f3digo para repassar invoca\u00e7\u00f5es para o servidor. stub servidor ( skeleton ) - c\u00f3digo que atende a conex\u00f5es do stub cliente e repassa para a implementa\u00e7\u00e3o pr\u00f3pria da fun\u00e7\u00e3o. convers\u00e3o de dados - c\u00f3digo que serializa e deserializa dados para serem trafegados de e para o servidor cabe\u00e7alhos - defini\u00e7\u00f5es da interface na linguagem de desenvolvimento da aplica\u00e7\u00e3o; se linguagem C, por exemplo, estes ser\u00e3o arquivos .h , se em Java, ent\u00e3o estes ser\u00e3o arquivos .java , com defini\u00e7\u00e3o de interface . O c\u00f3digo cliente \u00e9 compilado e gera o cliente, que deve inicializar a infraestrutura RPC Tipo de transporte SSL? Localizar servidor Lidar com falhas O c\u00f3digo servidor \u00e9 compilado e gera o servidor, que deve exportar e localizar servi\u00e7os (servi\u00e7o de nomea\u00e7\u00e3o) Gerenciamento de portas Conex\u00f5es Mas para entendermos melhor o fluxo, vejamos algumas ferramentas reais. Estudo de Caso RPC: gRPC gRPC \u00e9 um framework para invoca\u00e7\u00e3o remota de procedimentos multi-linguagem e sistema operacional, usando internamente pelo Google h\u00e1 v\u00e1rios anos para implementar sua arquitetura de micro-servi\u00e7os. Inicialmente desenvolvido pelo Google, o gRPC \u00e9 hoje de c\u00f3digo livre encubado pela Cloud Native Computing Foundation. O s\u00edtio gRPC.io documenta muito bem o gRPC, inclusive os princ\u00edpios que nortearam seu projeto. O seu uso segue, em linhas gerais, o modelo discutido nas se\u00e7\u00f5es anteriores, isto \u00e9, inicia-se pela defini\u00e7\u00e3o de estruturas de dados e servi\u00e7os, \"compila-se\" a defini\u00e7\u00e3o para gerar stubs na linguagem desejada, e compila-se os stubs juntamente com os c\u00f3digos cliente e servidor para gerar os bin\u00e1rios correspondentes. Vejamos a seguir um tutorial passo a passo, em Java, baseado no quickstart guide . Instala\u00e7\u00e3o Os procedimentos de instala\u00e7\u00e3o dependem da linguagem em que pretende usar o gRPC, tanto para cliente quanto para servidor. No caso do Java , n\u00e3o h\u00e1 instala\u00e7\u00e3o propriamente dita . Exemplo Java Observe que o reposit\u00f3rio base apontado no tutorial serve de exemplo para diversas linguagens e diversos servi\u00e7os, ent\u00e3o sua estrutura \u00e9 meio complicada. N\u00f3s nos focaremos aqui no exemplo mais simples, uma esp\u00e9cie de \"hello word\" do RPC. Pegando o c\u00f3digo Para usar os exemplos, voc\u00ea precisa clonar o reposit\u00f3rio com o tutorial, usando o comando a seguir. 1 git clone -b v1.19.0 https://github.com/grpc/grpc-java Uma vez clonado, entre na pasta de exemplo do Java e certifique-se que est\u00e1 na vers\u00e3o 1.19, usada neste tutorial. 1 2 cd grpc-java \\e xamples git checkout v1.19.0 Compilando e executando O projeto usa gradle para gerenciar as depend\u00eancias. Para, use o wrapper do gradle como se segue. 1 ./gradlew installDist Caso esteja na UFU, coloque tamb\u00e9m informa\u00e7\u00e3o sobre o proxy no comando. 1 ./gradlew -Dhttp.proxyHost = proxy.ufu.br -Dhttp.proxyPort = 3128 -Dhttps.proxyHost = proxy.ufu.br -Dhttps.proxyPort = 3128 installDist Como quando usamos sockets diretamente, para usar o servi\u00e7o definido neste exemplo, primeiros temos que executar o servidor. 1 ./build/install/examples/bin/hello-world-server Agora, em um terminal distinto e a partir da mesma localiza\u00e7\u00e3o, execute o cliente, quantas vezes quiser. 1 ./build/install/examples/bin/hello-world-client O servi\u00e7o O exemplo n\u00e3o \u00e9 muito excitante, pois tudo o que o servi\u00e7o faz \u00e9 enviar uma sauda\u00e7\u00e3o aos clientes. O servi\u00e7o \u00e9 definido no seguinte arquivo .proto , localizado em ./src/main/proto/helloworld.proto . 1 2 3 4 5 6 7 8 9 10 11 12 13 message HelloRequest { string name = 1; } message HelloReply { string message = 1; } // The greeting service definition. service Greeter { rpc SayHello (HelloRequest) returns (HelloReply) {} } No arquivo, inicialmente s\u00e3o definidas duas mensagens, usadas como requisi\u00e7\u00e3o (cliente para servidor) e outra como resposta (servidor para cliente) do servi\u00e7o definido em seguida. A mensagem HelloRequest tem apenas um campo denominado name , do tipo string . Esta mensagem conter\u00e1 o nome do cliente, usado na resposta gerada pelo servidor. A mensagem HelloReply tamb\u00e9m tem um campo do tipo string , denominado message , que conter\u00e1 a resposta do servidor. O servi\u00e7o dispon\u00edvel \u00e9 definido pela palavra chave service e de nome Greeter ; \u00e9 importante entender que este nome ser\u00e1 usado em todo o c\u00f3digo gerado pelo compilador gRPC e que se for mudado, todas as refer\u00eancias ao c\u00f3digo gerado devem ser atualizadas. O servi\u00e7o possui apenas uma opera\u00e7\u00e3o, SayHello , que recebe como entrada uma mensagem HelloRequest e gera como resposta uma mensagem HelloReply . Caso a opera\u00e7\u00e3o precisasse de mais do que o conte\u00fado de name para executar, a mensagem HelloRequest deveria ser estendida, pois n\u00e3o h\u00e1 passar mais de uma mensagem para a opera\u00e7\u00e3o. Por outro lado, embora seja poss\u00edvel passar zero mensagens, esta n\u00e3o \u00e9 uma pr\u00e1tica recomendada. Isto porqu\u00ea caso o servi\u00e7o precisasse ser modificado no futuro, embora seja poss\u00edvel estender uma mensagem, n\u00e3o \u00e9 poss\u00edvel modificar a assinatura do servi\u00e7o. Assim, caso n\u00e3o haja a necessidade de se passar qualquer informa\u00e7\u00e3o para a opera\u00e7\u00e3o, recomenda-se que seja usada uma mensagem de entrada vazia, que poderia ser estendida no futuro. O mesmo se aplica ao resultado da opera\u00e7\u00e3o. Observe tamb\u00e9m que embora o servi\u00e7o de exemplo tenha apenas uma opera\u00e7\u00e3o, poderia ter m\u00faltiplas. Por exemplo, para definir uma vers\u00e3o em portugu\u00eas da opera\u00e7\u00e3o SayHello , podemos fazer da seguinte forma. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 message HelloRequest { string name = 1 ; } message HelloReply { string message = 1 ; } message OlaRequest { // <<<<<==== string name = 1 ; } message OlaReply { // <<<<<==== string message = 1 ; } service Greeter { rpc SayHello ( HelloRequest ) returns ( HelloReply ) {} rpc DigaOla ( OlaRequest ) returns ( OlaReply ) {} // <<<<<==== } ... Observe que a nova opera\u00e7\u00e3o recebe como entrada mensagens OlaRequest e OlaReply , que tem defini\u00e7\u00f5es exatamente iguais a HellorRequest e HelloReply . Logo, em vez de definir novas mensagens, poder\u00edamos ter usado as j\u00e1 definidas. Novamente, esta n\u00e3o \u00e9 uma boa pr\u00e1tica, pois caso fosse necess\u00e1rio evoluir uma das opera\u00e7\u00f5es para atender a novos requisitos e estender suas mensagens, n\u00e3o ser\u00e1 necess\u00e1rio tocar o restante do servi\u00e7o. Apenas refor\u00e7ando, \u00e9 boa pr\u00e1tica definir requests e responses para cada m\u00e9todo, a n\u00e3o ser que n\u00e3o haja d\u00favida de que ser\u00e3o para sempre iguais. Implementando um servi\u00e7o Agora modifique o arquivo .proto como acima, para incluir a opera\u00e7\u00e3o DigaOla , recompile e reexecute o servi\u00e7o. N\u00e3o d\u00e1 certo, n\u00e3o \u00e9 mesmo? Isto porqu\u00ea voc\u00ea adicionou a defini\u00e7\u00e3o de uma nova opera\u00e7\u00e3o, mas n\u00e3o incluiu o c\u00f3digo para implement\u00e1-la. Fa\u00e7amos ent\u00e3o a modifica\u00e7\u00e3o do c\u00f3digo, come\u00e7ando por ./src/main/java/io/grpc/examples/helloworld/HelloWorldServer.java . Este arquivo define a classe que implementa o servi\u00e7o Greeter , GreeterImpl , com um m\u00e9todo para cada uma das opera\u00e7\u00f5es definidas. Para confirmar, procure por sayHello para encontrar a implementa\u00e7\u00e3o de SayHello ; observe que a diferen\u00e7a do casing vem das boas pr\u00e1ticas de Java, de definir m\u00e9todos e vari\u00e1veis em Camel casing . Para que sua vers\u00e3o estendida do servi\u00e7o Greeter funcione, defina um m\u00e9todo correspondendo \u00e0 DigaOla , sem consultar o c\u00f3digo exemplo abaixo, mas usando o c\u00f3digo de sayHello como base; n\u00e3o se importe por enquanto com os m\u00e9todos sendo invocados. Note que os ... indicam que parte do c\u00f3digo, que n\u00e3o sofreu modifica\u00e7\u00f5es, foi omitido. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ... private class GreeterImpl extends GreeterGrpc . GreeterImplBase { ... @Override public void sayHello ( HelloRequest req , StreamObserver < HelloReply > responseObserver ) { ... } @Override public void digaOla ( OlaRequest req , StreamObserver < OlaReply > responseObserver ) { OlaReply reply = OlaReply . newBuilder (). setMessage ( \"Ola \" + req . getName ()). build (); responseObserver . onNext ( reply ); responseObserver . onCompleted (); } } Se voc\u00ea recompilar e reexecutar o c\u00f3digo, n\u00e3o perceber\u00e1 qualquer mudan\u00e7a na sa\u00edda do programa. Isto porqu\u00ea embora tenha definido um novo servi\u00e7o, voc\u00ea n\u00e3o o utilizou. Para tanto, agora modifique o cliente, em src/main/java/io/grpc/examples/helloworld/HelloWorldClient.java , novamente se baseando no c\u00f3digo existente e n\u00e3o se preocupando com \"detalhes\". 1 2 3 4 5 6 7 8 9 10 11 12 13 public void greet ( String name ) { logger . info ( \"Will try to greet \" + name + \" ...\" ); ... OlaRequest request2 = OlaRequest . newBuilder (). setName ( name ). build (); OlaReply response2 ; try { response2 = blockingStub . digaOla ( request2 ); } catch ( StatusRuntimeException e ) { logger . log ( Level . WARNING , \"RPC failed: {0}\" , e . getStatus ()); return ; } logger . info ( \"Greeting: \" + response2 . getMessage ()); } Agora sim, voc\u00ea pode reexecutar cliente e servidor. 1 2 3 ./gradlew installDist ./build/install/examples/bin/hello-world-server & ./build/install/examples/bin/hello-world-client Percebeu como foi f\u00e1cil adicionar uma opera\u00e7\u00e3o ao servi\u00e7o? Agora nos foquemos nos detalhes. Stub do servidor Como criar o servidor Como definir o servi\u00e7o Como \"startar\" o servidor. Stub do cliente Stub bloqueante Stub n\u00e3o bloqueante IDL gRPC Outras caracter\u00edsticas da IDL do gRPC Tipos b\u00e1sicos bool: boolean (true/false) double: 64-bit; ponto-flutuante float: 32-bit; ponto-flutuante i32: 32-bit; inteiro sinalizado i64: 64-bit; inteiro sinalizado siXX: signed uiXX: unsigned sfixedXX: codifica\u00e7\u00e3o de tamanho fixo bytes: 8-bit; inteiro sinalizado string: string UTF-8 ou ASCII 7-bit Any: tipo indefinido Diferentes tradu\u00e7\u00f5es Cole\u00e7\u00f5es Defina e implemente uma opera\u00e7\u00e3o DigaOlas em que uma lista de nomes \u00e9 enviada ao servidor e tal que o servidor responda com uma longa string cumprimentando todos os nomes, um ap;os o outro. Streams Do lado do servidor 1 2 3 4 5 6 7 8 9 10 11 List < String > listOfHi = Arrays . asList ( \"e aih\" , \"ola\" , \"ciao\" , \"bao\" , \"howdy\" , \"s'up\" ); @Override public void digaOlas ( OlaRequest req , StreamObserver < OlaReply > responseObserver ) { for ( String hi : listOfHi ) { OlaReply reply = OlaReply . newBuilder (). setMessage ( hi + \", \" req . getName ()). build (); responseObserver . onNext ( reply ); } responseObserver . onCompleted (); } Do lado do cliente 1 2 3 4 5 6 7 8 9 10 11 OlaRequest request = OlaRequest . newBuilder (). setName ( name ). build (); try { Iterator < OlaReply > it = blockingStub . digaOlas ( request ); while ( it . hasNext ()){ OlaReply response = it . next (); logger . info ( \"Greeting: \" + response . getMessage ()); } } catch ( StatusRuntimeException e ) { logger . log ( Level . WARNING , \"RPC failed: {0}\" , e . getStatus ()); return ; } Exemplo Python 1 2 3 4 5 6 7 8 9 10 apt-get install python3 apt-get install python3-pip python3 -m pip install --upgrade pip python3 -m pip install grpcio python3 -m pip install grpcio-tools git clone -b v1.10.x https://github.com/grpc/grpc cd grpc/examples/python/helloworld python3 greeter \\_ server.py python3 greeter \\_ client.py Para recompilar os stubs, fa\u00e7a 1 python3 -m grpc_tools.protoc -I../../protos --python_out = . --grpc_python_out = . ../../protos/helloworld.proto Modifique o servidor 1 2 def DigaOla ( self , request , context ): return helloworld_pb2 . OlaReply ( message = 'Ola, %s !' + request . name ) Modifique o cliente 1 2 response = stub . DigaOla ( helloworld_pb2 . OlaRequest ( name = 'zelelele' )) print ( \"Greeter client received: \" + response . message ) Estudo de Caso RPC: Thrift Thrift Instala\u00e7\u00e3o Baixe e compile o thrift ou instale-o usando apt-get, por exemplo. apt-get install thrift-compiler execute \"thrift\" na linha de comando. Para thrift com Java, tamb\u00e9m precisar\u00e3o dos seguintes arquivos slf4j libthrift0.9.3.jar coloque-os na pasta jars IDL Thrift Tipos b\u00e1sicos bool: boolean (true/false) byte: 8-bit; inteiro sinalizado i16: 16-bit; inteiro sinalizado i32: 32-bit; inteiro sinalizado i64: 64-bit; inteiro sinalizado double: 64-bit; ponto-flutuante string: string UTF-8 binary: sequ\u00eancia de bytes Estruturas 1 2 3 4 5 6 struct Example { 1 : i32 number , 2 : i64 bigNumber , 3 : double decimals , 4 : string name = \"thrifty\" } Servi\u00e7os 1 2 3 4 5 service ChaveValor { void set ( 1 : i32 key , 2 : string value ), string get ( 1 : i32 key ) throws ( 1 : KeyNotFound knf ), void delete ( 1 : i32 key ) } N\u00e3o se pode retornar NULL!!! Exce\u00e7\u00f5es 1 2 3 4 exception KeyNotFound { 1 : i64 hora r , 2 : string chaveProcurada = \"thrifty\" } Containers List Map Set Exemplo: chavevalor.thrift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 namespace java chavevalor namespace py chavevalor exception KeyNotFound { } service ChaveValor { string getKV ( 1 : i32 key ) throws ( 1 : KeyNotFound knf ), bool setKV ( 1 : i32 key , 2 : string value ), void delKV ( 1 : i32 key ) } Compila\u00e7\u00e3o thrift --gen java chavevalor.thrift thrift --gen py chavevalor.thrift ChaveValorHandler.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 namespace java chavevalor namespace py chavevalor exception KeyNotFound { } service ChaveValor { string getKV ( 1 : i32 key ) throws ( 1 : KeyNotFound knf ), bool setKV ( 1 : i32 key , 2 : string value ), void delKV ( 1 : i32 key ) } package chavevalor ; import org.apache.thrift.TException ; import java.util.HashMap ; import chavevalor.* ; public class ChaveValorHandler implements ChaveValor . Iface { private HashMap < Integer , String > kv = new HashMap <> (); @Override public String getKV ( int key ) throws TException { if ( kv . containsKey ( key )) return kv . get ( key ); else throw new KeyNotFound (); } @Override public boolean setKV ( int key , String valor ) throws TException { kv . put ( key , valor ); return true ; } @Override public void delKV ( int key ) throws TException { kv . remove ( key ); } } Arquitetura Runtime library -- componentes podem ser selecionados em tempo de execu\u00e7\u00e3o e implementa\u00e7\u00f5es podem ser trocadas Protocol -- respons\u00e1vel pela serializa\u00e7\u00e3oo dos dados TBinaryProtocol TJSONProtocol TDebugProtocol ... Transport -- I/O no ``fio'' TSocket TFramedTransport (non-blocking server) TFileTransport TMemoryTransport Processor -- Conecta protocolos de entrada e sa\u00edda com o \\emph{handler} Handler -- Implementa\u00e7\u00e3o das opera\u00e7\u00f5es oferecidas Server -- Escuta portas e repassa dados (protocolo) para o processors TSimpleServer TThreadPool TNonBlockingChannel Classpath 1 2 3 javac -cp jars/libthrift0.9.3.jar:jars/slf4japi1.7.21.jar:gen-java -d . *.java java -cp jars/libthrift0.9.3.jar:jars/slf4japi1.7.21.jar:gen-java:. chavevalor.ChaveValorServer java -cp jars/libthrift0.9.3.jar:jars/slf4japi1.7.21.jar:gen-java:. chavevalor.ChaveValorClient Refer\u00eancias Tutorial Estudo de Caso RPC: RMI TODO Como usar RMI. Comunica\u00e7\u00e3o orientada a Mensagens TODO MOM Enterprise Message Bus To Message Bus or Not: distributed system design O foco aqui \u00e9 na descri\u00e7\u00e3o da tecnologia, mas n\u00e3o das arquiteturas resultantes, que ser\u00e3o vistas no cap\u00edtulo seguinte. Publish/Subscribe TODO Descrever pub/sub e diferenciar de MOM O foco aqui \u00e9 na descri\u00e7\u00e3o da tecnologia, mas n\u00e3o das arquiteturas resultantes, que ser\u00e3o vistas no cap\u00edtulo seguinte. Implementing RPC \u21a9 Omitirei alguns detalhes aqui, em nome da generalidade, mas voc\u00eas podem recuper\u00e1-los em seus livros de Arquitetura de Computadores. \u21a9 O stub do servidor tamb\u00e9m \u00e9 conhecido como skeleton . \u21a9 Marshalling: representar par\u00e2metros de forma pr\u00f3pria para transmiss\u00e3o \"no fio\". \u21a9","title":"Comunica\u00e7\u00e3o"},{"location":"teaching/gbc074gsi028/comm/#communicacao","text":"O desenvolvimento de sistemas distribu\u00eddos usando diretamente Sockets como forma de comunica\u00e7\u00e3o entre componentes n\u00e3o \u00e9 para os fracos de cora\u00e7\u00e3o. Sua grande vantagem est\u00e1 no acesso baixo n\u00edvel \u00e0 rede , e todo o ganho de desempenho que isso pode trazer. Suas desvantagens, entretanto, s\u00e3o v\u00e1rias: interface de \"arquivo\" para se ler e escrever bytes; controle de fluxo de \"objetos\" \u00e9 por conta da aplica\u00e7\u00e3o, isto \u00e9, a aplica\u00e7\u00e3o precisa sinalizar quantos bytes ser\u00e3o escritos de um lado, para que o outro saiba quanto ler para obter um \"objeto\" correto; logo, a serializa\u00e7\u00e3o e desserializa\u00e7\u00e3o de objetos \u00e9 tamb\u00e9m por conta da aplica\u00e7\u00e3o; tratamento de desconex\u00f5es e eventuais reconex\u00f5es tamb\u00e9m \u00e9 gerenciado pela aplica\u00e7\u00e3o e nem a t\u00e3o famosa confiabilidade do TCP ajuda. Enquanto se poderia argumentar que algumas destas desvantagens podem ser descartadas em fun\u00e7\u00e3o da discuss\u00e3o de incluir ou n\u00e3o API na comunica\u00e7\u00e3o fim-a-fim , \u00e9 certo que algumas funcionalidades s\u00e3o ub\u00edquas em aplica\u00e7\u00f5es distribu\u00eddas. Aqui discutiremos algumas destas funcionalidades e como podem e s\u00e3o implementadas por frameworks de comunica\u00e7\u00e3o de mais alto n\u00edvel.","title":"Communica\u00e7\u00e3o"},{"location":"teaching/gbc074gsi028/comm/#representacao-de-dados","text":"Exceto por aplica\u00e7\u00f5es muito simples, processos em um sistema distribu\u00eddos trocam dados complexos, por exemplo estruturas ou classes com diversos campos, incluindo valores num\u00e9ricos de diversos tipos, strings e vetores de bytes, com diversos n\u00edveis de aninhamento e somando v\u00e1rios KB. Neste cen\u00e1rio, v\u00e1rios fatores precisam ser levados em considera\u00e7\u00e3o na hora de colocar esta estrutura no fio , por exemplo: Diferentes linguagens de programa\u00e7\u00e3o usadas para desenvolver os componentes. tipos com defini\u00e7\u00e3o imprecisa, por exemplo \"inteiro\": 8: 16, 32, 64 ou bits? paradigmas distintos: classe x estrutura conjunto de caracteres diferentes: ASCII x UTF Arquiteturas diferentes. ordem dos bytes little endian? x64 IA-32 big endian? IP SPARC (< V9) Motorola PowerPC bi-endian? ARM, MIPS, IA-64 representa\u00e7\u00e3o de ponto flutuante alinhamento de bytes Sistemas operacionais diferentes crlf (DOS) x lf (Unix) fragmenta\u00e7\u00e3o","title":"Representa\u00e7\u00e3o de dados"},{"location":"teaching/gbc074gsi028/comm/#representacao-textual","text":"Uma abordagem comumente usada \u00e9 a representa\u00e7\u00e3o em formato textual \"amig\u00e1vel a humanos\". Veja o exemplo de como o protocolo HTTP requisita e recebe uma p\u00e1gina HTML. 1 2 3 4 5 6 telnet www.google.com 80 Trying 187.72.192.217... Connected to www.google.com. Escape character is '^]'. GET / HTTP/1.1 host: www.google.com As linhas 5 e 6 s\u00e3o entradas pelo cliente para requisitar a p\u00e1gina raiz do s\u00edtio www.google.com . A linha 7, vazia, indica ao servidor que a requisi\u00e7\u00e3o est\u00e1 terminada. Em resposta a esta requisi\u00e7\u00e3o, o servidor envia o seguinte, em que as primeiras linhas trazem metadados da p\u00e1gina requisitada e, ap\u00f3s a linha em branco, vem a resposta em HTML \u00e0 requisi\u00e7\u00e3o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 HTTP/1.1 302 Found Location: http://www.google.com.br/?gws_rd=cr & ei=HTDqWJ3BDYe-wATs_a3ACA Cache-Control: private Content-Type: text/html; charset=UTF-8 P3P: CP=\"This is not a P3P policy! See https://www.google.com/support/accounts/answer/151657?hl=en for more info.\" Date: Sun, 09 Apr 2017 12:59:09 GMT Server: gws Content-Length: 262 X-XSS-Protection: 1; mode=block X-Frame-Options: SAMEORIGIN Set-Cookie: NID=100=NB_AruuFWL0hXk2-h7VDduHO_UkjAr6RaqgG7VbccTsfLzFfhxEKx21Xpa2EH7IgshgczE9vU4W1TyKsa07wQeuZosl5DbyZluR1ViDRf0C-5lRpd9cCpCD5JXXjy-UE; expires=Mon, 09-Oct-2017 12:59:09 GMT; path=/; domain=.google.com; HttpOnly < HTML >< HEAD >< meta http-equiv = \"content-type\" content = \"text/html;charset=utf-8\" > < TITLE > 302 Moved </ TITLE ></ HEAD >< BODY > < H1 > 302 Moved </ H1 > The document has moved < A HREF = \"http://www.google.com.br/?gws_rd=cr&amp;ei=HTDqWJ3BDYe-wATs_a3ACA\" > here </ A > . </ BODY ></ HTML > Representa\u00e7\u00f5es textuais s\u00e3o usadas em diversos protocolos como SMTP, POP, e telnet. Algumas destas representa\u00e7\u00f5es seguem padr\u00f5es formalizados, o que facilita a gera\u00e7\u00e3o e interpreta\u00e7\u00e3o dos dados. Dois padr\u00f5es bem conhecidas s\u00e3o XML e JSON. XML \u00e9 o acr\u00f4nimo para Extensible Markup Language , ou seja, uma linguagem marca\u00e7\u00e3o que pode ser estendida para representar diferentes tipos de informa\u00e7\u00e3o. A HTML, por exemplo, \u00e9 uma inst\u00e2ncia de XML destinada \u00e0 representa\u00e7\u00e3o de hipertexto (A bem da verdade, XML foi uma generaliza\u00e7\u00e3o de HTML). Por exemplo, para representarmos os dados relativos \u00e0 uma pessoa, podemos ter uma inst\u00e2ncia XML assim: 1 2 3 4 5 6 7 8 9 <person> <name> John Doe </name> <id> 112234556 </id> <email> jdoe@example.com </email> <telephones> <telephone type= \"mobile\" > 123 321 123 </telephone> <telephone type= \"home\" > 321 123 321 </telephone> </telephones> </person> Uma das grandes vantagens do uso de XML \u00e9 a possibilidade de se formalizar o que pode ou n\u00e3o estar em um arquivo para um certo dom\u00ednio utilizando um XML Domain Object Model . H\u00e1, por exemplo, modelos para representa\u00e7\u00e3o de documentos de texto, governos eletr\u00f4nicos, representa\u00e7\u00e3o de conhecimento, etc . Sua maior desvantagem \u00e9 que \u00e9 muito verborr\u00e1gico e por vezes complicado de se usar, abrindo alas para o seu mais famoso concorrente, JSON. JSON \u00e9 o acr\u00f4nimo de Javascript Object Notation , isto \u00e9, o formato para representa\u00e7\u00e3o de objetos da linguagem Javascript. Devido \u00e0 sua simplicidade e versatilidade, entretanto, foi adotado como forma de representa\u00e7\u00e3o de dados em sistemas desenvolvidos nas mais diferentes linguagens. O mesmo exemplo visto anteriormente, em XML, \u00e9 representado em JSON assim: 1 2 3 4 5 6 7 8 9 { \"name\" : \"John Doe\" , \"id\" : 112234556 , \"email\" : \"jdoe@example.com\" , \"telephones\" : [ { \"type\" : \"mobile\" , \"number\" : \"123 321 123\" }, { \"type\" : \"home\" , \"number\" : \"321 123 321\" }, ] } Em Python, por exemplo, JSON s\u00e3o gerados e interpretados nativamente, sem a necessidade de frameworks externos, facilitando seu uso. Mas de fato, a op\u00e7\u00e3o final por XML ou JSON \u00e9 quest\u00e3o de prefer\u00eancia, uma vez que os dois formatos s\u00e3o, de fato, equivalentes na quest\u00e3o da representa\u00e7\u00e3o de informa\u00e7\u00e3o. Outros formatos, bin\u00e1rios, oferecem vantagens no uso de espa\u00e7o para armazenar e transmitir dados, e por isso s\u00e3o frequentemente usados como forma de serializa\u00e7\u00e3o de dados em sistemas distribu\u00eddos, isto \u00e9, na transforma\u00e7\u00e3o de TAD para sequ\u00eancias de bytes que seguir\u00e3o \"no fio\". ASN.1 (Abstract Syntax Notation), pela ISO XDR (eXternal Data Representation) Java serialization Google Protocol Buffers Thrift ASN.1 e XDR s\u00e3o de interesse hist\u00f3rico, mas n\u00e3o os discutiremos aqui. Quanto \u00e0 serializa\u00e7\u00e3o feita nativamente pelo Java, por meio de ObjectOutputStreams , como neste exemplo , embora seja tentadora para quem usa Java, \u00e9 necess\u00e1rio saber que ela \u00e9 restrita \u00e0 JVM e que usa muito espa\u00e7o, embora minimize riscos de uma desserializa\u00e7\u00e3o para uma classe diferente. Nos foquemos nas autras alternativas listadas, ProtoBuffers e Thrift, que podem levar a representa\u00e7\u00f5es bin\u00e1rias e textuais.","title":"Representa\u00e7\u00e3o Textual"},{"location":"teaching/gbc074gsi028/comm/#protobuffers","text":"Nas palavras dos criadores , Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data. Por meio de protobuffers, \u00e9 poss\u00edvel estruturar dados e gerar o c\u00f3digo correspondente em diversas linguagens, for forma compartilh\u00e1vel entre as mesmas. Veja o exemplo a seguir, que especifica os dados referentes a uma pessoa. Observe a presen\u00e7a de campos de preenchimento opcional ( optional ), de enumera\u00e7\u00f5es ( enum ), e de cole\u00e7\u00f5es ( repeated ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 message Person { required string name = 1 ; required int32 id = 2 ; optional string email = 3 ; enum PhoneType { MOBILE = 0 ; HOME = 1 ; WORK = 2 ; } message PhoneNumber { required string number = 1 ; optional PhoneType type = 2 [ default = HOME ]; } repeated PhoneNumber phone = 4 ; } Com tal defini\u00e7\u00e3o \u00e9 poss\u00edvel gerar c\u00f3digo como o seguinte, em C++, que serializa os dados para escrita em um arquivo... 1 2 3 4 5 6 Person person ; person . set_name ( \"John Doe\" ); person . set_id ( 1234 ); person . set_email ( \"jdoe@example.com\" ); fstream output ( \"myfile\" , ios :: out | ios :: binary ); person . SerializeToOstream ( & output ); e l\u00ea do arquivo e desserializa para hidratar um novo objeto. 1 2 3 4 5 fstream input ( \"myfile\" , ios :: in | ios :: binary ); Person person ; person . ParseFromIstream ( & input ); cout << \"Name: \" << person . name () << endl ; cout << \"E-mail: \" << person . email () << endl ; De acordo com benchmarks do pr\u00f3prio projeto , a opera\u00e7\u00e3o em XML seria mais ordens de grandeza mais lenta e ocuparia mais espa\u00e7o. When this message is encoded to the protocol buffer binary format, it would probably be 28 bytes long and take around 100-200 nanoseconds to parse. The XML version is at least 69 bytes if you remove whitespace, and would take around 5,000-10,000 nanoseconds to parse.","title":"ProtoBuffers"},{"location":"teaching/gbc074gsi028/comm/#thrift","text":"TODO Thrift como forma de representa\u00e7\u00e3o de dados.","title":"Thrift"},{"location":"teaching/gbc074gsi028/comm/#invocacao-remota-de-procedimentos-rpc","text":"Em 1984, Birrel e Nelson 1 introduziram o mecanismo de Invoca\u00e7\u00e3o Remota de Procedimentos ( Remote Procedure Calls ), que permite que processos fa\u00e7am, pasmem, invoca\u00e7\u00f5es de procedimentos remotos! \u00d3bvio, a inova\u00e7\u00e3o n\u00e3o est\u00e1 na capacidade de uma m\u00e1quina conversar com outra, mas em como esta conversa acontece, do ponto de vista do programador. Por exemplo, RPC permita que se procure a substring \"teste\" dentro da string apontada por a , a partir da posi\u00e7\u00e3o 3, usando x = substring(a,3,\"teste\"); , mas com o invocador da fun\u00e7\u00e3o em um processo e a implementa\u00e7\u00e3o da fun\u00e7\u00e3o propriamente dita, em outro, possivelmente em outra m\u00e1quina.","title":"Invoca\u00e7\u00e3o Remota de Procedimentos - RPC"},{"location":"teaching/gbc074gsi028/comm/#stubs","text":"Antes de nos aprofundarmos, vejamos como uma invoca\u00e7\u00e3o de fun\u00e7\u00f5es acontece normalmente dentro de um \u00fanico processo 2 . O c\u00f3digo x = substring(a,3,\"teste\"); , que procura \"teste\" em *a , \u00e9 traduzido nos seguintes passos em linguagem de m\u00e1quina: coloque o endere\u00e7o de \"teste\" na pilha coloque 3 na pilha coloque o valor de a na pilha coloque o endere\u00e7o de retorno na pilha (junto com outros dados de controle) salte para substring ajustando o instruction pointer ... procure substring ... coloque o resultado no acumulador limpe a pilha salte de volta recuperando o endere\u00e7o de retorno da pilha e ajustando o IP coloque resultado em x Se o que queremos \u00e9 colocar o c\u00f3digo da fun\u00e7\u00e3o substring em um outro processo e execut\u00e1-lo como se estiv\u00e9ssemos no mesmo processo que faz a invoca\u00e7\u00e3o, precisamos pensar em v\u00e1rias quest\u00f5es relativas ao fluxo mostrado acima. Claramente n\u00e3o podemos usar o mesmo fluxo para invocar uma fun\u00e7\u00e3o, mas precisamos de c\u00f3digo de simule a invoca\u00e7\u00e3o local mas que, por baixo do cap\u00f4, use sockets para se comunicar com o processo remoto. Estq simula\u00e7\u00e3o usar\u00e1 c\u00f3digo extra, que finge implementar substring para o invocador mas delega ao c\u00f3digo remoto o trabalho real da busca. Este c\u00f3digo extra \u00e9 conhecido como stub , ou para ser mais preciso, stub cliente , que faz parte do processo invocando a opera\u00e7\u00e3o, e stub servidor, que faz parte do processo executando a opera\u00e7\u00e3o invocada 3 . Assim, o cliente invoca fun\u00e7\u00e3o no stub cliente, achando que \u00e9 a fun\u00e7\u00e3o que quer executar. Stub cliente faz o marshaling 4 dos par\u00e2metros e usa o SO para transferir os dados via rede para o stub servidor. Quando recebe a resposta do servidor, o stub cliente retorna a mesma resposta, como se tivesse calculado localmente. Stub cliente Implementa uma fun\u00e7\u00e3o substring(char*, int, char*) que abre socket para servidor envia par\u00e2metros especifica fun\u00e7\u00e3o espera resposta retorna resultado J\u00e1 o stub servidor fica esperando o contato do cliente. Quando acontece, faz o \"unmarshalling\" dos dados, invoca a fun\u00e7\u00e3o localmente na aplica\u00e7\u00e3o servidor e pega o resultado, que retona ao cliente. Stub servidor espera conex\u00e3o recebe par\u00e2metros recebe especifica\u00e7\u00e3o da fun\u00e7\u00e3o invoca fun\u00e7\u00e3o localmente envia resultado para cliente","title":"Stubs"},{"location":"teaching/gbc074gsi028/comm/#transparencia","text":"\u00c9 para o programador a grande vantagem do uso de RPC, pois se pode escrever c\u00f3digo distribu\u00eddo \"igual\" ao centralizado, certo? Isto \u00e9, interface baseada em procedimentos e sem a necessidade de detalhar portas, sockets, e representa\u00e7\u00e3o de dados . Ou seja, tudo \u00e9 transparente! Como j\u00e1 discutimos, v\u00e1rios fatores trabalham contra a transpar\u00eancia em sistemas distribu\u00eddos . Em espec\u00edfico quanto \u00e0 transpar\u00eancia dada pelo RPC, tamb\u00e9m temos limita\u00e7\u00f5es. O problema \u00e9 que h\u00e1 uma distin\u00e7\u00e3o clara em pelo menos dois processos e se pensarmos no c\u00f3digo descrito acima, temos que entender que processos independentes n\u00e3o compartilham um espa\u00e7o de endere\u00e7amento, e processos independentes n\u00e3o compartilham uma pilha. Assim, como fica a passagem de par\u00e2metro por refer\u00eancia , uma vez que o stub servidor n\u00e3o pode usar endere\u00e7os do espa\u00e7o de endere\u00e7amento do cliente? Algumas abordagens para simular a passagem por refer\u00eancia s\u00e3o poss\u00edveis. Por exemplo, o valor apontado pelo ponteiro \u00e9 passado para o servidor , que armazena o valor e alguma posi\u00e7\u00e3o de mem\u00f3ria e passa o endere\u00e7o de tal posi\u00e7\u00e3o para a fun\u00e7\u00e3o invocada. Contudo, a modifica\u00e7\u00e3o do valor pela fun\u00e7\u00e3o n\u00e3o reflete imediatamente no invocador; tais valores tem que ser copiados novamente e usados para sobrescrever o valor original no cliente. Al\u00e9m disso, esta abordagem s\u00f3 \u00e9 poss\u00edvel se o valor apontado for delimitado, o que nem sempre \u00e9 f\u00e1cil de determinar. Por exemplo, se o ponteiro for para o primeiro elemento de uma lista, o que deve ser copiado para o servidor? S\u00f3 o primeiro elemento? Toda a lista? Como ensinar para o framework RPC o que \u00e9 \"toda\" a lista? Java \"resolve\" o problema da passagem de par\u00e2metro por refer\u00eancia passando todo o grafo do objeto passado como par\u00e2metro para o servidor. Isto \u00e9, al\u00e9m de serializar o objeto apontado no par\u00e2metro, se o mesmo aponta para outros objetos, estes tamb\u00e9m ser\u00e3o serializados e transferidos; o servidor ir\u00e1 ent\u00e3o reconstruir todo o grafo e passar para o m\u00e9todo sendo invocado. \u00c9 muito f\u00e1cil ver que esta abordagem pode se tornar invi\u00e1vel rapidamente. Quando for o caso, Java permite marcar objetos como remotos e, em vez de serializar este objeto e enviar para o servidor, envia informa\u00e7\u00e3o suficiente para que o servidor possa invocar m\u00e9todos em tal objeto no cliente, tornando nebulosa a defini\u00e7\u00e3o de quem \u00e9 quem. Outros fatores tamb\u00e9m trabalham contra a transpar\u00eancia para o desenvolvedor. Vejamos alguns","title":"Transpar\u00eancia"},{"location":"teaching/gbc074gsi028/comm/#frameworks","text":"H\u00e1 diversas op\u00e7\u00f5e de frameworks para RPC, com diferentes caracter\u00edsticas, focos, e garantias. Alguns s\u00e3o parte da linguagem e outros s\u00e3o implementados como bibliotecas. Alguns suportam m\u00faltiplas linguagens e alguns apenas uma. Suporte a RPC na linguagem Sem RPC: C, C++, Java < 5.0 (1.5), Python Com RPC: Java, Go, Erlang, Scala, Haskell Ambientes heterog\u00eaneos: Thrift, gRPC, Akka, SOAP Frameworks mais modernos permitem escolher a forma de serializa\u00e7\u00e3o dos dados, se leg\u00edvel para humanos ou bin\u00e1rio, se o transporte \u00e9 via HTTP ou protocolo mais baixo n\u00edvel, se os dados trafegam abertamente ou se faz uso de comunica\u00e7\u00e3o criptografada (SSL). Outros permitem escolher sem\u00e2ntica de execu\u00e7\u00e3o entre no m\u00e1ximo uma e pelo menos uma , e h\u00e1 at\u00e9 quem prometa exatamente uma . Mas todos os frameworks tem algumas caracter\u00edsticas em comum e uma delas \u00e9 o uso de uma Linguagem de Defini\u00e7\u00e3o de Interface (IDL).","title":"Frameworks"},{"location":"teaching/gbc074gsi028/comm/#estudo-de-caso-rpc-grpc","text":"gRPC \u00e9 um framework para invoca\u00e7\u00e3o remota de procedimentos multi-linguagem e sistema operacional, usando internamente pelo Google h\u00e1 v\u00e1rios anos para implementar sua arquitetura de micro-servi\u00e7os. Inicialmente desenvolvido pelo Google, o gRPC \u00e9 hoje de c\u00f3digo livre encubado pela Cloud Native Computing Foundation. O s\u00edtio gRPC.io documenta muito bem o gRPC, inclusive os princ\u00edpios que nortearam seu projeto. O seu uso segue, em linhas gerais, o modelo discutido nas se\u00e7\u00f5es anteriores, isto \u00e9, inicia-se pela defini\u00e7\u00e3o de estruturas de dados e servi\u00e7os, \"compila-se\" a defini\u00e7\u00e3o para gerar stubs na linguagem desejada, e compila-se os stubs juntamente com os c\u00f3digos cliente e servidor para gerar os bin\u00e1rios correspondentes. Vejamos a seguir um tutorial passo a passo, em Java, baseado no quickstart guide .","title":"Estudo de Caso RPC: gRPC"},{"location":"teaching/gbc074gsi028/comm/#estudo-de-caso-rpc-thrift","text":"Thrift","title":"Estudo de Caso RPC: Thrift"},{"location":"teaching/gbc074gsi028/comm/#estudo-de-caso-rpc-rmi","text":"TODO Como usar RMI.","title":"Estudo de Caso RPC: RMI"},{"location":"teaching/gbc074gsi028/comm/#comunicacao-orientada-a-mensagens","text":"TODO MOM Enterprise Message Bus To Message Bus or Not: distributed system design O foco aqui \u00e9 na descri\u00e7\u00e3o da tecnologia, mas n\u00e3o das arquiteturas resultantes, que ser\u00e3o vistas no cap\u00edtulo seguinte.","title":"Comunica\u00e7\u00e3o orientada a Mensagens"},{"location":"teaching/gbc074gsi028/comm/#publishsubscribe","text":"TODO Descrever pub/sub e diferenciar de MOM O foco aqui \u00e9 na descri\u00e7\u00e3o da tecnologia, mas n\u00e3o das arquiteturas resultantes, que ser\u00e3o vistas no cap\u00edtulo seguinte. Implementing RPC \u21a9 Omitirei alguns detalhes aqui, em nome da generalidade, mas voc\u00eas podem recuper\u00e1-los em seus livros de Arquitetura de Computadores. \u21a9 O stub do servidor tamb\u00e9m \u00e9 conhecido como skeleton . \u21a9 Marshalling: representar par\u00e2metros de forma pr\u00f3pria para transmiss\u00e3o \"no fio\". \u21a9","title":"Publish/Subscribe"},{"location":"teaching/gbc074gsi028/coord/","text":"Coordena\u00e7\u00e3o Como visto na se\u00e7\u00e3o sobre Multiprograma\u00e7\u00e3o , diversas tarefas exigem coordena\u00e7\u00e3o entre threads em uma aplica\u00e7\u00e3o centralizada em que se faz uso de concorr\u00eancia para melhor uso de recursos computacionais, obten\u00e7\u00e3o de melhor desempenho, e modulariza\u00e7\u00e3o do c\u00f3digo. Sistemas distribu\u00eddos levam concorr\u00eancia a um novo patamar de complexidade, fazendo uso de m\u00faltiplos processos, cada um com possivelmente m\u00faltiplos threads , ainda por cima, espalhados geograficamente. Outras solu\u00e7\u00f5es e abstra\u00e7\u00f5es s\u00e3o portanto necess\u00e1rias. Exclus\u00e3o M\u00fatua Um dos problemas enfrentados em sistemas que fazem uso de concorr\u00eancia, distribu\u00eddos ou n\u00e3o, \u00e9 a exclus\u00e3o m\u00fatua. Em um sistema centralizado, uma vari\u00e1vel global, um lock, ou outra primitiva de sincroniza\u00e7\u00e3o podem ser usadas na sincroniza\u00e7\u00e3o, mas em um sistema distribu\u00eddo, primitivas simples como estas provavelmente n\u00e3o estar\u00e3o dispon\u00edveis ou o sistema ser\u00e1 muito restrito. Como, ent\u00e3o, controlar o acesso de m\u00faltiplos processos a um recurso compartilhado, garantindo que cada processo controla exclusivamente aquele recurso durante seu acesso? Qualquer solu\u00e7\u00e3o que se proponha a este problema de exclus\u00e3o m\u00fatua, precisa ter as propriedades 1, 2, 3, e, idealmente, a 4, a seguir: Exclus\u00e3o M\u00fatua exclus\u00e3o m\u00fatua - somente um processo pode estar na regi\u00e3o cr\u00edtica em qualquer instante de tempo; aus\u00eancia de deadlocks - se processos est\u00e3o tentando acessar o recurso, ent\u00e3o algum processo deve conseguir acesso em algum instante, dado que nenhum processo fique na regi\u00e3o cr\u00edtica indefinidamente; n\u00e3o-inani\u00e7\u00e3o - todos os processos interessados conseguem, em algum momento, acessar o recurso; espera limitada - idealmente, o tempo de espera pelo recurso \u00e9 limitado. H\u00e1 diversas solu\u00e7\u00f5es para exclus\u00e3o m\u00fatua em sistemas distribu\u00eddos, em diversos cen\u00e1rios, com seus pr\u00f3s e contras. Tr\u00eas das mais simples, e que ilustram o universo de solu\u00e7\u00f5es s\u00e3o via um processo centralizador, em um anel em que a vez \u00e9 circulada, e baseada em quoruns. Coordenador Enquanto em um sistema centralizado h\u00e1 um sistema operacional que prov\u00ea abstra\u00e7\u00f5es simples para os processos a serem coordenados, em um sistema distribu\u00eddo, n\u00e3o h\u00e1 naturalmente tal entidade. Uma poss\u00edvel solu\u00e7\u00e3o para o problem de exclus\u00e3o m\u00fatua em um ambiente distribu\u00eddo \u00e9 justamente dar um passo para tr\u00e1s e introduzir um coordenador. Nesta abordagem, os processos que precisam acessar a regi\u00e3o cr\u00edtica s\u00e3o denominados participantes e um dos processos assume o pal de coordenador . \u00c9 poss\u00edvel que um mesmo processo atue nos dois pap\u00e9is sem nenhum preju\u00edzo. Os processos executam o seguinte protocolo: Participante Envia requisi\u00e7\u00e3o de acesso ao coordenador Espera por resposta do coordenador Acessa o recurso Envia libera\u00e7\u00e3o do recurso para o coordenador Coordenador Inicializa recurso como livre Ao receber uma requisi\u00e7\u00e3o, a enfileira Ao receber uma libera\u00e7\u00e3o, marca o recurso como livre Sempre que recurso estiver marcado como livre E a fila n\u00e3o estiver vazia remove primeiro processo da fila envia libera\u00e7\u00e3o para processo removido marca o recurso como ocupado O diagrama a seguir apresenta uma execu\u00e7\u00e3o deste protocolo em um cen\u00e1rio com tr\u00eas participantes. O estado do coordenador mostra se o recurso est\u00e1 livre ou ocupado e quais processos esperam por permiss\u00e3o de acesso. sequenceDiagram participant Coordenador note over Coordenador: Recurso=livre/Fila = [] Part1->>Coordenador: RequestAccess note over Coordenador: Recurso=livre/Fila = [Part1] Coordenador->>Part1: ResponseOK note over Coordenador: Recurso=ocupado/Fila = [] Part2->>Coordenador: RequestAccess note over Coordenador: Recurso=ocupado/Fila = [Part2] Part1->>Coordenador: RequestFree note over Coordenador: Recurso=livre/Fila = [Part2] Coordenador->>Part1: ResponseFree Part3->>Coordenador: RequestAccess note over Coordenador: Recurso=livre/Fila = [Part2,Part3] Coordenador->>Part2: ResponseOK note over Coordenador: Recurso=ocupado/Fila = [Part3] Part2->>Coordenador: RequestFree note over Coordenador: Recurso=livre/Fila = [Part3] Coordenador->>Part2: ResponseFree note over Coordenador: Recurso=ocupado/Fila = [] Coordenador->>Part3: ResponseOK Part3->>Coordenador: RequestFree note over Coordenador: Recurso=livre/Fila = [] Coordenador->>Part3: ResponseFree Este algoritmo satisfaz as caracter\u00edsticas elencadas acima. Exclus\u00e3o m\u00fatua - se o coordenador autoriza um participante X, somente ap\u00f3s o participante X liberar o recurso \u00e9 que outro participante poder\u00e1 obter nova autoriza\u00e7\u00e3o. Aus\u00eancia de deadlocks - Todo processo que requisitar o recurso, entrar\u00e1 em uma fila, em apenas uma posi\u00e7\u00e3o; assim, a fila prover\u00e1 uma ordem total para os acessos, sem a possibilidade de circularidade nesta ordem. N\u00e3o-inani\u00e7\u00e3o - Dado que ningu\u00e9m fura a fila e que a cada vez que o recurso \u00e9 liberado a fila anda, em algum momento a vez do processo chegar\u00e1. Espera limitada - Dado que a posi\u00e7\u00e3o na fila pode apenas decrementar, seria poss\u00edvel estimar quanto tempo o participante precisa esperar para acessar o recurso. Outra vantagem deste algoritmo \u00e9 sua simplicidade e, conseguentemente, facilidade de implementa\u00e7\u00e3o. Contudo, este algoritmo tem tamb\u00e9m desvantagens, por exemplo, se muitas requisi\u00e7\u00f5es de acesso forem feitas, o coordenador pode ser sobrecarregado e se tornar um gargalo no acesso \u00e0 regi\u00e3o cr\u00edtica. Mais s\u00e9rio ainda \u00e9 a quest\u00e3o de como lidar com falhas, por exemplo, se ou o coordenador ou o participante que detem o direito de acesso ao recurso para de funcionar, ent\u00e3o nenhum outro processo conseguir\u00e1 acesso. Estes aspectos nos permitem mergulhar na \u00e1rea de toler\u00e2ncia a falhas, e o faremos, mas mais tarde. Por enquanto, consideraremos toler\u00e2ncia a falhas de forma superficial, ap\u00f3s discutirmos outra abordagem. Anel Nesta abordagem, os processos se organizam em um anel l\u00f3gico, com um processo antes e outro depois. Um dos processos \u00e9 iniciado com um token que d\u00e1 acesso ao recurso e o token \u00e9 passado adiante no anel; sempre que estiver de posse do token, o processo pode acessar o recurso. Ou seja, todos os participantes executam o seguinte protocolo: Participante Ao receber o token de acesso, se quiser acessar o recurso, acessa. Envia o token para o pr\u00f3ximo n\u00f3 do anel. O diagrama adiante mostra uma execu\u00e7\u00e3o do algoritmo em que apenas os participantes 1 e 3 acessam o recurso. sequenceDiagram Part1->>Part2: Permiss\u00e3o de Acesso Part2->>Part3: Permiss\u00e3o de Acesso note over Part3: Acessa o recurso Part3->>Part4: Permiss\u00e3o de Acesso Part4->>Part1: Permiss\u00e3o de Acesso note over Part1: Acessa o recurso Part1->>Part2: Permiss\u00e3o de Acesso Part2->>Part3: Permiss\u00e3o de Acesso note over Part3: Acessa o recurso Part3->>Part4: Permiss\u00e3o de Acesso Part4->>Part1: Permiss\u00e3o de Acesso Como o algoritmo centralizado, o algoritmo do anel tamb\u00e9m garante as propriedades 1, 2, 3 e 4, al\u00e9m de ser f\u00e1cil de implementar, testar e entender. Diferente do algoritmo centralizado, o algoritmo do anel n\u00e3o sofre com problemas de gargalo, pois nenhum processo precisa participar em todos os acessos, como o coordenador. Contudo, o algoritmo do anel desperdi\u00e7a tempo passando o token para quem n\u00e3o necessariamente quer acessar a regi\u00e3o cr\u00edtica. Tamb\u00e9m importante \u00e9 que este algoritmo tamb\u00e9m sofre com falhas: se um participante falha enquanto com o token , levando-o para al\u00e9m. Lidando com Falhas Em ambos os algoritmos, centralizado e do anel, se um processo falhar, o algoritmo pode ficar \"travado\". Vejamos alguns casos espec\u00edficos: No algoritmo centralizado, se o coordenador falha antes de liberar o acesso para algum processo, ele leva consigo a permiss\u00e3o. Em ambos os algoritmos, se o processo acessando o recurso falha, a permiss\u00e3o \u00e9 perdida e os demais processos sofrer\u00e3o inani\u00e7\u00e3o. No algoritmo do anel, se qualquer outro processo falha, o anel \u00e9 interrompido o anel n\u00e3o conseguir\u00e1 circular. Observe que nem falamos de falhas dos canais e j\u00e1 temos diversos cen\u00e1rios a serem resolvidos, para os quais se lhes pedir uma solu\u00e7\u00e3o, tenho certeza absoluta de que me oferecer\u00e3o alguma baseada em timeouts . Por exemplo, se o processo n\u00e3o devolver a permiss\u00e3o de acesso antes de que uma certa quantidade de tempo tenha passado, um timeout , ent\u00e3o assuma que o mesmo parou de funcionar e n\u00e3o voltar\u00e1 mais, e gere uma nova permiss\u00e3o a ser passada a outros requisitantes. O problema desta e outras \"solu\u00e7\u00f5es\" baseadas em timeouts est\u00e1 no assumir que o processo parou de funcionar , pois caso isso n\u00e3o seja verdade, teremos agora dois tokens no sistema, podendo levar \u00e0 viola\u00e7\u00e3o da propriedade de exclus\u00e3o m\u00fatua. Viola\u00e7\u00e3o da exclus\u00e3o m\u00fatua Fazer diagrama de sequ\u00eancia mostrando viola\u00e7\u00e3o da exclus\u00e3o m\u00fatua. Por mais que se ajuste o valor do temporizador, em um sistema distribu\u00eddo ass\u00edncrono, mesmo que aumentado com um rel\u00f3gio para medir a passagem do tempo local, o mesmo pode sempre estar errado. Impossibilidade de detec\u00e7\u00e3o de falhas Em um sistema distribu\u00eddo ass\u00edncrono, \u00e9 imposs\u00edvel distinguir um processo falho de um processo lento. Mais tarde discutiremos as implica\u00e7\u00f5es desta impossibilidade. Por agora, tentemos responder \u00e0 seguinte quest\u00e3o. Question Qual deve ser um timeout razo\u00e1vel para o meu sistema? A resposta depende de mais perguntas, como: Qual o custo E E de esperar por mais tempo? Qual o custo C C de cometer um engano? Qual a probabilidade p p de cometer um engano? O custo esperado por causa dos erros, isto \u00e9, a esperan\u00e7a matem\u00e1tica da vari\u00e1vel aleat\u00f3ria custo, \u00e9 menor que o custo de se esperar por mais tempo, isto \u00e9, C * p < E C * p < E ? Embora esta an\u00e1lise possa ser feita para estes algoritmos, a verdade \u00e9 que s\u00e3o realmente limitados e outras abordagens seriam melhor destino dos seus esfor\u00e7os. Por exemplo, podemos partir para a an\u00e1lise de algoritmos probabil\u00edsticos, pois afinal, como disse certa vez Werner Fogels, CTO da Amazon Se o mundo \u00e9 probabil\u00edstico, porqu\u00ea meus algoritmos devem ser determin\u00edsticos?\" Uma abordagem probabil\u00edstica interessante \u00e9 baseada em qu\u00f3runs. Qu\u00f3rum De acordo com o Dicion\u00e1rio Priberam da L\u00edngua Portuguesa, consultado em 17-04-2019 , \"qu\u00f3rum\" \u00e9 o N\u00famero de pessoas imprescind\u00edvel para a realiza\u00e7\u00e3o de algo. Aqui, este este algo ser\u00e1 a libera\u00e7\u00e3o de acesso ao recurso almejado pelos processos no sistema distribu\u00eddo. Esta abordagem \u00e9 semelhante em v\u00e1rios aspectos \u00e0 coordenada. De fato, um dos pap\u00e9is na abordagem \u00e9 o de coordenador, que executa o mesmo protocolo que antes. Entretanto, em vez de apenas um coordenador no sistema, temos n n , dos quais o participante precisa obter m > n/2 m > n/2 autoriza\u00e7\u00f5es antes de acessar o recurso; m m \u00e9 o qu\u00f3rum do sistema. Qu\u00f3rum n n coordenadores. m > n/2 m > n/2 coordenadores J\u00e1 os demais participantes devem agora considerar todo o conjunto de coordenadores antes de assumir que tem acesso a um recurso. O algoritmo completo \u00e9 o seguinte: Coordenador Inicializa recurso como livre Ao receber uma requisi\u00e7\u00e3o, a enfileira Ao receber uma libera\u00e7\u00e3o, marca o recurso como livre Sempre que recurso estiver marcado como livre E a fila n\u00e3o estiver vazia remove primeiro processo da fila envia libera\u00e7\u00e3o para processo removido marca o recurso como ocupado Participante Envia requisi\u00e7\u00e3o de acesso aos n n coordenadores Espera por resposta de m m coordenadores Acessa o recurso Envia libera\u00e7\u00e3o do recurso para o coordenador Al\u00e9m disso, para tornamos o problema mais interessante e demonstrar o potencial deste algoritmo, consideremos que as autoriza\u00e7\u00f5es s\u00e3o armazenadas somente em mem\u00f3ria, e que coordenadores, ao falhar e ent\u00e3o resumir suas atividades, esqueceme das autoriza\u00e7\u00f5es j\u00e1 atribu\u00eddas. Perda de mem\u00f3ria Quando um coordenador falha, esquece que deu ok e reinicia seu estado. Vejamos uma execu\u00e7\u00e3o bem sucedida destes algoritmo: TODO Construir execu\u00e7\u00e3o bem sucedida. Este algoritmo \u00e9 bom? Suponhamos o seguinte cen\u00e1rio: Coordenadores = { c_1,c_2,c_3,c_4,c_5,c_6,c_7 c_1,c_2,c_3,c_4,c_5,c_6,c_7 } n = 7 n = 7 m = 4 m = 4 Participante p_1 p_1 consegue autoriza\u00e7\u00e3o de { c_1,c_2,c_3,c_4 c_1,c_2,c_3,c_4 } e entra na regi\u00e3o cr\u00edtica. Coordenador c_4 c_4 falha e se recupera Participante p_2 p_2 consegue autoriza\u00e7\u00e3o de { c_4,c_5,c_6,c_7 c_4,c_5,c_6,c_7 } e entra na regi\u00e3o cr\u00edtica. Neste cen\u00e1rio, a propriedade de Exclus\u00e3o M\u00fatua \u00e9 violada. Isto porqu\u00ea, dados os dois qu\u00f3runs, todos os processos na interse\u00e7\u00e3o foram reinicidaos. Mas de forma geral, qual a probabilidade de isso acontecer? Ou seja, dados dois quoruns, de tamanho m m , que se sobrepoem em k k processos, qual a probabilidade P_v P_v de que os k k processos na interse\u00e7\u00e3o sejam reiniciados e levem \u00e0 viola\u00e7\u00e3o? Seja a P P a probabilidade de um coordenador em espec\u00edfico falhar e se recuperar dentro de uma janela de tempo \\delta t \\delta t . Temos Probabilidade de falha de exatamente 1 coordenador: P^1(1-P)^{n-1} P^1(1-P)^{n-1} Probabilidade de k k coordenadores falharem: P^k(1-P)^{n-k} P^k(1-P)^{n-k} Probabilidade de quaisquer k k em m m coordenadores falharem: \\binom{m}{k} P^k(1-P)^{m-k} \\binom{m}{k} P^k(1-P)^{m-k} Mas qual \u00e9 o tamanho k k da interse\u00e7\u00e3o? \\left| A \\cup B\\right| = \\left| A \\right| + \\left|B\\right| - \\left| A \\cap B \\right| \\Rightarrow n = m + m - k \\left| A \\cup B\\right| = \\left| A \\right| + \\left|B\\right| - \\left| A \\cap B \\right| \\Rightarrow n = m + m - k \\left| A \\cap B \\right| = \\left| A \\right| + \\left|B\\right| - \\left| A \\cup B\\right| \\Rightarrow k = m + m - n = 2m - n \\left| A \\cap B \\right| = \\left| A \\right| + \\left|B\\right| - \\left| A \\cup B\\right| \\Rightarrow k = m + m - n = 2m - n At\u00e9 agora consideramos que a k k corresponde \u00e0 cardinalidade da interse\u00e7\u00e3o dos dois quoruns, mas se mais do que a interse\u00e7\u00e3o forem reiniciados, tamb\u00e9m teremos problemas. Assim, se k k assume qualquer valor entre o tamanho da interse\u00e7\u00e3o e o n\u00famero total de coordenadores, teremos problemas. Probabilidade de quaisquer k k em m m coordenadores falharem, para qualquer k k variando de 2m-n 2m-n a n n : P_v = \\sum_{k=2m-n}^n \\binom{m}{k} P^k(1-P)^{m-k} P_v = \\sum_{k=2m-n}^n \\binom{m}{k} P^k(1-P)^{m-k} Para facilitar o entendimento desta grandeza, considere o exemplo: P=0.0001 P=0.0001 (1 minuto a cada 10 dias) n = 32 n = 32 m = 0.75n m = 0.75n P_v < 10^{-40} P_v < 10^{-40} ( Curiosidade sobre 10^{40} 10^{40} ) A probabilidade de viola\u00e7\u00e3o da exclus\u00e3o m\u00fatua, neste caso, \u00e9 muito pequena, a despeito de suportar falhas dos coordenadores. Pr\u00f3 Tolera falhas de coordenadores, com probabilidade controlada de viola\u00e7\u00e3o de exclus\u00e3o m\u00fatua. Mas e as outras propriedades desej\u00e1veis do algoritmo de exclus\u00e3o m\u00fatua, s\u00e3o alcan\u00e7adas? Relembrando: Contras Exclus\u00e3o M\u00fatua probabil\u00edstica: 1 - P_v 1 - P_v N\u00e3o-inani\u00e7\u00e3o E se cada participante obtiver o ok de um coordenador? Temporizador para quebrar o deadlock ? Espera limitada Aborts podem levar a espera infinita. Assim, este agoritmo tamb\u00e9m pode n\u00e3o ser adequado para certas situa\u00e7\u00f5es. Vamos tentar reacessar os problemas da primeira abordagem. Por um lado, o uso de um l\u00edder para coordenar a\u00e7\u00f5es em um SD simplifica o projeto, mas, por outro, o coordenador pode se tornar um ponto \u00fanico de falha, como no algoritmo de exclus\u00e3o m\u00fatua centralizado. Mas e se substitu\u00edssemos o coordenador no caso de falhas? Este \u00e9 o problema conhecido como elei\u00e7\u00e3o de l\u00edderes. TODO Maekawa - Diminui n\u00famero de votos necess\u00e1rios ( descri\u00e7\u00e3o ) Lamport - Usa rel\u00f3gios l\u00f3gicos, mas \u00e9 poss\u00edvel entender sem este background ( descri\u00e7ao ) Ricart-Agrawala - Melhora algoritmo de Lamport ( descri\u00e7\u00e3o ) Distributed-Mutual-Exclusion-slides Elei\u00e7\u00e3o de L\u00edderes O problema da escolha de um processo centralizador, ou l\u00edder, pode ser posto informalmente como o procedimento pelo qual um processo \u00e9 escolhido dentre os demais processos, sendo que o processo escolhido \u00e9 ciente da escolha e todos os demais processos o identificam como eleito . Uma nova elei\u00e7\u00e3o deve acontecer sempre que o l\u00edder se tornar indispon\u00edvel . Para entendermos melhor o problema, tentemos desenvolver um protocolo simples para escolhermos um l\u00edder, por exemplo, em sua turma da disciplina de Sistemas Distribu\u00eddos. Em primeiro lugar, precisamos definir um conjunto de candidatos: s\u00e3o todos eleg\u00edveis ou apenas um subconjunto se candidata? Todos se conhecem ou h\u00e1 grupos incomunic\u00e1veis diretamente dentro da turma? Mesmo que um colega seja bem conectado na turma, de que adianta ele ser l\u00edder se frequentemente n\u00e3o est\u00e1 presente quando necess\u00e1rio? Em termos computacionais, estas quest\u00f5es s\u00e3o relevantes pois todos os processoes n\u00e3o nascem iguais; alguns residem em m\u00e1quinas com mais mem\u00f3ria, mais poder de processamento, melhor conex\u00e3o com o resto do mundo ou maior grau de conectividade. Talvez este processo seja um l\u00edder mais \u00fatil que os demais. Al\u00e9m disso, se o processo est\u00e1 frequentemente desconectado, mesmo que bem servido de recursos, n\u00e3o ser\u00e1 um bom l\u00edder. Em segundo lugar, ainda que assumamos um conjunto de processos indiferenci\u00e1veis entre si, com acesso equivalente a recursos e que estejam sempre dispon\u00edves, ou exatamente por isso, temos um problem mais fundamental para resolver: para eleger um l\u00edder, precisamos identificar processos, de forma inequ\u00edvoca. Dentro de uma \u00fanica m\u00e1quina, identificamos processos facilmente usando seu pid , ou process id , um inteiro associado a cada processoinstanciado pelo sistema operacional; o pid \u00e9 v\u00e1lido enquanto o processo estiver executando e pode ser reciclado uma vez que o processo para de executar, o que pode ser um problema. Al\u00e9m disso, o host \u00e9 reiniciado, os pid tamb\u00e9m s\u00e3o, e portanto esta identifica\u00e7\u00e3o n\u00e3o \u00e9 duradoura. Mais importante, o pid s\u00f3 faz sentido dentro de uma \u00fanica m\u00e1quina e n\u00e3o em um sistema distribu\u00eddo. Se apenas uma inst\u00e2ncia do processo executa em um mesmo host , ent\u00e3o o identificador do host em si \u00e9 suficiente e, de fato, comumente utilizado. Se mais de um processo executa no mesmo host , ent\u00e3o cabe ao desenvolvedor criar um esquema que permita diferenciar os processos, e n\u00e3o precisa ser nada complicado; pode ser apenas um par\u00e2metro passado na inicializa\u00e7\u00e3o do processo ou a combina\u00e7\u00e3o IP/porta . Assumindo um esquema de nomea\u00e7\u00e3o est\u00e1 dispon\u00edvel e que todos os processos se conhecem, voltemos ao problema de eleger um l\u00edder para sua turma. Uma abordagem que pode funcionar \u00e9 colocar todos os candidatos para brigar e quem sobrar em p\u00e9 no final, \u00e9 o novo l\u00edder. A despeito desta op\u00e7\u00e3o gerar um l\u00edder n\u00e3o muito popular, o algoritmo do brig\u00e3o \u00e9 um cl\u00e1ssico. Algoritmo do Brig\u00e3o ( Bully ) No algoritmo do brig\u00e3o, alguma caracter\u00edsticas compar\u00e1vel dos processos \u00e9 escolhida e aquele processo funcional com o valor de tal caracter\u00edstica mais vantajoso para um l\u00edder \u00e9 escolhido como tal. Por exemplo, pode ser vantajoso ter um l\u00edder com maior quantidade de mem\u00f3ria, frequ\u00eancia da CPU ou largura de banda da conex\u00e3o com a Internet; no caso de empate, o identificador do processo pode ser usado para gerar uma ordem total entre os processos. Para simplificar, vamos assumir que o identificador do processo reflete as qualidades do mesmo para a lideran\u00e7a, tal que o maior identificador seja o melhor candidato. Os maiores processos, os \"brig\u00f5es\", elimina os processos menores da competi\u00e7\u00e3o, sempre que uma elei\u00e7\u00e3o acontecer. O algoritmo, \u00e9 o seguinte, onde p p e q q s\u00e3o usados para representar tanto identificadores de processos quando os processos em si. Algoritmo do Brig\u00e3o Quando p p suspeita que o l\u00edder n\u00e3o est\u00e1 presente p p envia mensagem (ELEICAO, p p ) para todos os processos com identificador maior que p p Se p p n\u00e3o recebe (OK, p p ) de outros processos, envia (COORD, p p ) para todos os processos Se algum responde, aguarda notifica\u00e7\u00e3o do novo l\u00edder Quando p p recebe (ELEICAO, q q ), q < p q < p * Envia (OK, p p ) Se um processo falho se recupera, inicia uma elei\u00e7\u00e3o TODO Explicar passos. Expandir pr\u00f3ximos Algoritmo do Anel Algoritmo do Anel Organize os n\u00f3s em um anel l\u00f3gico Quando p p acha que o l\u00edder est\u00e1 morto: Envia mensagem { p p } para \"a direita\" no anel. Se processo \u00e0 direita est\u00e1 falho, salte-o, e assim por diante. Quando q q recebe { p p } Envia { p,q p,q } para a direita. Quando p p recebe S S tal que q \\in S q \\in S Escolhe menor id em S S , por exemplo, e anuncia como l\u00edder. Algoritmo de Chang & Robert Algoritmo de Chang e Robert Organize os n\u00f3s em um anel l\u00f3gico Quando p p acha que o l\u00edder est\u00e1 morto: Envia mensagem p p para \"a direita\" no anel, saltando falhos. Liga flag \"participante\" Quando q q recebe p p Se p > q p > q , repassa p p para a direita. Sen\u00e3o, envia q q para a direita. Liga flag \"participante\" Quando p p recebe q q da esquerda Se \"participante\" est\u00e1 ligado, identifica q q como l\u00edder. Desliga \"participante\" Se p \\neq q p \\neq q , repassa q q \u00e0 direita Algoritmo do YoYo Fonte Algoritmo do YoYo Grafos incompletos Duas fases Fase 1 p p envia seu identificador para seus vizinhos. Quando q q recebe p p Se p>q p>q , adiciona aresta q\\rightarrow p q\\rightarrow p Sen\u00e3o, adiciona aresta q\\leftarrow p q\\leftarrow p Fonte (source) Vertedouro (sink) Interno Fase 2 Fontes enviam seus identificadores para seus vizinhos. Interno espera msg de todas as arestas de entrada, escolhe o menor id, e repassa para arestas de sa\u00edda. Vertedouro espera msg de todas as arestas de entrada e escolhe o menor id. Vertedouro envia S para vizinhos de onde viu menor valor e N para os demais. Interno repassa S para o vizinho correspondente ao menor id e N para os demais. Fonte espera por todos os votos. Se todos s\u00e3o S, continua; caso contr\u00e1rio, desiste. N inverte a dire\u00e7\u00e3o das arestas em que trafega. Poss\u00edvel otimizar para eliminar n\u00f3s e arestas irrelevantes. Exemplo: a) The network, b) Oriented network after setup phase, c) YO- phase in which source values are passed, d) YO phase sending responses from sinks, e) updated structure after -YO phase. Quest\u00f5es importantes Problemas? Estabilidade? O que acontece se a rede \u00e9 particionada? Split Brain Network Partitioning: rede dividida em duas partes incomunic\u00e1veis. M\u00faltiplas elei\u00e7\u00f5es podem acontecer em paralelo. M\u00faltiplos l\u00edderes em paralelo. Como lidar com este problema? Use primeiro algoritmo e s\u00f3 eleja l\u00edder ap\u00f3s maioria de votos. Rede redundante, disco compartilhado, centraliza\u00e7\u00e3o, volta ao primeiro caso. Detec\u00e7\u00e3o de Falhas Elei\u00e7\u00e3o de l\u00edderes perfeita \u00e9 imposs\u00edvel em cen\u00e1rios real\u00edsticos. Detec\u00e7\u00e3o de falhas perfeita \u00e9 imposs\u00edvel... em sistemas distribu\u00eddos ass\u00edncronos (Internet) sujeitos \u00e0 parti\u00e7\u00f5es (Internet) com requisitos de disponibilidade total. Falemos mais sobre este problema depois.","title":"Coordena\u00e7\u00e3o"},{"location":"teaching/gbc074gsi028/coord/#coordenacao","text":"Como visto na se\u00e7\u00e3o sobre Multiprograma\u00e7\u00e3o , diversas tarefas exigem coordena\u00e7\u00e3o entre threads em uma aplica\u00e7\u00e3o centralizada em que se faz uso de concorr\u00eancia para melhor uso de recursos computacionais, obten\u00e7\u00e3o de melhor desempenho, e modulariza\u00e7\u00e3o do c\u00f3digo. Sistemas distribu\u00eddos levam concorr\u00eancia a um novo patamar de complexidade, fazendo uso de m\u00faltiplos processos, cada um com possivelmente m\u00faltiplos threads , ainda por cima, espalhados geograficamente. Outras solu\u00e7\u00f5es e abstra\u00e7\u00f5es s\u00e3o portanto necess\u00e1rias.","title":"Coordena\u00e7\u00e3o"},{"location":"teaching/gbc074gsi028/coord/#exclusao-mutua","text":"Um dos problemas enfrentados em sistemas que fazem uso de concorr\u00eancia, distribu\u00eddos ou n\u00e3o, \u00e9 a exclus\u00e3o m\u00fatua. Em um sistema centralizado, uma vari\u00e1vel global, um lock, ou outra primitiva de sincroniza\u00e7\u00e3o podem ser usadas na sincroniza\u00e7\u00e3o, mas em um sistema distribu\u00eddo, primitivas simples como estas provavelmente n\u00e3o estar\u00e3o dispon\u00edveis ou o sistema ser\u00e1 muito restrito. Como, ent\u00e3o, controlar o acesso de m\u00faltiplos processos a um recurso compartilhado, garantindo que cada processo controla exclusivamente aquele recurso durante seu acesso? Qualquer solu\u00e7\u00e3o que se proponha a este problema de exclus\u00e3o m\u00fatua, precisa ter as propriedades 1, 2, 3, e, idealmente, a 4, a seguir: Exclus\u00e3o M\u00fatua exclus\u00e3o m\u00fatua - somente um processo pode estar na regi\u00e3o cr\u00edtica em qualquer instante de tempo; aus\u00eancia de deadlocks - se processos est\u00e3o tentando acessar o recurso, ent\u00e3o algum processo deve conseguir acesso em algum instante, dado que nenhum processo fique na regi\u00e3o cr\u00edtica indefinidamente; n\u00e3o-inani\u00e7\u00e3o - todos os processos interessados conseguem, em algum momento, acessar o recurso; espera limitada - idealmente, o tempo de espera pelo recurso \u00e9 limitado. H\u00e1 diversas solu\u00e7\u00f5es para exclus\u00e3o m\u00fatua em sistemas distribu\u00eddos, em diversos cen\u00e1rios, com seus pr\u00f3s e contras. Tr\u00eas das mais simples, e que ilustram o universo de solu\u00e7\u00f5es s\u00e3o via um processo centralizador, em um anel em que a vez \u00e9 circulada, e baseada em quoruns.","title":"Exclus\u00e3o M\u00fatua"},{"location":"teaching/gbc074gsi028/coord/#coordenador","text":"Enquanto em um sistema centralizado h\u00e1 um sistema operacional que prov\u00ea abstra\u00e7\u00f5es simples para os processos a serem coordenados, em um sistema distribu\u00eddo, n\u00e3o h\u00e1 naturalmente tal entidade. Uma poss\u00edvel solu\u00e7\u00e3o para o problem de exclus\u00e3o m\u00fatua em um ambiente distribu\u00eddo \u00e9 justamente dar um passo para tr\u00e1s e introduzir um coordenador. Nesta abordagem, os processos que precisam acessar a regi\u00e3o cr\u00edtica s\u00e3o denominados participantes e um dos processos assume o pal de coordenador . \u00c9 poss\u00edvel que um mesmo processo atue nos dois pap\u00e9is sem nenhum preju\u00edzo. Os processos executam o seguinte protocolo: Participante Envia requisi\u00e7\u00e3o de acesso ao coordenador Espera por resposta do coordenador Acessa o recurso Envia libera\u00e7\u00e3o do recurso para o coordenador Coordenador Inicializa recurso como livre Ao receber uma requisi\u00e7\u00e3o, a enfileira Ao receber uma libera\u00e7\u00e3o, marca o recurso como livre Sempre que recurso estiver marcado como livre E a fila n\u00e3o estiver vazia remove primeiro processo da fila envia libera\u00e7\u00e3o para processo removido marca o recurso como ocupado O diagrama a seguir apresenta uma execu\u00e7\u00e3o deste protocolo em um cen\u00e1rio com tr\u00eas participantes. O estado do coordenador mostra se o recurso est\u00e1 livre ou ocupado e quais processos esperam por permiss\u00e3o de acesso. sequenceDiagram participant Coordenador note over Coordenador: Recurso=livre/Fila = [] Part1->>Coordenador: RequestAccess note over Coordenador: Recurso=livre/Fila = [Part1] Coordenador->>Part1: ResponseOK note over Coordenador: Recurso=ocupado/Fila = [] Part2->>Coordenador: RequestAccess note over Coordenador: Recurso=ocupado/Fila = [Part2] Part1->>Coordenador: RequestFree note over Coordenador: Recurso=livre/Fila = [Part2] Coordenador->>Part1: ResponseFree Part3->>Coordenador: RequestAccess note over Coordenador: Recurso=livre/Fila = [Part2,Part3] Coordenador->>Part2: ResponseOK note over Coordenador: Recurso=ocupado/Fila = [Part3] Part2->>Coordenador: RequestFree note over Coordenador: Recurso=livre/Fila = [Part3] Coordenador->>Part2: ResponseFree note over Coordenador: Recurso=ocupado/Fila = [] Coordenador->>Part3: ResponseOK Part3->>Coordenador: RequestFree note over Coordenador: Recurso=livre/Fila = [] Coordenador->>Part3: ResponseFree Este algoritmo satisfaz as caracter\u00edsticas elencadas acima. Exclus\u00e3o m\u00fatua - se o coordenador autoriza um participante X, somente ap\u00f3s o participante X liberar o recurso \u00e9 que outro participante poder\u00e1 obter nova autoriza\u00e7\u00e3o. Aus\u00eancia de deadlocks - Todo processo que requisitar o recurso, entrar\u00e1 em uma fila, em apenas uma posi\u00e7\u00e3o; assim, a fila prover\u00e1 uma ordem total para os acessos, sem a possibilidade de circularidade nesta ordem. N\u00e3o-inani\u00e7\u00e3o - Dado que ningu\u00e9m fura a fila e que a cada vez que o recurso \u00e9 liberado a fila anda, em algum momento a vez do processo chegar\u00e1. Espera limitada - Dado que a posi\u00e7\u00e3o na fila pode apenas decrementar, seria poss\u00edvel estimar quanto tempo o participante precisa esperar para acessar o recurso. Outra vantagem deste algoritmo \u00e9 sua simplicidade e, conseguentemente, facilidade de implementa\u00e7\u00e3o. Contudo, este algoritmo tem tamb\u00e9m desvantagens, por exemplo, se muitas requisi\u00e7\u00f5es de acesso forem feitas, o coordenador pode ser sobrecarregado e se tornar um gargalo no acesso \u00e0 regi\u00e3o cr\u00edtica. Mais s\u00e9rio ainda \u00e9 a quest\u00e3o de como lidar com falhas, por exemplo, se ou o coordenador ou o participante que detem o direito de acesso ao recurso para de funcionar, ent\u00e3o nenhum outro processo conseguir\u00e1 acesso. Estes aspectos nos permitem mergulhar na \u00e1rea de toler\u00e2ncia a falhas, e o faremos, mas mais tarde. Por enquanto, consideraremos toler\u00e2ncia a falhas de forma superficial, ap\u00f3s discutirmos outra abordagem.","title":"Coordenador"},{"location":"teaching/gbc074gsi028/coord/#anel","text":"Nesta abordagem, os processos se organizam em um anel l\u00f3gico, com um processo antes e outro depois. Um dos processos \u00e9 iniciado com um token que d\u00e1 acesso ao recurso e o token \u00e9 passado adiante no anel; sempre que estiver de posse do token, o processo pode acessar o recurso. Ou seja, todos os participantes executam o seguinte protocolo: Participante Ao receber o token de acesso, se quiser acessar o recurso, acessa. Envia o token para o pr\u00f3ximo n\u00f3 do anel. O diagrama adiante mostra uma execu\u00e7\u00e3o do algoritmo em que apenas os participantes 1 e 3 acessam o recurso. sequenceDiagram Part1->>Part2: Permiss\u00e3o de Acesso Part2->>Part3: Permiss\u00e3o de Acesso note over Part3: Acessa o recurso Part3->>Part4: Permiss\u00e3o de Acesso Part4->>Part1: Permiss\u00e3o de Acesso note over Part1: Acessa o recurso Part1->>Part2: Permiss\u00e3o de Acesso Part2->>Part3: Permiss\u00e3o de Acesso note over Part3: Acessa o recurso Part3->>Part4: Permiss\u00e3o de Acesso Part4->>Part1: Permiss\u00e3o de Acesso Como o algoritmo centralizado, o algoritmo do anel tamb\u00e9m garante as propriedades 1, 2, 3 e 4, al\u00e9m de ser f\u00e1cil de implementar, testar e entender. Diferente do algoritmo centralizado, o algoritmo do anel n\u00e3o sofre com problemas de gargalo, pois nenhum processo precisa participar em todos os acessos, como o coordenador. Contudo, o algoritmo do anel desperdi\u00e7a tempo passando o token para quem n\u00e3o necessariamente quer acessar a regi\u00e3o cr\u00edtica. Tamb\u00e9m importante \u00e9 que este algoritmo tamb\u00e9m sofre com falhas: se um participante falha enquanto com o token , levando-o para al\u00e9m.","title":"Anel"},{"location":"teaching/gbc074gsi028/coord/#lidando-com-falhas","text":"Em ambos os algoritmos, centralizado e do anel, se um processo falhar, o algoritmo pode ficar \"travado\". Vejamos alguns casos espec\u00edficos: No algoritmo centralizado, se o coordenador falha antes de liberar o acesso para algum processo, ele leva consigo a permiss\u00e3o. Em ambos os algoritmos, se o processo acessando o recurso falha, a permiss\u00e3o \u00e9 perdida e os demais processos sofrer\u00e3o inani\u00e7\u00e3o. No algoritmo do anel, se qualquer outro processo falha, o anel \u00e9 interrompido o anel n\u00e3o conseguir\u00e1 circular. Observe que nem falamos de falhas dos canais e j\u00e1 temos diversos cen\u00e1rios a serem resolvidos, para os quais se lhes pedir uma solu\u00e7\u00e3o, tenho certeza absoluta de que me oferecer\u00e3o alguma baseada em timeouts . Por exemplo, se o processo n\u00e3o devolver a permiss\u00e3o de acesso antes de que uma certa quantidade de tempo tenha passado, um timeout , ent\u00e3o assuma que o mesmo parou de funcionar e n\u00e3o voltar\u00e1 mais, e gere uma nova permiss\u00e3o a ser passada a outros requisitantes. O problema desta e outras \"solu\u00e7\u00f5es\" baseadas em timeouts est\u00e1 no assumir que o processo parou de funcionar , pois caso isso n\u00e3o seja verdade, teremos agora dois tokens no sistema, podendo levar \u00e0 viola\u00e7\u00e3o da propriedade de exclus\u00e3o m\u00fatua. Viola\u00e7\u00e3o da exclus\u00e3o m\u00fatua Fazer diagrama de sequ\u00eancia mostrando viola\u00e7\u00e3o da exclus\u00e3o m\u00fatua. Por mais que se ajuste o valor do temporizador, em um sistema distribu\u00eddo ass\u00edncrono, mesmo que aumentado com um rel\u00f3gio para medir a passagem do tempo local, o mesmo pode sempre estar errado. Impossibilidade de detec\u00e7\u00e3o de falhas Em um sistema distribu\u00eddo ass\u00edncrono, \u00e9 imposs\u00edvel distinguir um processo falho de um processo lento. Mais tarde discutiremos as implica\u00e7\u00f5es desta impossibilidade. Por agora, tentemos responder \u00e0 seguinte quest\u00e3o. Question Qual deve ser um timeout razo\u00e1vel para o meu sistema? A resposta depende de mais perguntas, como: Qual o custo E E de esperar por mais tempo? Qual o custo C C de cometer um engano? Qual a probabilidade p p de cometer um engano? O custo esperado por causa dos erros, isto \u00e9, a esperan\u00e7a matem\u00e1tica da vari\u00e1vel aleat\u00f3ria custo, \u00e9 menor que o custo de se esperar por mais tempo, isto \u00e9, C * p < E C * p < E ? Embora esta an\u00e1lise possa ser feita para estes algoritmos, a verdade \u00e9 que s\u00e3o realmente limitados e outras abordagens seriam melhor destino dos seus esfor\u00e7os. Por exemplo, podemos partir para a an\u00e1lise de algoritmos probabil\u00edsticos, pois afinal, como disse certa vez Werner Fogels, CTO da Amazon Se o mundo \u00e9 probabil\u00edstico, porqu\u00ea meus algoritmos devem ser determin\u00edsticos?\" Uma abordagem probabil\u00edstica interessante \u00e9 baseada em qu\u00f3runs.","title":"Lidando com Falhas"},{"location":"teaching/gbc074gsi028/coord/#quorum","text":"De acordo com o Dicion\u00e1rio Priberam da L\u00edngua Portuguesa, consultado em 17-04-2019 , \"qu\u00f3rum\" \u00e9 o N\u00famero de pessoas imprescind\u00edvel para a realiza\u00e7\u00e3o de algo. Aqui, este este algo ser\u00e1 a libera\u00e7\u00e3o de acesso ao recurso almejado pelos processos no sistema distribu\u00eddo. Esta abordagem \u00e9 semelhante em v\u00e1rios aspectos \u00e0 coordenada. De fato, um dos pap\u00e9is na abordagem \u00e9 o de coordenador, que executa o mesmo protocolo que antes. Entretanto, em vez de apenas um coordenador no sistema, temos n n , dos quais o participante precisa obter m > n/2 m > n/2 autoriza\u00e7\u00f5es antes de acessar o recurso; m m \u00e9 o qu\u00f3rum do sistema. Qu\u00f3rum n n coordenadores. m > n/2 m > n/2 coordenadores J\u00e1 os demais participantes devem agora considerar todo o conjunto de coordenadores antes de assumir que tem acesso a um recurso. O algoritmo completo \u00e9 o seguinte: Coordenador Inicializa recurso como livre Ao receber uma requisi\u00e7\u00e3o, a enfileira Ao receber uma libera\u00e7\u00e3o, marca o recurso como livre Sempre que recurso estiver marcado como livre E a fila n\u00e3o estiver vazia remove primeiro processo da fila envia libera\u00e7\u00e3o para processo removido marca o recurso como ocupado Participante Envia requisi\u00e7\u00e3o de acesso aos n n coordenadores Espera por resposta de m m coordenadores Acessa o recurso Envia libera\u00e7\u00e3o do recurso para o coordenador Al\u00e9m disso, para tornamos o problema mais interessante e demonstrar o potencial deste algoritmo, consideremos que as autoriza\u00e7\u00f5es s\u00e3o armazenadas somente em mem\u00f3ria, e que coordenadores, ao falhar e ent\u00e3o resumir suas atividades, esqueceme das autoriza\u00e7\u00f5es j\u00e1 atribu\u00eddas. Perda de mem\u00f3ria Quando um coordenador falha, esquece que deu ok e reinicia seu estado. Vejamos uma execu\u00e7\u00e3o bem sucedida destes algoritmo: TODO Construir execu\u00e7\u00e3o bem sucedida. Este algoritmo \u00e9 bom? Suponhamos o seguinte cen\u00e1rio: Coordenadores = { c_1,c_2,c_3,c_4,c_5,c_6,c_7 c_1,c_2,c_3,c_4,c_5,c_6,c_7 } n = 7 n = 7 m = 4 m = 4 Participante p_1 p_1 consegue autoriza\u00e7\u00e3o de { c_1,c_2,c_3,c_4 c_1,c_2,c_3,c_4 } e entra na regi\u00e3o cr\u00edtica. Coordenador c_4 c_4 falha e se recupera Participante p_2 p_2 consegue autoriza\u00e7\u00e3o de { c_4,c_5,c_6,c_7 c_4,c_5,c_6,c_7 } e entra na regi\u00e3o cr\u00edtica. Neste cen\u00e1rio, a propriedade de Exclus\u00e3o M\u00fatua \u00e9 violada. Isto porqu\u00ea, dados os dois qu\u00f3runs, todos os processos na interse\u00e7\u00e3o foram reinicidaos. Mas de forma geral, qual a probabilidade de isso acontecer? Ou seja, dados dois quoruns, de tamanho m m , que se sobrepoem em k k processos, qual a probabilidade P_v P_v de que os k k processos na interse\u00e7\u00e3o sejam reiniciados e levem \u00e0 viola\u00e7\u00e3o? Seja a P P a probabilidade de um coordenador em espec\u00edfico falhar e se recuperar dentro de uma janela de tempo \\delta t \\delta t . Temos Probabilidade de falha de exatamente 1 coordenador: P^1(1-P)^{n-1} P^1(1-P)^{n-1} Probabilidade de k k coordenadores falharem: P^k(1-P)^{n-k} P^k(1-P)^{n-k} Probabilidade de quaisquer k k em m m coordenadores falharem: \\binom{m}{k} P^k(1-P)^{m-k} \\binom{m}{k} P^k(1-P)^{m-k} Mas qual \u00e9 o tamanho k k da interse\u00e7\u00e3o? \\left| A \\cup B\\right| = \\left| A \\right| + \\left|B\\right| - \\left| A \\cap B \\right| \\Rightarrow n = m + m - k \\left| A \\cup B\\right| = \\left| A \\right| + \\left|B\\right| - \\left| A \\cap B \\right| \\Rightarrow n = m + m - k \\left| A \\cap B \\right| = \\left| A \\right| + \\left|B\\right| - \\left| A \\cup B\\right| \\Rightarrow k = m + m - n = 2m - n \\left| A \\cap B \\right| = \\left| A \\right| + \\left|B\\right| - \\left| A \\cup B\\right| \\Rightarrow k = m + m - n = 2m - n At\u00e9 agora consideramos que a k k corresponde \u00e0 cardinalidade da interse\u00e7\u00e3o dos dois quoruns, mas se mais do que a interse\u00e7\u00e3o forem reiniciados, tamb\u00e9m teremos problemas. Assim, se k k assume qualquer valor entre o tamanho da interse\u00e7\u00e3o e o n\u00famero total de coordenadores, teremos problemas. Probabilidade de quaisquer k k em m m coordenadores falharem, para qualquer k k variando de 2m-n 2m-n a n n : P_v = \\sum_{k=2m-n}^n \\binom{m}{k} P^k(1-P)^{m-k} P_v = \\sum_{k=2m-n}^n \\binom{m}{k} P^k(1-P)^{m-k} Para facilitar o entendimento desta grandeza, considere o exemplo: P=0.0001 P=0.0001 (1 minuto a cada 10 dias) n = 32 n = 32 m = 0.75n m = 0.75n P_v < 10^{-40} P_v < 10^{-40} ( Curiosidade sobre 10^{40} 10^{40} ) A probabilidade de viola\u00e7\u00e3o da exclus\u00e3o m\u00fatua, neste caso, \u00e9 muito pequena, a despeito de suportar falhas dos coordenadores. Pr\u00f3 Tolera falhas de coordenadores, com probabilidade controlada de viola\u00e7\u00e3o de exclus\u00e3o m\u00fatua. Mas e as outras propriedades desej\u00e1veis do algoritmo de exclus\u00e3o m\u00fatua, s\u00e3o alcan\u00e7adas? Relembrando: Contras Exclus\u00e3o M\u00fatua probabil\u00edstica: 1 - P_v 1 - P_v N\u00e3o-inani\u00e7\u00e3o E se cada participante obtiver o ok de um coordenador? Temporizador para quebrar o deadlock ? Espera limitada Aborts podem levar a espera infinita. Assim, este agoritmo tamb\u00e9m pode n\u00e3o ser adequado para certas situa\u00e7\u00f5es. Vamos tentar reacessar os problemas da primeira abordagem. Por um lado, o uso de um l\u00edder para coordenar a\u00e7\u00f5es em um SD simplifica o projeto, mas, por outro, o coordenador pode se tornar um ponto \u00fanico de falha, como no algoritmo de exclus\u00e3o m\u00fatua centralizado. Mas e se substitu\u00edssemos o coordenador no caso de falhas? Este \u00e9 o problema conhecido como elei\u00e7\u00e3o de l\u00edderes. TODO Maekawa - Diminui n\u00famero de votos necess\u00e1rios ( descri\u00e7\u00e3o ) Lamport - Usa rel\u00f3gios l\u00f3gicos, mas \u00e9 poss\u00edvel entender sem este background ( descri\u00e7ao ) Ricart-Agrawala - Melhora algoritmo de Lamport ( descri\u00e7\u00e3o ) Distributed-Mutual-Exclusion-slides","title":"Qu\u00f3rum"},{"location":"teaching/gbc074gsi028/coord/#eleicao-de-lideres","text":"O problema da escolha de um processo centralizador, ou l\u00edder, pode ser posto informalmente como o procedimento pelo qual um processo \u00e9 escolhido dentre os demais processos, sendo que o processo escolhido \u00e9 ciente da escolha e todos os demais processos o identificam como eleito . Uma nova elei\u00e7\u00e3o deve acontecer sempre que o l\u00edder se tornar indispon\u00edvel . Para entendermos melhor o problema, tentemos desenvolver um protocolo simples para escolhermos um l\u00edder, por exemplo, em sua turma da disciplina de Sistemas Distribu\u00eddos. Em primeiro lugar, precisamos definir um conjunto de candidatos: s\u00e3o todos eleg\u00edveis ou apenas um subconjunto se candidata? Todos se conhecem ou h\u00e1 grupos incomunic\u00e1veis diretamente dentro da turma? Mesmo que um colega seja bem conectado na turma, de que adianta ele ser l\u00edder se frequentemente n\u00e3o est\u00e1 presente quando necess\u00e1rio? Em termos computacionais, estas quest\u00f5es s\u00e3o relevantes pois todos os processoes n\u00e3o nascem iguais; alguns residem em m\u00e1quinas com mais mem\u00f3ria, mais poder de processamento, melhor conex\u00e3o com o resto do mundo ou maior grau de conectividade. Talvez este processo seja um l\u00edder mais \u00fatil que os demais. Al\u00e9m disso, se o processo est\u00e1 frequentemente desconectado, mesmo que bem servido de recursos, n\u00e3o ser\u00e1 um bom l\u00edder. Em segundo lugar, ainda que assumamos um conjunto de processos indiferenci\u00e1veis entre si, com acesso equivalente a recursos e que estejam sempre dispon\u00edves, ou exatamente por isso, temos um problem mais fundamental para resolver: para eleger um l\u00edder, precisamos identificar processos, de forma inequ\u00edvoca. Dentro de uma \u00fanica m\u00e1quina, identificamos processos facilmente usando seu pid , ou process id , um inteiro associado a cada processoinstanciado pelo sistema operacional; o pid \u00e9 v\u00e1lido enquanto o processo estiver executando e pode ser reciclado uma vez que o processo para de executar, o que pode ser um problema. Al\u00e9m disso, o host \u00e9 reiniciado, os pid tamb\u00e9m s\u00e3o, e portanto esta identifica\u00e7\u00e3o n\u00e3o \u00e9 duradoura. Mais importante, o pid s\u00f3 faz sentido dentro de uma \u00fanica m\u00e1quina e n\u00e3o em um sistema distribu\u00eddo. Se apenas uma inst\u00e2ncia do processo executa em um mesmo host , ent\u00e3o o identificador do host em si \u00e9 suficiente e, de fato, comumente utilizado. Se mais de um processo executa no mesmo host , ent\u00e3o cabe ao desenvolvedor criar um esquema que permita diferenciar os processos, e n\u00e3o precisa ser nada complicado; pode ser apenas um par\u00e2metro passado na inicializa\u00e7\u00e3o do processo ou a combina\u00e7\u00e3o IP/porta . Assumindo um esquema de nomea\u00e7\u00e3o est\u00e1 dispon\u00edvel e que todos os processos se conhecem, voltemos ao problema de eleger um l\u00edder para sua turma. Uma abordagem que pode funcionar \u00e9 colocar todos os candidatos para brigar e quem sobrar em p\u00e9 no final, \u00e9 o novo l\u00edder. A despeito desta op\u00e7\u00e3o gerar um l\u00edder n\u00e3o muito popular, o algoritmo do brig\u00e3o \u00e9 um cl\u00e1ssico.","title":"Elei\u00e7\u00e3o de L\u00edderes"},{"location":"teaching/gbc074gsi028/coord/#algoritmo-do-brigao-bully","text":"No algoritmo do brig\u00e3o, alguma caracter\u00edsticas compar\u00e1vel dos processos \u00e9 escolhida e aquele processo funcional com o valor de tal caracter\u00edstica mais vantajoso para um l\u00edder \u00e9 escolhido como tal. Por exemplo, pode ser vantajoso ter um l\u00edder com maior quantidade de mem\u00f3ria, frequ\u00eancia da CPU ou largura de banda da conex\u00e3o com a Internet; no caso de empate, o identificador do processo pode ser usado para gerar uma ordem total entre os processos. Para simplificar, vamos assumir que o identificador do processo reflete as qualidades do mesmo para a lideran\u00e7a, tal que o maior identificador seja o melhor candidato. Os maiores processos, os \"brig\u00f5es\", elimina os processos menores da competi\u00e7\u00e3o, sempre que uma elei\u00e7\u00e3o acontecer. O algoritmo, \u00e9 o seguinte, onde p p e q q s\u00e3o usados para representar tanto identificadores de processos quando os processos em si. Algoritmo do Brig\u00e3o Quando p p suspeita que o l\u00edder n\u00e3o est\u00e1 presente p p envia mensagem (ELEICAO, p p ) para todos os processos com identificador maior que p p Se p p n\u00e3o recebe (OK, p p ) de outros processos, envia (COORD, p p ) para todos os processos Se algum responde, aguarda notifica\u00e7\u00e3o do novo l\u00edder Quando p p recebe (ELEICAO, q q ), q < p q < p * Envia (OK, p p ) Se um processo falho se recupera, inicia uma elei\u00e7\u00e3o TODO Explicar passos. Expandir pr\u00f3ximos","title":"Algoritmo do Brig\u00e3o (Bully)"},{"location":"teaching/gbc074gsi028/coord/#algoritmo-do-anel","text":"Algoritmo do Anel Organize os n\u00f3s em um anel l\u00f3gico Quando p p acha que o l\u00edder est\u00e1 morto: Envia mensagem { p p } para \"a direita\" no anel. Se processo \u00e0 direita est\u00e1 falho, salte-o, e assim por diante. Quando q q recebe { p p } Envia { p,q p,q } para a direita. Quando p p recebe S S tal que q \\in S q \\in S Escolhe menor id em S S , por exemplo, e anuncia como l\u00edder.","title":"Algoritmo do Anel"},{"location":"teaching/gbc074gsi028/coord/#algoritmo-de-chang-robert","text":"Algoritmo de Chang e Robert Organize os n\u00f3s em um anel l\u00f3gico Quando p p acha que o l\u00edder est\u00e1 morto: Envia mensagem p p para \"a direita\" no anel, saltando falhos. Liga flag \"participante\" Quando q q recebe p p Se p > q p > q , repassa p p para a direita. Sen\u00e3o, envia q q para a direita. Liga flag \"participante\" Quando p p recebe q q da esquerda Se \"participante\" est\u00e1 ligado, identifica q q como l\u00edder. Desliga \"participante\" Se p \\neq q p \\neq q , repassa q q \u00e0 direita","title":"Algoritmo de Chang &amp; Robert"},{"location":"teaching/gbc074gsi028/coord/#algoritmo-do-yoyo","text":"Fonte Algoritmo do YoYo Grafos incompletos Duas fases Fase 1 p p envia seu identificador para seus vizinhos. Quando q q recebe p p Se p>q p>q , adiciona aresta q\\rightarrow p q\\rightarrow p Sen\u00e3o, adiciona aresta q\\leftarrow p q\\leftarrow p Fonte (source) Vertedouro (sink) Interno Fase 2 Fontes enviam seus identificadores para seus vizinhos. Interno espera msg de todas as arestas de entrada, escolhe o menor id, e repassa para arestas de sa\u00edda. Vertedouro espera msg de todas as arestas de entrada e escolhe o menor id. Vertedouro envia S para vizinhos de onde viu menor valor e N para os demais. Interno repassa S para o vizinho correspondente ao menor id e N para os demais. Fonte espera por todos os votos. Se todos s\u00e3o S, continua; caso contr\u00e1rio, desiste. N inverte a dire\u00e7\u00e3o das arestas em que trafega. Poss\u00edvel otimizar para eliminar n\u00f3s e arestas irrelevantes. Exemplo: a) The network, b) Oriented network after setup phase, c) YO- phase in which source values are passed, d) YO phase sending responses from sinks, e) updated structure after -YO phase.","title":"Algoritmo do YoYo"},{"location":"teaching/gbc074gsi028/coord/#questoes-importantes","text":"Problemas? Estabilidade? O que acontece se a rede \u00e9 particionada? Split Brain Network Partitioning: rede dividida em duas partes incomunic\u00e1veis. M\u00faltiplas elei\u00e7\u00f5es podem acontecer em paralelo. M\u00faltiplos l\u00edderes em paralelo. Como lidar com este problema? Use primeiro algoritmo e s\u00f3 eleja l\u00edder ap\u00f3s maioria de votos. Rede redundante, disco compartilhado, centraliza\u00e7\u00e3o, volta ao primeiro caso. Detec\u00e7\u00e3o de Falhas Elei\u00e7\u00e3o de l\u00edderes perfeita \u00e9 imposs\u00edvel em cen\u00e1rios real\u00edsticos. Detec\u00e7\u00e3o de falhas perfeita \u00e9 imposs\u00edvel... em sistemas distribu\u00eddos ass\u00edncronos (Internet) sujeitos \u00e0 parti\u00e7\u00f5es (Internet) com requisitos de disponibilidade total. Falemos mais sobre este problema depois.","title":"Quest\u00f5es importantes"},{"location":"teaching/gbc074gsi028/disdb/","text":"Bancos de Dados Distribu\u00eddos NoSQL Estruturas de Dados para SD Qualquer que seja a escolha de algoritmo para fazer o particionamento dos dados entre servidores, sobra ainda a quest\u00e3o de como manipular os dados dentro do servidor. Idealmente, toda opera\u00e7\u00e3o seria executada a partir da mem\u00f3ria principal, tendo assim a menor lat\u00eancia poss\u00edvel. Contudo, para que se tenha tamb\u00e9m durabilidade das opera\u00e7\u00f5es executadas, para que os dados manipulados sobrevivam a reinicializa\u00e7\u00f5es do servidor, intencionais ou n\u00e3o, \u00e9 preciso armazenar os dados em mem\u00f3ria est\u00e1vel , da qual a mais comum \u00e9 s\u00e3o os discos r\u00edgidos . \u00c9 not\u00f3rio que escritas em disco s\u00e3o muito mais lentas que em mem\u00f3ria principal, mas o que exatamente \u00e9 lento no acesso ao disco? Essencialmente, o posicionamento da cabeca de leitura/escrita na trilha correta do disco, pois esta opera\u00e7\u00e3o \u00e9 mec\u00e2nica. Por esta raz\u00e3o, acessos aleat\u00f3rios s\u00e3o mais custosos que acessos sequenciais, pois neste o custo de posicionamento \u00e9 pago apenas uma vez. Por este motivo, muitos bancos de dados, especialmente DHT pois tem seu uso focado em quantidades muito grandes de dados, gerados e acessados com grande velocidade, tentam acessar o disco sempre de forma sequencial. Alguns bancos de dados, como o Cassandra, armazenam os dados na forma de uma Log Structured Merge Tree , ou LSMT. Log Structured Merge Tree Uma Log Structured Merge Tree \u00e9 uma forma de se armazenar dados em disco de forma de forma quase sempre sequencial, minimizando assim os o impacto da durabilidade no desempenho do sistema. Considere um banco armazenando uma pequena quantidade de dados, que cabe em mem\u00f3ria principal. Na LSMT, opera\u00e7\u00f5es de escrita s\u00e3o adicionadas a um commit log , em disco, e somente ent\u00e3o s\u00e3o executadas em mem\u00f3ria principal e confirmadas para o cliente; a estrutura que armazena os dados em mem\u00f3ria \u00e9 denominada memory table , ou simplesmente memtable . Neste cen\u00e1rio o acesso ao disco na escrita \u00e9 sequencial, o melhor que se pode ter em um disco, e a recupera\u00e7\u00e3o dos dados \u00e9 feita diretamente da mem\u00f3ria, r\u00e1pida. No caso de uma reinicializa\u00e7\u00e3o do processo, a reexecu\u00e7\u00e3o do commit log restaurar\u00e1 o estado da memtable. Contudo, se o commit log for extenso, reexecut\u00e1-lo demandar\u00e1 um tempo significativo. Uma forma de acelerar o processo \u00e9 fazer snapshots da memtable de forma sincronizada com a escrita no log. Isto \u00e9, digamos que todas as opera\u00e7\u00f5es de escrita, at\u00e9 a d\u00e9cima, est\u00e3o salvas no commit log e refletidas na memtable. Digamos tamb\u00e9m que todas as opera\u00e7\u00f5es s\u00e3o modifica\u00e7\u00f5es da mesma linha do banco de dados em mem\u00f3ria. Se um snapshot \u00e9 tomado, ele ser\u00e1 correspondente ao commit log, isto \u00e9, conter\u00e1 o efeito de exatamente as mesmas 10 opera\u00e7\u00f5es, mas de forma mais compacta que o log, uma vez que o log conter\u00e1 dez opera\u00e7\u00f5es e o snapshot somente uma linha de dados. Ap\u00f3s o snapshot ser conclu\u00eddo, o log correspondente pode ser apagado. Novas opera\u00e7\u00f5es de escrita devem ser armazenadas em um novo log e, no caso de uma reinicializa\u00e7\u00e3o, primeiro se deve restaurar o snapshot e ent\u00e3o o novo log. Para lidar com corrup\u00e7\u00f5es de arquivo no sistema, pode ser uma boa ideia manter mais do que o \u00faltimo log e snapshot , j\u00e1 que a recupera\u00e7\u00e3o do estado exigiria voltar mais atr\u00e1s na reexecu\u00e7\u00e3o de opera\u00e7\u00f5es. Observe que, al\u00e9m da escrita dos logs, todos os outros acessos ao disco tamb\u00e9m s\u00e3o sequenciais, seja o flush das memtables, ou a leitura dos snapshots para recupera\u00e7\u00e3o e do commit log para reexecu\u00e7\u00e3o, e j\u00e1 que opera\u00e7\u00f5es de leitura s\u00e3o todas respondidas da mem\u00f3ria, o sistema ter\u00e1 um excelente desempenho. Contudo, h\u00e1 outro limitante de desempenho importante, relacionado \u00e0 premissa pouco realista de que os dados cabem todos em mem\u00f3ria. Isto \u00e9, se os dados n\u00e3o cabem em mem\u00f3ria, snapshots ser\u00e3o importantes n\u00e3o somente para permitir coletar lixo dos logs, isto \u00e9, dados obsoletos, mas tamb\u00e9m, para usar a capacidade de armazenamento dos discos. Consideremos ent\u00e3o um cen\u00e1rio em que a memtable cabe apenas n entradas; quando a opera\u00e7\u00e3o para adicionar n+1 n+1 -\u00e9sima entrada \u00e0 memtable \u00e9 recebida, um flushs dos dados para um novo snapshot \u00e9 feito e a memtable \u00e9 resetada , liberando espa\u00e7o em mem\u00f3ria. Para melhorar o desempenho, estas descargas podem ser feitas proativamente antes da chegada de novas entradas e fora do caminho cr\u00edtico da opera\u00e7\u00e3o de escrita, mas isto \u00e9 apenas uma otimiza\u00e7\u00e3o e portanto n\u00e3o a consideraremos aqui. Neste novo fluxo, os arquivos em disco n\u00e3o correspondem mais a snapshots do banco de dados, ent\u00e3o nos referiremos a eles como stable storage tables , ou sstables , em oposi\u00e7\u00e3o \u00e0s memtables , pelo menos por enquanto. Compacta\u00e7\u00f5es Apesar deste novo fluxo de escrita aumentar a capacidade de armazenamento do nosso banco de dados, ele traz problemas para o fluxo de leitura. Digamos que a chave k k teve um valor atribu\u00eddo e descarregado em uma sstable em diversas ocasi\u00f5es. O primeiro problema aqui \u00e9 que h\u00e1 v\u00e1rios valores antigos associados a k k , inutilmente e ocupando espa\u00e7o, isto \u00e9, lixo. O segundo \u00e9 que caso o valor associado a k k seja requisitado, o sistema dever\u00e1 retornar a \u00faltima vers\u00e3o, que pode estar em diversos arquivos. Para lidar com ambos os problemas, podemos compactar as sstables juntas, eliminados dados obsoletos e minimizando o n\u00famero de arquivos a serem pesquisados no caso de leitura. Caso a sstables estejam ordenadas, o procedimento de compacta\u00e7\u00e3o pode ser feito como a uni\u00e3o de dois segmentos de dados no merge sort , isto \u00e9, iterando-se paralelamente nos dois arquivos e escolhendo sempre a menor chave da vez e movendo-a para um novo segmento que conter\u00e1 a uni\u00e3o dos dados. A figura a seguir mostra um exemplo que v\u00e1rias sstables de n\u00edvel 0, aquelas geradas por flushs , s\u00e3o unidas gerando sstables de n\u00edvel 1 e assim sucessivamente. Observe como as compacta\u00e7\u00f5es geram uma \u00e1rvore (na verdade, uma floresta), raz\u00e3o do nome merge tree . No caso de uma pesquisa, somente as tabelas mais \u00e0 direita e de n\u00edvel mais alto precisam ser consultadas e portanto as sstables j\u00e1 usadas como entrada podem ser eliminadas como lixo do sistema. Ainda assim, no caso de uma leitura, diversas sstables potencialmente cont\u00e9m o dado a ser retornado. O problema se agrava em sistemas em que partes do dado possam ser gravadas independentemente, como no CassandraDB, em que cada coluna \u00e9 independente das outras. Diversas propostas poderiam ser feitas para se identificar mais rapidamente se uma sstable cont\u00e9m uma chave. Por exemplo, pode-se associar a cada tabela um bitmap indicando a presen\u00e7a ou n\u00e3o de uma certa chave, mas esta abordagem obviamente falha se o espa\u00e7o de chaves for grande. Outra possibilidade \u00e9 lembrar a faixa de chaves contida na tabela. Esta estrat\u00e9gia pode ser \u00fatil caso haja localidade no espa\u00e7o de chaves no momento da escrita, mas falhar\u00e1 miseravelmente se o espa\u00e7o de chaves for usado uniformemente, resultando em faixas grandes entre a menor e maior chaves de cada tabela. Como acelerar a identifica\u00e7\u00e3o das sstables pertinentes? Entram em cena os filtros de Bloom . Filtros de Bloom De acordo com nossa fonte mais que confi\u00e1vel, a Wikipedia A Bloom filter is a **space-efficient* probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not, thus a Bloom filter has a 100% recall rate. In other words, a query returns either \"possibly in set\" or \"definitely not in set\" .* Se associarmos a cada sstable um filtro de Bloom, ent\u00e3o s\u00f3 ser\u00e1 preciso l\u00ea-la se o filtro correspondente disser que a chave possivelmente est\u00e1 contida, como no seguinte exemplo. Mas como exatamente constru\u00edmos um filtro de Bloom? Iniciamos com um vetor de bits inicialmente zerados e um conjunto finito de fun\u00e7\u00f5es de hash cujo resultado seja uniformemente distribu\u00eddo no tamanho do vetor de bits. Para cada elemento colocado no conjunto a ser refletido pelo filtro, aplicamos cada uma das fun\u00e7\u00f5es hash e colocamos o bit 1 na posi\u00e7\u00e3o do vetor igual ao resultado da fun\u00e7\u00e3o. No exemplo a seguir, inserimos os elementos x, y e z e usamos tr\u00eas fun\u00e7\u00f5es hash. Na consulta , cada elemento passa por pelas mesmas fun\u00e7\u00f5es hash. Se algum dos \u00edndices apontados n\u00e3o estiver com um 1, como no caso do w, no exemplo, o elemento n\u00e3o pertence ao conjunto. Caso contr\u00e1rio, o filtro responder\u00e1 que \u00e9 poss\u00edvel que perten\u00e7a. Mas qu\u00e3o bom \u00e9 um filtro de Bloom na identifica\u00e7\u00e3o do das sstables? Ou, de outra forma, quais fatores influenciam na taxa de falsos positivos do filtro? * o n\u00famero n n de elementos no conjunto, uma vez que quanto mais elementos, mais bits 1; * o n\u00famero k k de hashes, pois quanto mais hashes, mais bits transformados em 1; e, * o n\u00famero m m de bits no vetor, pois quanto menos bits, mais colis\u00f5es de bits. De forma mais precisa, * a probabilidade de setar um certo bit na inser\u00e7\u00e3o de um elemento \u00e9 1/m 1/m , e * a probabilidade de n\u00e3o setar tal bit \u00e9 1 - 1/m 1 - 1/m ; * a probabilidade de k k hashes n\u00e3o setarem um bit \u00e9 (1 - 1/m)^k (1 - 1/m)^k ; * a probabilidade de n\u00e3o setar um bit ap\u00f3s n n inser\u00e7\u00f5es \u00e9 (1 - 1/m)^{kn} (1 - 1/m)^{kn} ; * a probabilidade de setar um bit ap\u00f3s n n inser\u00e7\u00f5es \u00e9 1 - (1 - 1/m)^{kn} 1 - (1 - 1/m)^{kn} Logo, * a probabilidade de falso positivo p = (1 - (1 - 1/m)^{kn})^k \\approx (1 - e^{-kn/m})^k p = (1 - (1 - 1/m)^{kn})^k \\approx (1 - e^{-kn/m})^k O que nos permite chegar \u00e0 rela\u00e7\u00e3o * m/n = - 1.44\\log_2 p m/n = - 1.44\\log_2 p , em que podemos calcular m m em fun\u00e7\u00e3o do n n esperado e do p p desejado. E podemos tamb\u00e9m identificar o k k \u00f3timo para a situa\u00e7\u00e3o, pela equa\u00e7\u00e3o * k = - \\frac{\\ln p}{\\ln 2} = - \\log_2 p k = - \\frac{\\ln p}{\\ln 2} = - \\log_2 p Uma forma \"simples\" de visualizar este resultado \u00e9 dada pela figura a seguir, em que o eixo Y d\u00e1 a taxa de falsos positivos do filtro em fun\u00e7\u00e3o do n\u00famero de elementos inseridos, indicado no eixo X, para diversas configura\u00e7\u00f5es, apresentadas como curvas. Por exemplo, com um filtro com m = 2^{24}b = 2MB m = 2^{24}b = 2MB , ap\u00f3s 1 milh\u00e3o de inser\u00e7\u00f5es, tem-se probabilidade de falsos positivo p = 0,0001 p = 0,0001 . Refer\u00eancias Modern Algorithms and Data Structures: Bloom-Filter TODO Mover ED SD de Tecnologias para c\u00e1 Combinar https://adambcomer.com/blog/simple-database/motivation-design.html https://adambcomer.com/blog/simple-database/memtable.html https://adambcomer.com/blog/simple-database/wal.html \\section{Modelos de Consist\u00eancia} \\subsection{Motiva\u00e7\u00e3o} \\begin{frame}{Content Delivery Network} \\includegraphics[width=.7\\textwidth]{images/cdn} \\begin{itemize} \\item Conte\u00fado \u00e9 colocado pr\u00f3ximo aos clientes. \\item Conte\u00fado est\u00e1tico ou majoritariamente determin\u00edstico. \\item Um pequeno atraso na replica\u00e7\u00e3o \u00e9 tolerado. \\item Atualiza\u00e7\u00e3o acontece infrequentemente. \\end{itemize} \\begin{itemize} \\item Conte\u00fado \u00e9 colocado pr\u00f3ximo aos clientes. \\item Conte\u00fado est\u00e1tico ou majoritariamente determin\u00edstico. \\item Um pequeno atraso na replica\u00e7\u00e3o \u00e9 tolerado. \\item Atualiza\u00e7\u00e3o acontece infrequentemente. \\end{itemize} Fonte: \\url{ https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/ } \\end{frame} \\begin{frame} {RAFT} Considere um sistema replicado usando RAFT. Ap\u00f3s cada opera\u00e7\u00e3o que modifica o estado, todas as r\u00e9plicas tem o mesmo valor. \\includegraphics[width=.5\\textwidth]{images/raft} %Fonte: http://thesecretlivesofdata.com/raft/ Caso um cliente queira apenas ler o estado, o que deve fazer? \\pause \\begin{itemize} \\item Requisitar o valor do l\u00edder\\pause : o valor lido ser\u00e1 \\alert{o \u00faltimo} valor escrito.\\pause \\item Requisitar o valor de alguma r\u00e9plica\\pause : o valor lido ser\u00e1 \\alert{um} valor escrito, n\u00e3o necessariamente o \u00faltimo. Mais tempo implica maior a probabilidade de ser o valor escrito.\\pause \\item Se em vez de difus\u00e3o at\u00f4mica us\u00e1ssemos IP-Multicast?\\pause{} Alguns valores escritos poderiam nunca ser vistos. \\end{itemize} \\end{frame} \\begin{frame}{Replica\u00e7\u00e3o: solu\u00e7\u00e3o ou problema?} Replica\u00e7\u00e3o aumenta disponibilidade mas tem custo em desempenho e, possivelmente, inconsist\u00eancias tempor\u00e1rias nos dados. \\end{frame} \\begin{frame}{Replica\u00e7\u00e3o: solu\u00e7\u00e3o ou problema?} Replica\u00e7\u00e3o aumenta disponibilidade mas tem custo em desempenho e, possivelmente, inconsist\u00eancias tempor\u00e1rias nos dados. \\end{frame} \\begin{frame}{Conflitos} O problema da replica\u00e7\u00e3o est\u00e1 em como lidar com conflitos nas opera\u00e7\u00f5es dos clientes. \\begin{itemize} \\item Leitura-Leitura: N\u00e3o h\u00e1 conflitos. Qualquer quantidade de clientes.\\\\ Replicar ``... \u00e9 f\u00e1cil, extremamente f\u00e1cil ...'' \\item Leitura-Escrita: Clientes querem ler dados corretos e, geralmente, a \u00faltima vers\u00e3o escrita.\\\\ Como atualizar rapidamente as r\u00e9plicas? \\item Escrita-Escrita: Dados sendo atualizados em m\u00faltiplos lugares ao mesmo tempo. Ordena\u00e7\u00e3o/compatibiliza\u00e7\u00e3o das escritas. \\end{itemize} %\\pause Ordena\u00e7\u00e3o total das opera\u00e7\u00f5es pode ser custosa demais. \\pause Solu\u00e7\u00e3o? \\pause Enfraquecer os requisitos de consist\u00eancia dos sistema. \\end{frame} \\begin{frame}{Modelos de Consist\u00eancia} Diferentes formas de propaga\u00e7\u00e3o e recupera\u00e7\u00e3o resultam em diferentes garantias, \\pause diferentes \\alert{modelos de consist\u00eancia}. \\pause \\begin{itemize} \\item Consist\u00eancia forte: todas a r\u00e9plicas tem o mesmo valor dentro de um pequena janela de tempo.\\ Alto custo. \\item Consist\u00eancia eventual: r\u00e9plicas um dia ter\u00e3o o mesmo valor.\\ Demora em sincronizar. \\item Consist\u00eancia fraca: n\u00e3o h\u00e1 garantia da replica\u00e7\u00e3o.\\ Yay!!! \\end{itemize} \\pause Diferentes modelos com nomes parecidos ou at\u00e9 iguais. \u00c9 preciso conhecer o que cada sistema est\u00e1 entregando para poder utiliz\u00e1-lo da forma correta. \\end{frame} \\begin{block}{Modelo de Consist\u00eancia} Contrato entre uma data-store (distribu\u00edda) em que se especifica os resultados de opera\u00e7\u00f5es de leitura e escrita na presen\u00e7a de concorr\u00eancia. \\end{block} \\end{frame} \\begin{frame}{Modelos Centrados nos Dados x Cliente} \\begin{itemize} \\item Os dados s\u00e3o mantidos consistentes. \\item Inconsist\u00eancias n\u00e3o s\u00e3o vistas pelo cliente. \\end{itemize} \\end{frame} \\begin{frame}{Modelos Centrados nos Dados x Cliente} \\begin{itemize} \\item Os dados s\u00e3o mantidos consistentes. \\item Inconsist\u00eancias n\u00e3o s\u00e3o vistas pelo cliente. \\end{itemize} \\end{frame} \\subsection{Modelos Centrados nos Dados} \\begin{frame}{Data store} \\begin{block}{Modelo Computacional} \\center \\includegraphics[width=.7\\textwidth]{images/07-01} \\end{block} \\end{frame} \\begin{frame}{Data store} \\begin{block}{Modelo Computacional} \\center \\includegraphics[width=.7\\textwidth]{images/07-01} \\end{block} \\end{frame} \\begin{frame}{Modelos de Consist\u00eancia Centrados nos Dados} \\begin{itemize} \\item Consist\u00eancia Forte: opera\u00e7\u00f5es s\u00e3o sincronizadas \\begin{itemize} \\item Estrita (Strict): segue a linha do tempo. \\item Sequencial: bancos de dados transacionais (quase). \\item Causal: opera\u00e7\u00f5es com depend\u00eancia causal s\u00e3o ordenadas \\item FIFO: ordem dos comandos de um mesmo cliente. \\end{itemize} \\item Consist\u00eancia Fraca: sincroniza\u00e7\u00e3o acontece quando necess\u00e1rio. \\begin{itemize} \\item Consist\u00eancia fraca geral \\item Consist\u00eancia de entrada \\end{itemize} \\item Quanto mais fraco, mais escal\u00e1vel. \\end{itemize} \\end{frame} \\begin{frame}{Modelos de Consist\u00eancia Centrados nos Dados} \\begin{itemize} \\item Consist\u00eancia Forte: opera\u00e7\u00f5es s\u00e3o sincronizadas \\begin{itemize} \\item Estrita (Strict): segue a linha do tempo. \\item Sequencial: bancos de dados transacionais (quase). \\item Causal: opera\u00e7\u00f5es com depend\u00eancia causal s\u00e3o ordenadas \\item FIFO: ordem dos comandos de um mesmo cliente. \\end{itemize} \\item Consist\u00eancia Fraca: sincroniza\u00e7\u00e3o acontece quando necess\u00e1rio. \\begin{itemize} \\item Consist\u00eancia fraca geral \\item Consist\u00eancia de entrada \\end{itemize} \\item Quanto mais fraco, mais escal\u00e1vel. \\end{itemize} \\end{frame} \\begin{frame}{Nota\u00e7\u00e3o} \\includegraphics[width=1\\textwidth]{images/07-04} \\begin{itemize} \\item A leitura de x em (a) retorna a \\item A primeira leitura de x em (b) retorna Nil \\item A segunda leitura de x em (b) retorna a \\end{itemize} \\end{frame} \\begin{frame}{Consist\u00eancia Estrita} Qualquer leitura de um objeto X X retorna o valor gravado em X X pela opera\u00e7\u00e3o de escrita mais recente em X X . 1 2 3 4 \\begin{itemize} \\item O que quer dizer ``mais recente'' em um sistema distribu\u00eddo ass\u00edncrono? \\item Todas as opera\u00e7\u00f5es de escrita s\u00e3o instantaneamente vis\u00edveis a todos os processos e \\alert{tempo global} \u00e9 respeitado. \\item Comportamento observado em um sistema sem conflitos ou centralizado \\end{itemize} 1 \\includegraphics[width=1\\textwidth]{images/07-04} \\end{frame} \\begin{frame}{Consist\u00eancia Sequencial} O resultado de qualquer execu\u00e7\u00e3o \u00e9 equivalente a alguma execu\u00e7\u00e3o sequencial dos processos, e as opera\u00e7\u00f5es da cada processo aparecem nesta execu\u00e7\u00e3o sequencial na ordem especificada por seu programa. \\pause \\includegraphics[width=.5 \\textwidth]{images/07-05a} \\pause P2, P3, P4, P1, P4, P3 \\pause \\includegraphics[width=.5 \\textwidth]{images/07-05b} \\pause P1 ou P2, qual veio primeiro? \\end{frame} \\begin{frame}{Consist\u00eancia Causal} Escritas com potencial rela\u00e7\u00e3o causal s\u00e3o vistas por todos os processos na mesma ordem. Escritas concorrentes (n\u00e3o causalmente relacionadas) podem se vistas em ordens diferentes por processos diferentes. \\includegraphics[width=1 \\textwidth]{images/07-08} \\pause W(x)b depende de R(x)a que depende de W(x)a\\ \\pause W(x)c e W(x)b s\u00e3o concorrentes. \\end{frame} \\begin{frame}{Consist\u00eancia Causal} \\includegraphics[width=.5 \\textwidth]{images/07-09a} \\pause W(x)b depende de R(x)a que depende de W(x)a. W(x)a deve ser ordenado com W(x)b. P3 n\u00e3o pode ter lido b e depois a. \\pause \\includegraphics[width=.5 \\textwidth]{images/07-09b} \\end{frame} \\begin{frame}{Consist\u00eancia FIFO} Escritas de um processo s\u00e3o vistas por todos os outros processos na ordem em que foram feitas. Escritas de diferentes processos podem ser vistas em ordens diferentes. \\includegraphics[width=1 \\textwidth]{images/07-08b} \\end{frame} % % \\begin{frame}{Consist\u00eancia Cont\u00ednua} %Grau de (in)consist\u00eancia \u00e9 limitado. %\\begin{itemize} % \\item r\u00e9plicas podem diferir na quantidade e ordem de atualiza\u00e7\u00f5es executadas. % \\item r\u00e9plicas podem diferir em valores num\u00e9ricos para dados % \\item r\u00e9plicas podem diferir na idade dos dados %\\end{itemize} % %\\begin{block}{Conit} % Unidade de Consis\u00eancia -- especifica uma unidade de dados sobre a qual consist\u00eancia pode ser medida. %\\end{block} %\\end{frame} % % \\begin{frame}{Conit} %\\includegraphics[width=.7\\textwidth]{images/07-02} % %\\begin{block}{Conit: <span><span class=\"MathJax_Preview\">x</span><script type=\"math/tex\">x e y y } %\\begin{itemize} % \\item Rel\u00f3gio vetorial (Vector clock) % \\item Opera\u00e7\u00e3o em cinza \u00e9 permanente %\\end{itemize} %\\end{block} %\\end{frame} % % \\begin{frame}{Conit} %\\includegraphics[width=.7\\textwidth]{images/07-02} % %\\begin{block}{Conit: <span><span class=\"MathJax_Preview\">x</span><script type=\"math/tex\">x e y y } % \\begin{itemize} % \\item A tem tr\u00eas opera\u00e7\u00f5es n\u00e3o permanentes (pendentes): desvio de ordem = 3. % \\item B tem duas opera\u00e7\u00f5es n\u00e3o permanentes: desvio de ordem = 2 % \\end{itemize} %\\end{block} %\\end{frame} % % % \\begin{frame}{Conit} %\\includegraphics[width=.7\\textwidth]{images/07-02} % %\\begin{block}{Conit: <span><span class=\"MathJax_Preview\">x</span><script type=\"math/tex\">x e y y } % \\begin{itemize} % \\item A n\u00e3o viu uma opera\u00e7\u00e3o de B, que muda o valor em 5: desvio num\u00e9rico (1,5) % \\item B n\u00e3o viu t\u00eas opera\u00e7\u00f5es de A, que muda o valor em 9: desvio num\u00e9rico (3,\\alert{9}) % \\end{itemize} %\\end{block} %\\end{frame} % % % \\begin{frame}{Conit} %\\includegraphics[width=.7\\textwidth]{images/07-02} % %\\begin{block}{Conit: <span><span class=\"MathJax_Preview\">x</span><script type=\"math/tex\">x e y y } % \\begin{itemize} % \\item A n\u00e3o viu 11 opera\u00e7\u00f5es de B % \\item B n\u00e3o viu 15 opera\u00e7\u00f5es de A % \\end{itemize} %\\end{block} %\\end{frame} % % \\begin{frame}{Conit} %Como manter dist\u00e2ncia num\u00e9rica limitada? %\\end{frame} % \\begin{frame}{Opera\u00e7\u00f5es Simples} Modelos desenvolvidos para processamento paralelo, especificando a ordem de execu\u00e7\u00e3o de opera\u00e7\u00f5es em m\u00faltiplos threads/processos. \\end{frame} \\begin{frame}{Opera\u00e7\u00f5es Simples} Modelos desenvolvidos para processamento paralelo, especificando a ordem de execu\u00e7\u00e3o de opera\u00e7\u00f5es em m\u00faltiplos threads/processos. \\end{frame} \\begin{frame}{Grupos de Opera\u00e7\u00f5es} \\begin{block}{Ideia} Efeito de um grupo de opera\u00e7\u00f5es se torna vis\u00edvel a outros processos ao mesmo tempo. Efeitos de opera\u00e7\u00f5es individuais em um grupo n\u00e3o s\u00e3o vis\u00edveis. \\end{block} \\begin{itemize} \\item Vari\u00e1veis de sincroniza\u00e7\u00e3o \\begin{itemize} \\item Acesso \u00e0s vari\u00e1veis de sincroniza\u00e7\u00e3o da datastore \u00e9 sequencialmente consistente. \\item Acesso \u00e0 vari\u00e1vel de sincroniza\u00e7\u00e3o n\u00e3o \u00e9 permitido at\u00e9 que todas as escritas das anteriores tenham sido executadas em todos os lugares. \\item Acesso aos dados n\u00e3o \u00e9 permitido at\u00e9 que todas as vari\u00e1veis de sincroniza\u00e7\u00e3o tenham sido liberadas. \\end{itemize} \\end{itemize} \\begin{itemize} \\item Vari\u00e1veis de sincroniza\u00e7\u00e3o \\begin{itemize} \\item Acesso \u00e0s vari\u00e1veis de sincroniza\u00e7\u00e3o da datastore \u00e9 sequencialmente consistente. \\item Acesso \u00e0 vari\u00e1vel de sincroniza\u00e7\u00e3o n\u00e3o \u00e9 permitido at\u00e9 que todas as escritas das anteriores tenham sido executadas em todos os lugares. \\item Acesso aos dados n\u00e3o \u00e9 permitido at\u00e9 que todas as vari\u00e1veis de sincroniza\u00e7\u00e3o tenham sido liberadas. \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Vari\u00e1veis de sincroniza\u00e7\u00e3o} \\includegraphics[width=.7\\textwidth]{images/weaka} \\includegraphics[width=.7\\textwidth]{images/weakb} Materializando vari\u00e1veis de sincroniza\u00e7\u00e3o na forma de \\emph{locks} \\end{frame} \\begin{frame}{Consist\u00eancia de Entrada} \\begin{itemize} \\item Lock de leitura s\u00f3 retorna quando todas as mudan\u00e7as guardadas por aquele lock tiverem sido executadas no processo. \\item Lock de escrita s\u00f3 retorna quando nenhum outro processo tiver um lock, de leitura ou escrita. \\item Para ler uma vari\u00e1vel, processo deve primeiro contactar o dono atual do lock cercando a vari\u00e1vel, para pegar as mais recentes atualiza\u00e7\u00f5es. \\end{itemize} \\includegraphics[width=1\\textwidth]{images/07-10} \\end{frame} \\begin{frame}{Transa\u00e7\u00f5es} Tornam o trancamento/destrancamento de vari\u00e1veis transparente. \\end{frame} \\begin{frame}{Transa\u00e7\u00f5es} Tornam o trancamento/destrancamento de vari\u00e1veis transparente. \\end{frame} \\subsection{Modelos Centrados nos Clientes} \\begin{frame}{Modelos Centrados nos Clientes} \\begin{block}{Ideia} Evitar sincroniza\u00e7\u00e3o global focando-se no que os clientes v\u00eaem do sistema. Se para os clientes parecer consistente, tudo bem. \\end{block} \\begin{itemize} \\item Consist\u00eancia Eventual \\begin{itemize} \\item Se nenhuma escrita ocorrer em per\u00edodo consider\u00e1vel de tempo, os clientes gradualmente se sincronizar\u00e3o e ficar\u00e3o consistentes. \\item Se clientes sempre acessarem as mesmas r\u00e9plicas, ter\u00e3o impress\u00e3o de consist\u00eancia. \\end{itemize} \\item Garantias s\u00e3o do ponto de vista de \\alert{um} cliente. \\begin{itemize} \\item Leituras monot\u00f4nicas \\item Escrita monot\u00f4nicas \\item Leia suas escritas \\item Escritas seguem leituras. \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Modelo de Sistema} \\includegraphics[width=1\\textwidth]{images/07-11} Cliente pode se mover antes de sua \u00faltima opera\u00e7\u00e3o ter replicado do servidor onde estava para o novo servidor. \\end{frame} \\begin{frame}[allowframebreaks]{Leituras Monot\u00f4nicas} \\begin{block}{Garantia} Se um processo l\u00ea o valor de um item <span><span class=\"MathJax_Preview\">x</span><script type=\"math/tex\">x , qualquer leitura sucessiva de x x retornar\u00e1 o mesmo valor ou um mais recente. \\end{block} \\begin{itemize} \\item Toda vez que se conecta a um servidor de email, seu cliente l\u00ea novas mensagens, caso haja. \\item O cliente nunca esquece uma mensagem, mesmo que ainda n\u00e3o esteja no servidor conectado por \u00faltimo. \\end{itemize} \\framebreak \\begin{itemize} \\item WS($x_i$) -- opera\u00e7\u00f5es de escrita (\\emph{write set}) que levaram a vari\u00e1vel $x$ a ter o valor $x_i$. \\item WS($x_i;x_j$) -- opera\u00e7\u00f5es de escrita relativas a $x_j$ incluem opera\u00e7\u00f5es de escrita relativas a $x_i$ \\end{itemize} \\begin{itemize} \\item WS($x_i$) -- opera\u00e7\u00f5es de escrita (\\emph{write set}) que levaram a vari\u00e1vel $x$ a ter o valor $x_i$. \\item WS($x_i;x_j$) -- opera\u00e7\u00f5es de escrita relativas a $x_j$ incluem opera\u00e7\u00f5es de escrita relativas a $x_i$ \\end{itemize} \\includegraphics[width=.5\\textwidth]{images/07-12} \\end{frame} \\begin{frame}{Escritas Monot\u00f4nicas} \\begin{block}{Garantia} Se um processo escreve em item <span><span class=\"MathJax_Preview\">x</span><script type=\"math/tex\">x , ent\u00e3o esta opera\u00e7\u00e3o deve terminar antes que qualquer escrita sucessiva em x x possa ser executada pelo mesmo processo. \\end{block} \\begin{itemize} \\item Em um sistema de arquivos na rede, a escrita do conte\u00fado de um arquivo, em certa posi\u00e7\u00e3o, s\u00f3 pode ser feita se escritas anteriores j\u00e1 est\u00e3o registradas no arquivo, independentemente de o cliente contactar novo servidor de arquivos. \\end{itemize} \\includegraphics[width=.5\\textwidth]{images/07-13} \\end{frame} \\begin{frame}{Leia suas Escritas} \\begin{block}{Garantia} Se um processo escreve em item <span><span class=\"MathJax_Preview\">x</span><script type=\"math/tex\">x , ent\u00e3o leituras sucessivas no mesmo item pelo mesmo processo devem refletir tal escrita. \\end{block} \\begin{itemize} \\item Atualizar c\u00f3digo fonte de uma p\u00e1gina e exigir que o navegador carrega a nova vers\u00e3o. \\end{itemize} \\includegraphics[width=.5\\textwidth]{images/07-14} \\end{frame} \\begin{frame}{Escritas seguem Leituras} \\begin{block}{Garantia} Se um processo l\u00ea um item <span><span class=\"MathJax_Preview\">x</span><script type=\"math/tex\">x , ent\u00e3o escritas sucessivas no mesmo item s\u00f3 podem ser completadas se o mesmo reflete o valor lido anteriormente. \\end{block} \\begin{itemize} \\item S\u00f3 \u00e9 permitido enviar uma resposta a uma mensagem se a mensagem em si \u00e9 vista, independentemente do cliente ter se movimentado. \\end{itemize} \\includegraphics[width=.5\\textwidth]{images/07-15} \\end{frame} \\section{Posicionamento de R\u00e9plicas} \\begin{frame}{Posicionamento de R\u00e9plicas} Onde colocar r\u00e9plicas para conseguir melhor escalabilidade do sistema? Menor custo de comunica\u00e7\u00e3o? \\end{frame} \\begin{frame}{Posicionamento de R\u00e9plicas} \\begin{itemize} \\item Objetos (c\u00f3digo/dados) \\item Permanente \\item Sob demanda do servidor -- por exemplo em uma CDN \\item Sob demanda do cliente -- por exemplo um cache. \\end{itemize} \\includegraphics[width=\\textwidth]{images/07-17} \\end{frame} \\begin{frame}{Sob demanda do Servidor} \\begin{itemize} \\item <span><span class=\"MathJax_Preview\">Q</span><script type=\"math/tex\">Q conta acessos ao arquivo F F \\item Agrega acessos por poss\u00edvel r\u00e9plica mais pr\u00f3xima ( P P ) \\item N\u00famero de acessos acima de limiar R R , replica para P P \\item N\u00famero de acessos abaixo de D D , apaga de P P \\item D < R D < R \\item Se n\u00e3o \u00e9 alto o suficiente para replicar nem baixo o suficiente para ignorar (entre D D e R R ), considera migrar. \\end{itemize} \\includegraphics[width=.5\\textwidth]{images/07-18} \\end{frame} \\begin{frame}{Propaga\u00e7\u00e3o de Atualiza\u00e7\u00f5es} R\u00e9plicas precisam ser atualizadas.\\pause \\begin{itemize} \\item Propagar dados -- n\u00e3o reexecuta opera\u00e7\u00f5es. \\item Propagar opera\u00e7\u00f5es -- n\u00e3o copia todos os dados modificados. \\pause \\item Propagar notifica\u00e7\u00f5es -- r\u00e9plica precisa solicitar atualiza\u00e7\u00e3o.\\\\ Usado em caches. \\end{itemize} Melhor op\u00e7\u00e3o depende do custo das opera\u00e7\u00f5es, dados manipulados, e taxa de leitura/escrita dos dados. \\end{frame} \\begin{frame}{Propaga\u00e7\u00e3o de Atualiza\u00e7\u00f5es} R\u00e9plicas precisam ser atualizadas. \\begin{itemize} \\item Propagar dados \\begin{itemize} \\item raz\u00e3o leitura/escrita \u00e9 grande. \\item opera\u00e7\u00f5es s\u00e3o caras. \\end{itemize} \\item Propagar opera\u00e7\u00f5es \\begin{itemize} \\item raz\u00e3o leitura/escrita \u00e9 grande. \\item opera\u00e7\u00f5es s\u00e3o baratas. \\end{itemize} \\item Propagar notifica\u00e7\u00f5es \\begin{itemize} \\item raz\u00e3o leitura/escrita \u00e9 pequena. \\item pouco uso da rede \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Propaga\u00e7\u00e3o de Atualiza\u00e7\u00f5es} R\u00e9plicas precisam ser atualizadas. \\begin{itemize} \\item Propagar dados \\begin{itemize} \\item raz\u00e3o leitura/escrita \u00e9 grande. \\item opera\u00e7\u00f5es s\u00e3o caras. \\end{itemize} \\item Propagar opera\u00e7\u00f5es \\begin{itemize} \\item raz\u00e3o leitura/escrita \u00e9 grande. \\item opera\u00e7\u00f5es s\u00e3o baratas. \\end{itemize} \\item Propagar notifica\u00e7\u00f5es \\begin{itemize} \\item raz\u00e3o leitura/escrita \u00e9 pequena. \\item pouco uso da rede \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Proativo/Push ou Reativo/Pull} \\begin{itemize} \\item Proativo \\begin{itemize} \\item Mant\u00e9m r\u00e9plicas consistentes \\item Desnecess\u00e1rio se leitura <span><span class=\"MathJax_Preview\">&lt;&lt;</span><script type=\"math/tex\"><< escrita. \\end{itemize} \\item Reativo \\begin{itemize} \\item R\u00e9plicas s\u00f3 se tornam consistentes quando necess\u00e1rio. \\item Lento se leitura <span><span class=\"MathJax_Preview\">&gt;&gt;</span><script type=\"math/tex\">>> escrita \\end{itemize} \\end{itemize} Qual \u00e9 melhor? \\end{frame} \\begin{frame}{H\u00edbrido: Lease} \\begin{itemize} \\item R\u00e9plica se registra para receber atualiza\u00e7\u00f5es/notifica\u00e7\u00f5es por um per\u00edodo. \\item Estado sobre r\u00e9plicas \u00e9 mantido enquanto poss\u00edvel, pelo per\u00edodo contratado. \\item Em caso de sobrecarga, deixa de mandar atualiza\u00e7\u00f5es/notifica\u00e7\u00f5es. \\item Em caso de lease antigo n\u00e3o renovado, deixa de mandar atualiza\u00e7\u00f5es/notifica\u00e7\u00f5es. \\item Em caso de renova\u00e7\u00f5es frequentes, aumenta o per\u00edodo do lease. \\end{itemize} \\end{frame} \\begin{frame}{H\u00edbrido: Lease} \\begin{itemize} \\item R\u00e9plica se registra para receber atualiza\u00e7\u00f5es/notifica\u00e7\u00f5es por um per\u00edodo. \\item Estado sobre r\u00e9plicas \u00e9 mantido enquanto poss\u00edvel, pelo per\u00edodo contratado. \\item Em caso de sobrecarga, deixa de mandar atualiza\u00e7\u00f5es/notifica\u00e7\u00f5es. \\item Em caso de lease antigo n\u00e3o renovado, deixa de mandar atualiza\u00e7\u00f5es/notifica\u00e7\u00f5es. \\item Em caso de renova\u00e7\u00f5es frequentes, aumenta o per\u00edodo do lease. \\end{itemize} \\end{frame} \\section{Checkpointing \\& Recupera\u00e7\u00e3o} \\begin{frame}{Recupera\u00e7\u00e3o} Suponha que uma s\u00e9rie de erros aconteceram no sistema, e que n\u00e3o \u00e9 poss\u00edvel continuar o processamento como o sistema est\u00e1. Neste cen\u00e1rio, \u00e9 necess\u00e1rio ou avan\u00e7ar para um novo estado, livre de erros, ou retroceder a um estado correto anterior. \\end{frame} \\begin{frame}{Recupera\u00e7\u00e3o} Voltar a um estado correto parece ser a solu\u00e7\u00e3o mais f\u00e1cil. \\pause Para isso, precisamos de \\alert{Pontos de Recupera\u00e7\u00e3o} \\end{frame} \\begin{frame}{Snapshots} Podem ser usados na: \\begin{itemize} \\item Recupera\u00e7\u00e3o do sistema. \\item Coleta de lixo (remover objetos n\u00e3o referenciados em nenhum outro processo). \\item Dete\u00e7\u00e3o de deadlocks. \\item Depura\u00e7\u00e3o (pausar o sistema). \\end{itemize} \\end{frame} \\begin{frame}{Snapshots} Podem ser usados na: \\begin{itemize} \\item Recupera\u00e7\u00e3o do sistema. \\item Coleta de lixo (remover objetos n\u00e3o referenciados em nenhum outro processo). \\item Dete\u00e7\u00e3o de deadlocks. \\item Depura\u00e7\u00e3o (pausar o sistema). \\end{itemize} \\end{frame} \\begin{frame}{Pontos de Recupera\u00e7\u00e3o} Ponto de Recupera\u00e7\u00e3o v\u00e1lidos s\u00e3o a uni\u00e3o de backups locais que formam um \\alert{Estado Global Consistente}. \\end{frame} \\begin{frame}{Pontos de Recupera\u00e7\u00e3o} Ponto de Recupera\u00e7\u00e3o v\u00e1lidos s\u00e3o a uni\u00e3o de backups locais que formam um \\alert{Estado Global Consistente}. \\end{frame} \\begin{frame}{Estado Global Consistente} \\begin{block}{O qu\u00ea?} Conjunto com um estado local de cada processo no sistema tal que toda mensagem recebida no estado local de um processo tamb\u00e9m precisa fazer parte do estado local do processo remetente. \\end{block} \\begin{block}{O qu\u00ea?} Conjunto com um estado local de cada processo no sistema tal que toda mensagem recebida no estado local de um processo tamb\u00e9m precisa fazer parte do estado local do processo remetente. \\end{block} \\begin{block}{Linha de recupera\u00e7\u00e3o} O mais recente Estado Global Consistente \\end{block} \\begin{block}{Linha de recupera\u00e7\u00e3o} O mais recente Estado Global Consistente \\end{block} \\includegraphics[width=.7\\textwidth]{images/08-24} \\end{frame} \\begin{frame}{Estado Global Consistente} \\begin{block}{Comunica\u00e7\u00e3o Confi\u00e1vel} Se o sistema prov\u00ea comunica\u00e7\u00e3o confi\u00e1vel, ent\u00e3o toda mensagem enviada no estado local de um processo tamb\u00e9m precisa fazer parte do estado local do destinat\u00e1rio. \\end{block} \\includegraphics[width=.7\\textwidth]{images/08-24} \\end{frame} \\begin{frame}{Rollback em Cascata} \\begin{block}{Bad timing} Se estados locais s\u00e3o capturados na ``hora errada'', a linha de recupera\u00e7\u00e3o pode ser o estado inicial. \\end{block} \\includegraphics[width=.7\\textwidth]{images/08-25} \\end{frame} \\begin{frame}{Armazenamento em Disco} Segue a t\u00e9cnica j\u00e1 estudada. \\includegraphics[width=.7\\textwidth]{images/08-23} \\end{frame} \\subsection{Checkpointing independente} \\begin{frame}{Checkpointing independente} Cada processo faz o checkpoint local independentemente, incorrendo no risco de um \\emph{rollback} em cascata. \\begin{itemize} \\item Seja <span><span class=\"MathJax_Preview\">C_i^m</span><script type=\"math/tex\">C_i^m o m m -\u00e9simo checkpoint do processo p_i p_i . \\item Seja I_i^m I_i^m o intervalo entre C_i^{m-1} C_i^{m-1} e C_i^m C_i^m . \\item Quando o processo p_i p_i envia a mensagem no intervalo I_i^m I_i^m , envia (i,m) (i,m) em piggyback \\item Quando o processo p_j p_j recebe a mensagem no intervalo I_j^n I_j^n , grava a depend\u00eancia I_i^m \\rightarrow I_j^n I_i^m \\rightarrow I_j^n \\item A depend\u00eancia I_i^m \\rightarrow I_j^n I_i^m \\rightarrow I_j^n \u00e9 salva junto com o checkpoint C_j^n C_j^n \\end{itemize} \\end{frame} \\begin{frame}{Checkpointing independente} \\begin{block}{Restri\u00e7\u00e3o} Se o processo <span><span class=\"MathJax_Preview\">p_j</span><script type=\"math/tex\">p_j \u00e9 revertido para o estado C_j^n C_j^n , ent\u00e3o o p_i p_i n\u00e3o pode reverter para nenhum estado anterior a C_i^m C_i^m , ou n\u00e3o teria enviado as mensagens recebidas por p_j p_j 4 inclusas em C_j^n C_j^n . \\end{block} Ou \\begin{block}{Restri\u00e7\u00e3o} Se o processo $p_i$ \u00e9 revertido para o estado $C_i^{m-1}$, ent\u00e3o o $p_j$ tem que ser revertido pelo menos at\u00e9 $C_j^{n-1}$, ou incluiria mensagens ainda n\u00e3o enviadas por $p_i$. \\end{block} \\begin{block}{Restri\u00e7\u00e3o} Se o processo $p_i$ \u00e9 revertido para o estado $C_i^{m-1}$, ent\u00e3o o $p_j$ tem que ser revertido pelo menos at\u00e9 $C_j^{n-1}$, ou incluiria mensagens ainda n\u00e3o enviadas por $p_i$. \\end{block} \\pause Como implementar a recupera\u00e7\u00e3o? \\end{frame} \\begin{frame}{Caso patol\u00f3gico} \\begin{itemize} \\item $p_i$ e $p_j$ no estado inicial ($C_i^0, C_j^0$) \\item $p_i$ manda mensagens para $p_j$ ($C_i^1 \\rightarrow C_j^1$) \\item $C_j^1$ \\item $p_j$ manda mensagens para $p_i$ $C_j^2 \\rightarrow C_i^1$ \\item $C_i^1$ \\item $p_i$ manda mensagens para $p_j$ $C_i^2 \\rightarrow C_j^2$ \\item $C_j^2$ \\item $p_j$ manda mensagens para $p_i$ $C_j^3 \\rightarrow C_i^2$ \\item $C_i^2$ \\item ... \\end{itemize} \\end{frame} \\begin{frame}{Caso patol\u00f3gico} \\begin{itemize} \\item $p_i$ e $p_j$ no estado inicial ($C_i^0, C_j^0$) \\item $p_i$ manda mensagens para $p_j$ ($C_i^1 \\rightarrow C_j^1$) \\item $C_j^1$ \\item $p_j$ manda mensagens para $p_i$ $C_j^2 \\rightarrow C_i^1$ \\item $C_i^1$ \\item $p_i$ manda mensagens para $p_j$ $C_i^2 \\rightarrow C_j^2$ \\item $C_j^2$ \\item $p_j$ manda mensagens para $p_i$ $C_j^3 \\rightarrow C_i^2$ \\item $C_i^2$ \\item ... \\end{itemize} \\end{frame} \\subsection{Checkpointing coordenado} \\begin{frame}{Checkpointing coordenado} Processos se coordenam por troca de mensagem para executar checkpointing ``simultaneamente''. \\pause Qual a vantagem sobre o n\u00e3o coordenado? \\end{frame} \\begin{frame}{Bloqueio em duas fases} \\begin{itemize} \\item Um coordenador faz multicast da mensagem <code>checkpoint-request''. \\item Quando um participante recebe</code>checkpoint-request'' \\begin{itemize} \\item faz um checkpoint local, \\item para de mandar mensagens da aplica\u00e7\u00e3o \\item responde com <code>checkpoint-taken'' \\end{itemize} \\item Quando</code>checkpoint-taken'' recebido de todos os participantes, multicast <code>checkpoint-done'' \\item Quando receber</code>checkpoint-done'', retoma computa\u00e7\u00e3o normal \\end{itemize} \\begin{itemize} \\item Por qu\u00ea funciona? \\pause Impede forma\u00e7\u00e3o de depend\u00eancias circulares. \\item Todos os processos precisam participar? \\pause Somente os que dependem da recupera\u00e7\u00e3o do coordenador. \\end{itemize} \\end{frame} \\begin{frame}{Bloqueio em duas fases} Pontos negativos? \\pause \\begin{itemize} \\item Duas fases? J\u00e1 vi isso antes... \\pause Se o coordenador falha, outros processos ficam bloqueados? \\pause Timeout! \\item Como eleger outro coordenador? E se dois aparecerem juntos?\\pause Pode ser resolvido com um protocolo de elei\u00e7\u00e3o como o do RAFT. \\pause{} N\u00e3o \u00e9 garantido, mas aumenta as chances de sucesso. \\end{itemize} \\end{frame} \\begin{frame}{Bloqueio em duas fases} Pontos negativos? \\pause \\begin{itemize} \\item Duas fases? J\u00e1 vi isso antes... \\pause Se o coordenador falha, outros processos ficam bloqueados? \\pause Timeout! \\item Como eleger outro coordenador? E se dois aparecerem juntos?\\pause Pode ser resolvido com um protocolo de elei\u00e7\u00e3o como o do RAFT. \\pause{} N\u00e3o \u00e9 garantido, mas aumenta as chances de sucesso. \\end{itemize} \\end{frame} \\begin{frame}{Chandy-Lamport} 1 2 3 4 \\begin{itemize} \\item N\u00e3o interfere na aplica\u00e7\u00e3o \\item Cada processo grava snapshot independentemente \\end{itemize} \\end{frame} \\begin{frame}{Chandy-Lamport} \\begin{itemize} \\item Observador (iniciador do snapshot) \\begin{itemize} \\item Salva o pr\u00f3prio estado \\item Envia uma mensagem <code>snapshot'' aos outros processos em cada canal de sa\u00edda \\item Grava as mensagens chegando em cada canal at\u00e9 que receba uma mensagem</code>snapshot'' naquele canal. \\end{itemize} \\item Um processo p p que receba snapshot'' de um processo $q$ \\begin{itemize} \\item grava estado local $S_p$ \\item grava estado do canal $C_{q,p} =\\emptyset$ \\item Envia uma mensagem snapshot'' aos outros processos em cada canal de sa\u00edda \\item Grava as mensagens chegando em cada canal at\u00e9 que receba uma mensagem snapshot'' naquele canal (excluindo $C_{q,p}$) \\end{itemize} \\item Protocolo termina para o processo $p$ quando tiver recebido marcador snapshot'' em cada um de seus canais. \\item O estado global consiste dos snapshots + estado em cada um dos canais. \\pause \\item Exige canais FIFO \\end{itemize} 1 \\url{https://youtu.be/RQquDTYkHKY?t=383} \\end{frame} \\subsection{Message Logging} \\begin{frame}{Message Logging} Em vez de checkpoints frequentes, crie um log da comunica\u00e7\u00e3o e o re-execute a partir do \u00faltimo checkpoint. 1 2 3 4 5 6 \\begin{block}{Ideia} A computa\u00e7\u00e3o \u00e9 determinada pela troca de mensagens (eventos n\u00e3o determin\u00edsticos). Ao se enviar a mesma mensagem a partir de um certo estado, a computa\u00e7\u00e3o desencadeada \u00e9 sempre a mesma. \\end{block} \\pause Realista este modelo? H\u00e1 outros eventos n\u00e3o determin\u00edsticos no sistema? \\end{frame} \\begin{frame}{Message Logging} 1 \\includegraphics[width=\\textwidth]{images/08-26} \\end{frame} \\begin{frame}{Nota\u00e7\u00e3o} \\begin{itemize} \\item $Hdr(m)$ \\begin{itemize} \\item Cabe\u00e7alho da mensagem $m$ contendo fonte, destino, n\u00famero de sequ\u00eancia e n\u00famero de entrega. \\item O cabe\u00e7alho cont\u00e9m a informa\u00e7\u00e3o necess\u00e1ria para reenviar e re-receber a mensagem na ordem certa (dados devem ser reproduzidos para aplica\u00e7\u00e3o). \\item A mensagem $m$ \u00e9 est\u00e1vel se $Hdr(m)$ estiver em mem\u00f3ria est\u00e1vel. \\end{itemize} \\item $Dep(m)$ o conjunto de processos a quem $m$ ou mensagens que dependem de $m$ foram entregues. \\item $Copy(m)$: o conjunto de processos que tem uma c\u00f3pia de $Hdr(m)$ em mem\u00f3ria vol\u00e1til. \\end{itemize} \\end{frame} \\begin{frame}{Nota\u00e7\u00e3o} \\begin{itemize} \\item $Hdr(m)$ \\begin{itemize} \\item Cabe\u00e7alho da mensagem $m$ contendo fonte, destino, n\u00famero de sequ\u00eancia e n\u00famero de entrega. \\item O cabe\u00e7alho cont\u00e9m a informa\u00e7\u00e3o necess\u00e1ria para reenviar e re-receber a mensagem na ordem certa (dados devem ser reproduzidos para aplica\u00e7\u00e3o). \\item A mensagem $m$ \u00e9 est\u00e1vel se $Hdr(m)$ estiver em mem\u00f3ria est\u00e1vel. \\end{itemize} \\item $Dep(m)$ o conjunto de processos a quem $m$ ou mensagens que dependem de $m$ foram entregues. \\item $Copy(m)$: o conjunto de processos que tem uma c\u00f3pia de $Hdr(m)$ em mem\u00f3ria vol\u00e1til. \\end{itemize} \\end{frame} \\begin{frame}{\u00d3rf\u00e3os} \\begin{block}{Defini\u00e7\u00e3o} Se <span><span class=\"MathJax_Preview\">C</span><script type=\"math/tex\">C \u00e9 um conjunto de processos falhos, ent\u00e3o Q\\not\\in C Q\\not\\in C \u00e9 um \u00f3rf\u00e3o se existe uma mensagem m m tal que Q \\in Dep(m) Q \\in Dep(m) e Copy(m)\\subseteq C Copy(m)\\subseteq C \\end{block} 1 Se os processos em $C$ forem reiniciados, ent\u00e3o a computa\u00e7\u00e3o seguir\u00e1 um caminho possivelmente distinto do que levou $Q$ a receber $m$ ou um mensagem causalmente dependente de $m$. \\end{frame} \\begin{frame}{Protocolo Pessimista} Para cada mensagem m m n\u00e3o est\u00e1vel, h\u00e1 no m\u00e1ximo um processo dependente em m m ( Dep(m) \\leq 1 Dep(m) \\leq 1 ) 1 2 3 4 5 \\pause Uma mensagem n\u00e3o est\u00e1vel, no protocolo pessimista, deve ser estabilizada antes do envio da pr\u00f3xima mensagem. \\pause Toda mensagem \u00e9 precedida por uma escrita em disco. \\end{frame} \\begin{frame}{Protocolo Otimista} Para cada mensagem m m n\u00e3o est\u00e1vel, ent\u00e3o devemos garantir que se Copy(m) \\subseteq C Copy(m) \\subseteq C , ent\u00e3o \\emph{eventually} Dep(m) \\subseteq C Dep(m) \\subseteq C , onde C C \u00e9 o conjunto de processos que falharam. 1 2 3 4 \\pause Para garantir que $Dep(m) \\subseteq C$, fazemos um rollback de cada \u00f3rf\u00e3o $Q$ at\u00e9 que $Q \\not\\in Dep(m)$ \\pause Isto \u00e9, for\u00e7amos $Q$ a ser recuperado mesmo que n\u00e3o tenha falhado. \\end{frame} \\section{Bancos de Dados} \\subsection{Transa\u00e7\u00f5es} Falar em bancos de dados distribu\u00eddos implica falar em bancos transacionais e P2P. \\begin{frame}{Opera\u00e7\u00f5es At\u00f4micas} Falar em bancos de dados distribu\u00eddos implica falar em bancos Relacionais/Transactionais e P2P. Falar em bancos transacionais, implica falar ACID! \\end{frame} \\begin{frame}{Opera\u00e7\u00f5es At\u00f4micas} No modelo de M\u00e1quinas de Estados Replicadas, opera\u00e7\u00f5es s\u00e3o enviadas para as r\u00e9plicas, que as executam em ordem, deterministicamente e tamb\u00e9m \\emph{atomicamente}. Isto \u00e9, cada opera\u00e7\u00e3o \u00e9 ou executada independentemente das outras e por completo, ou n\u00e3o \u00e9 executada. \\end{frame} \\begin{frame}{Opera\u00e7\u00f5es At\u00f4micas} No modelo de M\u00e1quinas de Estados Replicadas, opera\u00e7\u00f5es s\u00e3o enviadas para as r\u00e9plicas, que as executam em ordem, deterministicamente e tamb\u00e9m \\emph{atomicamente}. Isto \u00e9, cada opera\u00e7\u00e3o \u00e9 ou executada independentemente das outras e por completo, ou n\u00e3o \u00e9 executada. \\end{frame} \\begin{frame}{Conjuntos de Opera\u00e7\u00f5es} Mesmo com Opera\u00e7\u00f5es At\u00f4micas, frequentemente queremos/precisamos agrupar opera\u00e7\u00f5es tal que \\begin{itemize} \\item \\alert{todas ou nenhuma} sejam executadas \\item mesmo na presen\u00e7a de falhas. \\end{itemize} \\pause \\emph{Atomicidade}. \\end{frame} \\begin{frame}{Mem\u00f3ria Est\u00e1vel} Para que os efeitos de opera\u00e7\u00f5es n\u00e3o sejam esquecidos, eles precisam ser armazenados em \\emph{mem\u00f3ria est\u00e1vel} como \\begin{itemize} \\item HD -- Hard Drives \\item SSD -- Solid State Drives \\item NVRAM -- Non Volatile Ram \\end{itemize} \\pause \\emph{Durabilidade}. \\end{frame} \\begin{frame}{Transa\u00e7\u00f5es} \\begin{itemize} \\item \\alert{Atomicidade} -- Todas as opera\u00e7\u00f5es ou nenhuma. \\item Consist\u00eancia -- Os dados transitam de estado v\u00e1lido para estado v\u00e1lido. \\item Isolamento -- Transa\u00e7\u00f5es n\u00e3o interferem umas nas outras. \\item \\alert{Durabilidade} -- Efeitos n\u00e3o s\u00e3o esquecidos. \\end{itemize} \\end{frame} \\begin{frame}{Transa\u00e7\u00f5es} \\begin{itemize} \\item \\alert{Atomicidade} -- Todas as opera\u00e7\u00f5es ou nenhuma. \\item Consist\u00eancia -- Os dados transitam de estado v\u00e1lido para estado v\u00e1lido. \\item Isolamento -- Transa\u00e7\u00f5es n\u00e3o interferem umas nas outras. \\item \\alert{Durabilidade} -- Efeitos n\u00e3o s\u00e3o esquecidos. \\end{itemize} \\end{frame} \\begin{frame}{O Banco} Conta C \\begin{itemize} \\item C.\\alert{get}Saldo() \\item C.\\alert{set}Saldo(montante) \\end{itemize} \\end{frame} \\begin{frame}{O Banco} Conta C \\begin{itemize} \\item C.\\alert{get}Saldo() \\item C.\\alert{set}Saldo(montante) \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Transa\u00e7\u00e3o} Mova 10\\% do saldo de X, de Y para X. \\begin{verbatim} T1: a -> b sB = b.getSaldo() b.setSaldo(sB*1.1) sA = a.getSaldo() a.setSaldo(sA-sB*0.1) \\end{verbatim} \\end{frame} \\begin{frame}[fragile]{Transa\u00e7\u00e3o} Mova 10\\% do saldo de X, de Y para X. \\begin{verbatim} T1: a -> b sB = b.getSaldo() b.setSaldo(sB*1.1) sA = a.getSaldo() a.setSaldo(sA-sB*0.1) \\end{verbatim} \\end{frame} \\begin{frame}[fragile]{Transa\u00e7\u00e3o} Qual o saldo total das contas? \\begin{verbatim} T2: a + b sA = a.getSaldo() sB = b.getSaldo() sT = sA + sB \\end{verbatim} \\end{frame} \\begin{frame}[fragile]{Transa\u00e7\u00e3o} Qual o saldo total das contas? \\begin{verbatim} T2: a + b sA = a.getSaldo() sB = b.getSaldo() sT = sA + sB \\end{verbatim} \\end{frame} \\begin{frame}[fragile]{Execu\u00e7\u00e3o Concorrente} Execu\u00e7\u00e3o concorrente de T1 e T2? \\begin{verbatim} T1 T2 sB = b.getSaldo() sA = a.getSaldo() b.setSaldo(sB*1.1) sB = b.getSaldo() sA = a.getSaldo() a.setSaldo(sA-sB*0.1) sT = sA+sB \\end{verbatim} \\pause Dados n\u00e3o finais ``vazaram''. \\emph{Dirty Read}. \\pause Falta \\emph{Isolamento}. \\end{frame} Pode levar a mais que um resultado errado. Pode deixar o BD em estado inv\u00e1lido. \\begin{frame}[fragile]{Execu\u00e7\u00e3o Concorrente} Mova 10\\% do saldo de X, de Y para X. \\begin{verbatim} T1 T1 sB = b.getSaldo() sB = b.getSaldo() b.setSaldo(sB*1.1) b.setSaldo(sB*1.1) sA = a.getSaldo() a.setSaldo(sA-sB*0.1) sA = a.getSaldo() a.setSaldo(sA-sB*0.1) \\end{verbatim} \\pause \\verb|sB*0.1| foi perdido. \\emph{Lost Update} \\pause Perdeu \\emph{Consist\u00eancia} \\end{frame} \\begin{frame}{Solu\u00e7\u00e3o?!} Para garantir Isolamento \\begin{itemize} \\item Execu\u00e7\u00f5es dos conjuntos n\u00e3o podem se sobrepor. \\item Execute um conjunto de opera\u00e7\u00f5es por vez, serialmente! \\item Garantir\u00e1 tamb\u00e9m Consist\u00eancia \\end{itemize} \\pause \\alert{Que tal?} \\pause Limite a concorr\u00eancia de transa\u00e7\u00f5es. \\end{frame} \\subsection{Equival\u00eancia Serial} \\begin{frame}{Concorr\u00eancia} Al\u00e9m de ACID, queremos o m\u00e1ximo de \\emph{concorr\u00eancia} para garantir o melhor \\emph{desempenho}.\\pause Queremos uma execu\u00e7\u00e3o das transa\u00e7\u00f5es semelhante \u00e0 serial, mas com o desempenho de concorrente.\\pause N\u00e3o queremos uma execu\u00e7\u00e3o serial, mas uma \\alert{Equival\u00eancia Serial}, isto \u00e9, que os efeitos das transa\u00e7\u00f5es, executadas concorrentemente, sejam equivalentes aos de alguma execu\u00e7\u00e3o serial destas transa\u00e7\u00f5es. \\end{frame} \\begin{frame}{Equival\u00eancia Serial} Preocupe-se com Opera\u00e7\u00f5es Conflitantes \\begin{itemize} \\item Transa\u00e7\u00f5es diferentes \\item Uma \u00e9 escrita \\item Mesmo dado \\end{itemize} Duas execu\u00e7\u00f5es (de transa\u00e7\u00f5es) s\u00e3o equivalentes se \\begin{itemize} \\item as transa\u00e7\u00f5es tem as mesmas opera\u00e7\u00f5es \\item quaisquer duas opera\u00e7\u00f5es conflitantes s\u00e3o executadas na mesma ordem nas duas execu\u00e7\u00f5es \\end{itemize} Uma execu\u00e7\u00e3o tem Equival\u00eancia Serial se \u00e9 equivalente a alguma execu\u00e7\u00e3o serial das transa\u00e7\u00f5es. \\end{frame} \\begin{frame}{Equival\u00eancia Serial} Escalone opera\u00e7\u00f5es concorrentemente, de forma a obter o melhor desempenho, mas de forma a manter Equival\u00eancia Serial. \\end{frame} \\begin{frame}{Equival\u00eancia Serial} Escalone opera\u00e7\u00f5es concorrentemente, de forma a obter o melhor desempenho, mas de forma a manter Equival\u00eancia Serial. \\end{frame} Esta defini\u00e7\u00e3o dif\u00edcil de ser testada. Algo mais simples? \\begin{frame}{Equival\u00eancia Serial} \\begin{itemize} \\item Como demonstrar Equival\u00eancia Serial? \\item Tenho que testar todas as execu\u00e7\u00f5es seriais e ver se uma casa com o que planejo fazer? \\item \u00c9 caro fazer este planejamento. \u00c9 mais eficiente garantir por constru\u00e7\u00e3o. \\end{itemize} \\end{frame} \\begin{frame}{Equival\u00eancia Serial} \\begin{itemize} \\item Como demonstrar Equival\u00eancia Serial? \\item Tenho que testar todas as execu\u00e7\u00f5es seriais e ver se uma casa com o que planejo fazer? \\item \u00c9 caro fazer este planejamento. \u00c9 mais eficiente garantir por constru\u00e7\u00e3o. \\end{itemize} \\end{frame} \\begin{frame}{Equival\u00eancia Serial} Simplifica\u00e7\u00e3o: A execu\u00e7\u00e3o de duas transa\u00e7\u00f5es tem Equival\u00eancia Serial se todos os pares de opera\u00e7\u00f5es conflitantes entre as transa\u00e7\u00f5es s\u00e3o executados na mesma ordem. \\end{frame} \\begin{frame}{Equival\u00eancia Serial} Simplifica\u00e7\u00e3o: A execu\u00e7\u00e3o de duas transa\u00e7\u00f5es tem Equival\u00eancia Serial se todos os pares de opera\u00e7\u00f5es conflitantes entre as transa\u00e7\u00f5es s\u00e3o executados na mesma ordem. \\end{frame} \\begin{frame}[fragile]{Lost Update} Mova 10\\% do saldo de X, de Y para X. \\begin{verbatim} a -> b c -> b s = b.getSaldo() [1] [2]s = b.getSaldo() [3] b.setSaldo(s*1.1) b.setSaldo(s*1.1)[4] c.setSaldo(s*0.1) a.setSaldo(s*0.1) \\end{verbatim} Conflitos: 1x3: \\rightarrow \\rightarrow , 2x4: \\leftarrow \\leftarrow , 3x4: \\leftarrow \\leftarrow \\pause Consist\u00eancia -- \\verb|s*0.1| foi perdido \\end{frame} \\begin{frame}[fragile]{Lost Update} Mova 10\\% do saldo de X, de Y para X. \\begin{verbatim} a -> b c -> b [2] s = b.getSaldo() [3] b.setSaldo(s*1.1) s = b.getSaldo() [1] b.setSaldo(s*1.1)[4] c.setSaldo(s*0.1) a.setSaldo(saldo*0.1) \\end{verbatim} Conflitos: 1x3: \\leftarrow \\leftarrow , 2x4: \\leftarrow \\leftarrow , 3x4: \\leftarrow \\leftarrow \\end{frame} \\begin{frame}[fragile]{Dirty Read} Saldo total? \\begin{verbatim} a -> b a -> b s = b.getSaldo() b.setSaldo(s*1.1) b.setSaldo(s*1.1) a.saque(s*0.1) s = b.getSaldo() b.setSaldo(s*1.1) b.setSaldo(s*1.1) a.saque(s*0.1) \\end{verbatim} \\pause Tem Equival\u00eancia Serial. \\pause Exceto se \\begin{verbatim} abortTransaction() \\end{verbatim} \\pause Nenhuma transa\u00e7\u00e3o que fez uma dirty read pode comitar. Logo, aborte a transa\u00e7\u00e3o da direita. \\end{frame} \\begin{frame}{Aborto em Cascata} T1 faz uma escrita. T2 l\u00ea o que T1 escreveu e faz outra escrita. T3 l\u00ea o que T2 escreveu e faz outra escrita. T4 l\u00ea o que... \\alert{T1 aborta.} \\end{frame} \\begin{frame}{Aborto em Cascata} T1 faz uma escrita. T2 l\u00ea o que T1 escreveu e faz outra escrita. T3 l\u00ea o que T2 escreveu e faz outra escrita. T4 l\u00ea o que... \\alert{T1 aborta.} \\end{frame} \\begin{frame}{Dirty Read} Como lidar? \\begin{itemize} \\item Suspenda a transa\u00e7\u00e3o quando esta fizer dirty read. \\item Se transa\u00e7\u00e3o foi abortada, todas as suspensas (que leram dela) devem ser abortadas. \\item Repita passo anterior. \\end{itemize} \\pause E se evitarmos dirty reads em vez de tratarmos? \\pause \\begin{itemize} \\item Suspenda antes de fazer dirty read. \\item Quando transa\u00e7\u00e3o for terminada, continue execu\u00e7\u00e3o. \\end{itemize} \\pause Abordagem leva a menor concorr\u00eancia. \\end{frame} Para nos permitir identificar transa\u00e7\u00f5es, vamos usar o seguinte framework para oper\u00e1-las. \\begin{frame}{Transa\u00e7\u00f5es} \\begin{itemize} \\item beginTransaction() \\item opera\u00e7\u00f5es \\item commitTransaction(): Ok/NOk \\item abortTransaction() \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Escrita Prematura} \\begin{verbatim} Saldo inicial: 100 a.setSaldo(105) a.setSaldo(110) commitTransaction() abortTransaction() \\end{verbatim} A transa\u00e7\u00e3o da direita n\u00e3o le, apenas escreve. O resultado? O saldo volta para 100. \\end{frame} \\begin{frame}{Strict Execution} \\begin{itemize} \\item Leituras e Escritas devem ser atrasadas at\u00e9 que todas as transa\u00e7\u00f5es anteriores que contenham escritas sejam commitadas ou abortadas. \\item Execu\u00e7\u00e3o estrita garante Isolamento. \\item Como implementar eficientemente? \\end{itemize} \\end{frame} \\begin{frame}{Strict Execution} \\begin{itemize} \\item Leituras e Escritas devem ser atrasadas at\u00e9 que todas as transa\u00e7\u00f5es anteriores que contenham escritas sejam commitadas ou abortadas. \\item Execu\u00e7\u00e3o estrita garante Isolamento. \\item Como implementar eficientemente? \\end{itemize} \\end{frame} \\subsection{Controle de Concorr\u00eancia} \\begin{frame}{Como} \\begin{itemize} \\item locks (pessimista): simples, mas problem\u00e1tico \\item multi-vers\u00e3o (otimista): custo se h\u00e1 muitos conflitos \\item timestamp: \\alert{time} \u00e9 algo complicado \\end{itemize} \\end{frame} \\begin{frame}{Como} \\begin{itemize} \\item locks (pessimista): simples, mas problem\u00e1tico \\item multi-vers\u00e3o (otimista): custo se h\u00e1 muitos conflitos \\item timestamp: \\alert{time} \u00e9 algo complicado \\end{itemize} \\end{frame} \\subsubsection{Locks} \\begin{frame}{Locks} Tranque todos os objetos para que outras transa\u00e7\u00f5es n\u00e3o consigam ler ou escrev\u00ea-los. Destranque quando n\u00e3o mais necess\u00e1rios. Sofre de dirty reads e escritas prematuras. \\begin{block}{Strict Two Phase Locking} \\begin{itemize} \\item tranque quando necess\u00e1rio \\item destranque ao final da transa\u00e7\u00e3o \\item termine a transa\u00e7\u00e3o \\end{itemize} \\end{block} Como aumentar a concorr\u00eancia? \\end{frame} \\begin{frame}{Read-Write Locks} \\begin{itemize} \\item dois n\u00edveis de acesso \\item m\u00faltiplos leitores \\item \u00fanico escritor \\item reads por ser transformados em locks \\item writes \\alert{n\u00e3o} podem se transformados em reads (violaria Strict Two-Phase Locking) \\end{itemize} \\end{frame} \\begin{frame}{Read-Write Locks} \\begin{itemize} \\item dois n\u00edveis de acesso \\item m\u00faltiplos leitores \\item \u00fanico escritor \\item reads por ser transformados em locks \\item writes \\alert{n\u00e3o} podem se transformados em reads (violaria Strict Two-Phase Locking) \\end{itemize} \\end{frame} \\begin{frame}{Variantes} \\begin{itemize} \\item Two-version locking (read/write/commit) % Similar idea but now with: read, write and commit locks. % \\begin{itemize} % \\item A read lock is allowed unless a commit lock is taken. % \\item One write lock is allowed if no commit lock is taken (i.e. even if read locks are taken) % \\item Written values are held local to the transaction and are not visible before commit. % \\item A write lock can be promoted to a commit lock if there are no read locks. % \\item When a transaction commits it tries to promote write locks to commit locks. % \\end{itemize} \\item Lock hier\u00e1rquico (granularidades variadas) % locks of mixed granularity. % \\begin{itemize} % \\item Small locks increase concurrency % \\item Large locks decrease overhead % \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Variantes} \\begin{itemize} \\item Two-version locking (read/write/commit) % Similar idea but now with: read, write and commit locks. % \\begin{itemize} % \\item A read lock is allowed unless a commit lock is taken. % \\item One write lock is allowed if no commit lock is taken (i.e. even if read locks are taken) % \\item Written values are held local to the transaction and are not visible before commit. % \\item A write lock can be promoted to a commit lock if there are no read locks. % \\item When a transaction commits it tries to promote write locks to commit locks. % \\end{itemize} \\item Lock hier\u00e1rquico (granularidades variadas) % locks of mixed granularity. % \\begin{itemize} % \\item Small locks increase concurrency % \\item Large locks decrease overhead % \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Lock -- Por qu\u00ea evitar?} \\begin{itemize} \\item Pessimista \\item Overhead mesmo se n\u00e3o h\u00e1 conflitos \\item Ou restritivo ou risco de deadlock \\item Lock liberado somente no final, para evitar dirty reads/escrita prematura. \\end{itemize} \\end{frame} \\begin{frame}{Lock -- Por qu\u00ea evitar?} \\begin{itemize} \\item Pessimista \\item Overhead mesmo se n\u00e3o h\u00e1 conflitos \\item Ou restritivo ou risco de deadlock \\item Lock liberado somente no final, para evitar dirty reads/escrita prematura. \\end{itemize} \\end{frame} \\subsubsection{Otimista} \\begin{frame}{Abordagem mais otimista?} \\begin{itemize} \\item Modifique uma c\u00f3pia privada dos dados \\item Na hora de terminar a transa\u00e7\u00e3o, verifique se nenhuma transa\u00e7\u00e3o modificou o dado, isto \u00e9, \\item se a c\u00f3pia privada ainda \u00e9 v\u00e1lida. \\item Substitua a c\u00f3pia p\u00fablica pela privada \\end{itemize} Esta t\u00e9cnica \u00e9 conhecida como \\emph{deferred update}, pois o Update dos dados s\u00f3 ocorre no final, se a Valida\u00e7\u00e3o passar. \\end{frame} \\begin{frame}{Abordagem Otimista} \\begin{itemize} \\item Baixo overhead, se n\u00e3o houver conflitos \\item Valida\u00e7\u00e3o \u00e9 r\u00e1pida \\item Update \u00e9 simples \\end{itemize} Se houver muitos conflitos, o trabalho da transa\u00e7\u00e3o \u00e9 todo desperdi\u00e7ado. \\end{frame} \\begin{frame}{Valida\u00e7\u00e3o} Read e Write sets de quaisquer transa\u00e7\u00f5es concorrentes deve ser disjuntos. \\begin{itemize} \\item T1 n\u00e3o deve ler dados escritos por T2 \\item T2 n\u00e3o deve ler dados escritos por T1 \\item T1/T2 n\u00e3o deve escrever dados escritos por T2/T1 \\end{itemize} \\includegraphics[width=.7\\textwidth]{images/trans_validation} \\end{frame} \\begin{frame}{Valida\u00e7\u00e3o} Read e Write sets de quaisquer transa\u00e7\u00f5es concorrentes deve ser disjuntos. \\begin{itemize} \\item T1 n\u00e3o deve ler dados escritos por T2 \\item T2 n\u00e3o deve ler dados escritos por T1 \\item T1/T2 n\u00e3o deve escrever dados escritos por T2/T1 \\end{itemize} \\includegraphics[width=.7\\textwidth]{images/trans_validation} \\end{frame} \\begin{frame}{Backward Validation} \\begin{itemize} \\item T1: transa\u00e7\u00e3o sendo validada \\item T2: transa\u00e7\u00e3o j\u00e1 comitada. \\item T1 n\u00e3o deve ler dados escritos por T2 \\end{itemize} Em caso de n\u00e3o valida\u00e7\u00e3o, aborte T1 \\includegraphics[width=.7\\textwidth]{images/trans_validation} \\end{frame} \\begin{frame}{Forward Validation} \\begin{itemize} \\item T1: transa\u00e7\u00e3o sendo validada \\item T2: transa\u00e7\u00e3o ainda em execu\u00e7\u00e3o \\item T2 n\u00e3o deve ler dados escritos por T1 \\end{itemize} Em caso de n\u00e3o valida\u00e7\u00e3o, aborte T1 \\includegraphics[width=.7\\textwidth]{images/trans_validation} \\pause, possivelmente nunca terminando uma transa\u00e7\u00e3o.\\ Ou aborte T2. \\end{frame} \\subsubsection{Timestamp} \\begin{frame}{Timestamping} \\begin{itemize} \\item Transa\u00e7\u00e3o recebe um \\emph{timestamp} no in\u00edcio \\item Opera\u00e7\u00f5es s\u00e3o validadas na execu\u00e7\u00e3o \\begin{itemize} \\item leia somente se nenhuma transa\u00e7\u00e3o com maior timestamp tiver escrito e comitado \\item escreva somente se nenhuma transa\u00e7\u00e3o com maior timestamp tiver lido e comitado \\end{itemize} \\item Transa\u00e7\u00f5es ``executam na ordem do timestamp'' \\end{itemize} Como implementar? \\end{frame} \\begin{frame}{Como implementar} \\begin{itemize} \\item Objetos tem valores \\emph{tentativos}, n\u00e3o comitados \\item Objetos tem vers\u00f5es em que foram escritos \\item em que foram comitados \\item e em que foram lidos 1 2 3 \\includegraphics[width=.9\\textwidth]{images/timestamp1} \\item Consist\u00eancia \u00e9 testado na execu\u00e7\u00e3o da opera\u00e7\u00e3o \\end{itemize} \\end{frame} \\begin{frame}{Como implementar -- Escrita} \\begin{itemize} \\item Escritas tem sucesso somente se vers\u00e3o sendo escrita \u00e9 maior que vers\u00f5es lidas \\item Se vers\u00e3o sendo escrita \u00e9 menor que vers\u00e3o j\u00e1 escrita, ignore e continue 1 \\includegraphics[width=.9\\textwidth]{images/timestamp1} \\end{itemize} \\end{frame} \\begin{frame}{Como implementar -- Leitura} \\begin{itemize} \\item Leitura com vers\u00e3o v tem sucesso se maior vers\u00e3o \u00e9 comitada e menor que v ou alguma n\u00e3o comitada \\item Leitura com vers\u00e3o v \u00e9 suspensa se maior vers\u00e3o \u00e9 n\u00e3o comitada e menor que v \\includegraphics[width=.9\\textwidth]{images/timestamp2} \\end{itemize} \\end{frame} \\begin{frame}{Como implementar -- Leitura} \\begin{itemize} \\item Leitura com vers\u00e3o v tem sucesso se maior vers\u00e3o \u00e9 comitada e menor que v ou alguma n\u00e3o comitada \\item Leitura com vers\u00e3o v \u00e9 suspensa se maior vers\u00e3o \u00e9 n\u00e3o comitada e menor que v \\includegraphics[width=.9\\textwidth]{images/timestamp2} \\end{itemize} \\end{frame} \\begin{frame}{Como implementar} \\begin{itemize} \\item Leitura com vers\u00e3o v \u00e9 abortada se maior vers\u00e3o comitada \u00e9 maior que v \\includegraphics[width=.9\\textwidth]{images/timestamp3} \\end{itemize} \\end{frame} \\begin{frame}{Como implementar} \\begin{itemize} \\item Leitura com vers\u00e3o v \u00e9 abortada se maior vers\u00e3o comitada \u00e9 maior que v \\includegraphics[width=.9\\textwidth]{images/timestamp3} \\end{itemize} \\end{frame} \\begin{frame}{Refer\u00eancias} Inspirado nas notas de aula de Johan Montelius e Vladimir Vlassov, da disciplina ID2201 Distributed Systems, KTH Royal Institute of Technology. Imagens copiadas descaradamente de seus slides. Tamb\u00e9m aqui, \\url{ https://www.cs.ucy.ac.cy/~dzeina/courses/epl446/lectures/16.pdf } \\end{frame} \\section{Bancos de Dados Distribu\u00eddos} \\subsection{Transa\u00e7\u00f5es Distribu\u00eddas} \\begin{frame}{Bancos de Dados Transacionais Distribu\u00eddos} Agora que relembramos como transa\u00e7\u00f5es funcionam e temos uma no\u00e7\u00e3o de como podem ser implementadas em um sistema centralizado, vamos tentar entender como faz\u00ea-lo em um sistema distribu\u00eddo. \\begin{itemize} \\item M\u00faltiplos servidores \\item Transa\u00e7\u00f5es em cada servidor \\item Transa\u00e7\u00f5es distribu\u00eddas \\item Como obter Equival\u00eancia Serial em transa\u00e7\u00f5es distribu\u00eddas \\end{itemize} \\end{frame} \\begin{frame}{Transa\u00e7\u00e3o Distribu\u00edda} \\begin{itemize} \\item beginTransaction(): tid (transaction id) \\item operation(tid,op) \\item endTransaction(tid): Ok/NOk \\item abortTransaction(tid) \\end{itemize} \\end{frame} \\begin{frame}{Transa\u00e7\u00e3o Distribu\u00edda} \\begin{itemize} \\item beginTransaction(): tid (transaction id) \\item operation(tid,op) \\item endTransaction(tid): Ok/NOk \\item abortTransaction(tid) \\end{itemize} \\end{frame} \\begin{frame}{Transa\u00e7\u00f5es Distribu\u00eddas} \\begin{itemize} \\item Cliente \\item Servidor: \\emph{resource managers} \\item Servidor: \\emph{transaction monitor/manager} \\end{itemize} \\begin{center} \\includegraphics[width=.55\\textwidth]{images/01-10} \\end{center} \\begin{center} \\includegraphics[width=.55\\textwidth]{images/01-10} \\end{center} \\begin{itemize} \\item beginTransaction(): tid (transaction id) \\item operation(tid,op) \\item endTransaction(tid): Ok/NOk \\item abortTransaction(tid) \\end{itemize} \\end{frame} \\begin{frame}{Transa\u00e7\u00f5es Distribu\u00eddas} Localmente, cada BD funciona como um sistema centralizado normal, usando abordagens otimistas ou pessimista para garantir consist\u00eancia. O grande problema no BD distribu\u00eddo \u00e9 garantir o \\emph{acordo} na termina\u00e7\u00e3o. \\end{frame} \\subsection{Comprometimento Distribu\u00eddo} \\begin{frame}{Atomicidade} \\begin{block}{O problema...} \\begin{itemize} \\item Transa\u00e7\u00e3o <span><span class=\"MathJax_Preview\">T</span><script type=\"math/tex\">T acessa recursos nos Resource Managers (RM) \\item Terminar com sucessos T T em todos os RM -- commit -- ou \\item abortar T T em todos os RM \\item ainda que enlaces de comunica\u00e7\u00e3o, n\u00f3s e RM falhem, antes ou durante a termina\u00e7\u00e3o da transa\u00e7\u00e3o. \\end{itemize} \\end{block} \\alert{Comprometimento Distribu\u00eddo} \\end{frame} \\begin{frame}{2PC} \\begin{itemize} \\item Participante -- Resource Manager ``tocados'' pela transa\u00e7\u00e3o \\item Coordenador -- Transaction Manager \\end{itemize} \\end{frame} \\begin{frame}{2PC} \\begin{itemize} \\item Participante -- Resource Manager ``tocados'' pela transa\u00e7\u00e3o \\item Coordenador -- Transaction Manager \\end{itemize} \\end{frame} \\begin{frame}{Premissas} \\begin{itemize} \\item Cliente decide quando iniciar o commit. \\item Cada Participante faz commit ou abort da transa\u00e7\u00e3o local.\\\\ Pode retornar Ok ou NOk. \\item Coordenador n\u00e3o come\u00e7a a commit at\u00e9 que a $T$ tenha terminado em todos os participantes e cliente tenha solicitado. \\item Participantes falham por parada. \\end{itemize} \\end{frame} \\begin{frame}{Premissas} \\begin{itemize} \\item Cliente decide quando iniciar o commit. \\item Cada Participante faz commit ou abort da transa\u00e7\u00e3o local.\\\\ Pode retornar Ok ou NOk. \\item Coordenador n\u00e3o come\u00e7a a commit at\u00e9 que a $T$ tenha terminado em todos os participantes e cliente tenha solicitado. \\item Participantes falham por parada. \\end{itemize} \\end{frame} \\subsubsection{1 Phase Commit -- 1PC} \\begin{frame}[fragile]{Comprometimento em 1 Fase} Aka 1-Phase Commit -- 1PC \\begin{itemize} \\item Cliente envia \\verb|endTransaction(tid)| para o Coordenador \\item Coordenador envia mensagem para participantes ``comitarem'' \\pause \\item E se um participante retornar NOk? % enquanto outros retornam Ok? \\item E se um participante n\u00e3o responder? \\end{itemize} \\end{frame} \\subsubsection{2-PC} \\begin{frame}[fragile]{Comprometimento em 2 Fases} Aka 2-Phase Commit -- 2PC \\begin{itemize} \\item Cliente envia \\verb|endTransaction(tid)| para o coordenador \\item coordenador envia mensagem para participantes se prepararem para terminar \\item coordenador espera que todos se preparem ou digam se n\u00e3o podem \\item coordenador envia \\alert{ordem} de termina\u00e7\u00e3o \\end{itemize} \\end{frame} \\begin{frame}{Comprometimento} \\begin{itemize} \\item Um Participante <span><span class=\"MathJax_Preview\">P</span><script type=\"math/tex\">P est\u00e1 pronto para commit se tiver todos os valores modificados por T T em mem\u00f3ria est\u00e1vel e nenhuma raz\u00e3o para abortar a transa\u00e7\u00e3o (outras transa\u00e7\u00f5es conflituosas fizeram commit?) \\item O Coordenador n\u00e3o pode come\u00e7ar a termina\u00e7\u00e3o at\u00e9 que todos os participantes estejam prontos. \\item Se algum participante aborta, o Coordenador deve abortar. \\end{itemize} Problema de Acordo, mas n\u00e3o igual ao Consenso. \\end{frame} \\begin{frame}{2PC -- O Protocolo} \\begin{itemize} \\item Fase 1 \\begin{itemize} \\item A: Coordenador envia vote-request para participantes. \\item B: Participante responde com vote-commit ou vote-abort para o coordenador; se vote-abort, aborta localmente. \\end{itemize} \\item Fase 2 \\begin{itemize} \\item A: Coordenador coleta votos de todos os processos; se forem todos vote-commit, envia global-commit para os participantes e ok para o cliente \\item B: Participantes esperam por global-commit ou global-abort \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{2PC -- O Protocolo} \\begin{itemize} \\item Fase 1 \\begin{itemize} \\item A: Coordenador envia vote-request para participantes. \\item B: Participante responde com vote-commit ou vote-abort para o coordenador; se vote-abort, aborta localmente. \\end{itemize} \\item Fase 2 \\begin{itemize} \\item A: Coordenador coleta votos de todos os processos; se forem todos vote-commit, envia global-commit para os participantes e ok para o cliente \\item B: Participantes esperam por global-commit ou global-abort \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{O Protocolo} Coordenador \\hfill Participante \\hfill \\includegraphics[width=.45\\textwidth]{images/08-18a} \\hfill \\includegraphics[width=.45\\textwidth]{images/08-18b} \\end{frame} \\begin{frame}{Falha no Participante} Participante falha no estado S S e, ao se recuperar, identifica tal fato ao reprocessar o log de opera\u00e7\u00f5es em mem\u00f3ria dur\u00e1vel. Se est\u00e1 no estado \\begin{itemize} \\item INIT: \\pause nem sabia que a termina\u00e7\u00e3o come\u00e7ou. \\pause Aborta unilateralmente, pois ou j\u00e1 abortaram ou v\u00e3o abortar.\\pause \\item ABORT: havia votado abort ou recebido global-abort -- continua protocolo. \\item COMMIT: estava pronto para terminar a transa\u00e7\u00e3o com sucesso -- continua protocolo. \\item READY: \\pause estava esperando por commit ou abort. \\pause Precisa saber se coordenador enviou global-commit ou global-abort\\pause -- consulta coordenador. \\end{itemize} \\end{frame} \\begin{frame}{2PC} Por qu\u00ea dif\u00edcil? \\begin{itemize} \\item E se $R_i$ falhar depois de ter se preparado?\\pause \\item E se $R_i$ falhar mas $R_j$ continuar funcionando?\\pause \\item E se todos estiverem desligados quando $R_i$ se recuperar?\\pause \\item E se $R_i$ estiver lento e parecer que a transa\u00e7\u00e3o falhou? \\end{itemize} \\end{frame} \\begin{frame}{2PC} Por qu\u00ea dif\u00edcil? \\begin{itemize} \\item E se $R_i$ falhar depois de ter se preparado?\\pause \\item E se $R_i$ falhar mas $R_j$ continuar funcionando?\\pause \\item E se todos estiverem desligados quando $R_i$ se recuperar?\\pause \\item E se $R_i$ estiver lento e parecer que a transa\u00e7\u00e3o falhou? \\end{itemize} \\end{frame} \\begin{frame}{Falha no Participante} \\begin{itemize} \\item READY: esperando por commit ou abort. Precisa saber se coordenador enviou global-commit our global-abort -- consulta coordenador. \\end{itemize} \\alert{E se coordenador n\u00e3o estiver presente?} \\pause Assumindo que participantes se conhecem \\pause , contate participante Q Q \\begin{itemize} \\item Se <span><span class=\"MathJax_Preview\">Q</span><script type=\"math/tex\">Q em COMMIT\\pause , vai para COMMIT \\item Se Q Q em ABORT\\pause , vai para ABORT \\item Se Q Q em INIT\\pause , ordena que Q aborte e, se confirmado, veja passo anterior \\item Se Q Q em READY\\pause , consulta outro participante. \\end{itemize} \\pause \\alert{Se todos os participantes em READY?} \\pause Possivelmente o coordenador j\u00e1 respondeu ao cliente. \\pause\\alert{Precisa} esperar pelo coordenador. \\end{frame} \\begin{frame}{Falha no Coordenador} O problema principal \u00e9: e se ningu\u00e9m ouviu a decis\u00e3o final do coordenador? Neste caso, \\pause o protocolo n\u00e3o pode continuar, enquanto o coordenador n\u00e3o retornar, pois se os RM abortarem, podem estar contradizendo algo dito ao cliente, por exemplo, \"Sim, ATM, pode entregar o dinheiro\", ou executando um comando que o cliente v\u00ea como anulado, como \"Reenvie o pedido de mais 27 carros \u00e0 f\u00e1brica.\" \\end{frame} \\begin{frame}{Recupera\u00e7\u00e3o do Coordenador} Ao se recuperar, o coordenador: \\begin{itemize} \\item sabe se come\u00e7ou a termina\u00e7\u00e3o de alguma transa\u00e7\u00e3o \\item sabe se j\u00e1 enviou alguma resposta final para as transa\u00e7\u00f5es inacabadas \\item sabe se j\u00e1 recebeu a confirma\u00e7\u00e3o de todos os participantes (se transa\u00e7\u00e3o n\u00e3o estiver em aberto) \\item reenvia a \u00faltima mensagem das transa\u00e7\u00f5es em aberto. \\end{itemize} \\end{frame} \\begin{frame}{Recupera\u00e7\u00e3o do Coordenador} Ao se recuperar, o coordenador: \\begin{itemize} \\item sabe se come\u00e7ou a termina\u00e7\u00e3o de alguma transa\u00e7\u00e3o \\item sabe se j\u00e1 enviou alguma resposta final para as transa\u00e7\u00f5es inacabadas \\item sabe se j\u00e1 recebeu a confirma\u00e7\u00e3o de todos os participantes (se transa\u00e7\u00e3o n\u00e3o estiver em aberto) \\item reenvia a \u00faltima mensagem das transa\u00e7\u00f5es em aberto. \\end{itemize} \\end{frame} \\begin{frame}{Otimiza\u00e7\u00f5es} \\begin{itemize} \\item Participantes ``somente-leitura'' \\begin{itemize} \\item N\u00e3o se importa com a decis\u00e3o; termina ap\u00f3s fase 1. \\item Responde com vote-commit-ro \\end{itemize} \\item Abort presumido \\begin{itemize} \\item Se ocorrer timeout, coordenador envia global-abort a todos e esquece transa\u00e7\u00e3o \\item Se questionado, responde com global-abort. \\end{itemize} \\item Transfer\u00eancia de coordena\u00e7\u00e3o \\begin{itemize} \\item se houver somente um participante... \\item vote-request-transfer \\item participante responde com global-commit/global-abort \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Otimiza\u00e7\u00f5es} \\begin{itemize} \\item Participantes ``somente-leitura'' \\begin{itemize} \\item N\u00e3o se importa com a decis\u00e3o; termina ap\u00f3s fase 1. \\item Responde com vote-commit-ro \\end{itemize} \\item Abort presumido \\begin{itemize} \\item Se ocorrer timeout, coordenador envia global-abort a todos e esquece transa\u00e7\u00e3o \\item Se questionado, responde com global-abort. \\end{itemize} \\item Transfer\u00eancia de coordena\u00e7\u00e3o \\begin{itemize} \\item se houver somente um participante... \\item vote-request-transfer \\item participante responde com global-commit/global-abort \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Coleta de Lixo} Mesmo quando somente um participante falha... Ap\u00f3s receber decis\u00e3o, o participante pode concluir e esquecer a transa\u00e7\u00e3o. Mas e se o participante falho precisar se recuperar e todos os outros envolvidos tiverem esquecido a transa\u00e7\u00e3o? \\pause Coleta de lixo s\u00f3 pode ser feita quando todos tiverem confirmado a execu\u00e7\u00e3o da transa\u00e7\u00e3o e, por isso, Fase 2b \u00e9 necess\u00e1ria. \\end{frame} \\subsubsection{3-PC} \\begin{frame}{Comprometimento em Tr\u00eas Fases} Estende o protocolo para permitir contornar falha do coordenador. \\end{frame} \\begin{frame}{Comprometimento em Tr\u00eas Fases} Estende o protocolo para permitir contornar falha do coordenador. \\end{frame} \\begin{frame}{O Protocolo} \\begin{itemize} \\item Fase 1a -- Coordenador envia vote-request para participantes. \\item Fase 1b -- Participante responde com vote-commit ou vote-abort para o coordenador; se vote-abort, aborta localmente. \\item Fase 2a -- Coordenador coleta votos de todos os processos; se forem todos vote-commit, envia \\alert{prepare-commit} para os participantes; se n\u00e3o, global-abort e para. \\item Fase 2b -- Participantes esperam por prepare-commit ou global-abort; se o primeiro, \\alert{respondem com ready-commit}; se o segundo, param. \\item Fase 3a -- coordenador espera por ready-commit de todos e ent\u00e3o envia global-commit. \\item Fase 3b -- participantes esperam por global-commit. \\end{itemize} \\end{frame} \\begin{frame}{O Protocolo} \\begin{itemize} \\item Fase 1a -- Coordenador envia vote-request para participantes. \\item Fase 1b -- Participante responde com vote-commit ou vote-abort para o coordenador; se vote-abort, aborta localmente. \\item Fase 2a -- Coordenador coleta votos de todos os processos; se forem todos vote-commit, envia \\alert{prepare-commit} para os participantes; se n\u00e3o, global-abort e para. \\item Fase 2b -- Participantes esperam por prepare-commit ou global-abort; se o primeiro, \\alert{respondem com ready-commit}; se o segundo, param. \\item Fase 3a -- coordenador espera por ready-commit de todos e ent\u00e3o envia global-commit. \\item Fase 3b -- participantes esperam por global-commit. \\end{itemize} \\end{frame} \\begin{frame}{O Protocolo} Coordenador \\hfill Participante \\includegraphics[width=.45\\textwidth]{images/08-22a} \\hfill \\includegraphics[width=.45\\textwidth]{images/08-22b} \\end{frame} \\begin{frame}{Falha no Participante} P P consegue saber o que fazer ap\u00f3s se recuperar da falha no estado READY ou PRE-COMMIT \\pause \\begin{itemize} \\item Participantes e coordenador n\u00e3o distam mais que um estado. \\item Se algu\u00e9m em READY, o coordenador n\u00e3o mandou global-commit ainda; Aborte. \\item Se \\alert{todos} em PRE-COMMIT, \u00e9 poss\u00edvel comitar, comite. \\item A execu\u00e7\u00e3o dos passos anteriores tem que anular o poder do coordenador. \\end{itemize} \\pause \\alert{Se todos os participantes em READY?} \\end{frame} \\begin{frame}{3PC x 2PC} \\begin{itemize} \\item 3PC -- Aumenta disponibilidade \\item 2PC -- Falha do coordenador \u00e9 ``corner case'' \\item 3PC -- Aumenta o custo do ``caminho feliz'' e por isso n\u00e3o \u00e9 usado na pr\u00e1tica \\item Nenhum escala e n\u00e3o us\u00e1-los \u00e9 uma das raz\u00f5es para o surgimento dos sistemas NoSQL \\end{itemize} \\end{frame} \\begin{frame}{3PC x 2PC} \\begin{itemize} \\item 3PC -- Aumenta disponibilidade \\item 2PC -- Falha do coordenador \u00e9 ``corner case'' \\item 3PC -- Aumenta o custo do ``caminho feliz'' e por isso n\u00e3o \u00e9 usado na pr\u00e1tica \\item Nenhum escala e n\u00e3o us\u00e1-los \u00e9 uma das raz\u00f5es para o surgimento dos sistemas NoSQL \\end{itemize} \\end{frame} \\subsubsection{Paxos-Commit} \\begin{frame}{Paxos-Commit} Usa inst\u00e2ncias de Consenso Distribu\u00eddo para votar. Se o consenso \u00e9 tolerante a falhas e consistente, todos v\u00eaem o mesmo resultado na transa\u00e7\u00e3o. \\end{frame} \\begin{frame}{O protocolo} \\begin{itemize} \\item Para terminar a transa\u00e7\u00e3o T T , o coordenador envia request-commit a todos os participantes. \\item Um participante P P prop\u00f5e seu voto na inst\u00e2ncia T_P T_P de consenso. \\item Todo participante P P espera pelas decis\u00f5es das inst\u00e2ncias de consenso T_i T_i para todos os participantes i i , inclusive si mesmo; se todas as decis\u00f5es forem commit, o participante comita a transa\u00e7\u00e3o. 1 \\item Se cansar de esperar por $T_Q$, o participante prop\u00f5e abort em $T_Q$. \\end{itemize} \\end{frame} \\begin{frame}{Falha no Participante} \\begin{itemize} \\item Se o participante falha antes de votar, ent\u00e3o algu\u00e9m votar\u00e1 abort por ele. \\item Se o participante $P$ falha, ou \u00e9 suspeito de, ent\u00e3o \u00e9 poss\u00edvel que dois votos diferentes tenham sido propostos em $T_P$;\\pause isso n\u00e3o \u00e9 um problema pois a decis\u00e3o \u00e9 a mesma para todos observando a inst\u00e2ncia. \\item Ap\u00f3s se recuperar, o participante recupera as decis\u00f5es de todas as inst\u00e2ncias $T_i$ e termina apropriadamente. \\end{itemize} \\end{frame} \\begin{frame}{Falha no Participante} \\begin{itemize} \\item Se o participante falha antes de votar, ent\u00e3o algu\u00e9m votar\u00e1 abort por ele. \\item Se o participante $P$ falha, ou \u00e9 suspeito de, ent\u00e3o \u00e9 poss\u00edvel que dois votos diferentes tenham sido propostos em $T_P$;\\pause isso n\u00e3o \u00e9 um problema pois a decis\u00e3o \u00e9 a mesma para todos observando a inst\u00e2ncia. \\item Ap\u00f3s se recuperar, o participante recupera as decis\u00f5es de todas as inst\u00e2ncias $T_i$ e termina apropriadamente. \\end{itemize} \\end{frame} \\subsection{Log Recuper\u00e1vel} \\begin{frame}{Log Recuper\u00e1vel} Como garantir que o log poder\u00e1 ser lido para recuperar o processo? \\end{frame} \\begin{frame}{Disco Duplicado} \\includegraphics[width=.7\\textwidth]{images/08-23} \\begin{itemize} \\item Dois discos iguais? \\item Dados diferentes, mas ambos bons? \\item Um bom outro estragado? \\item Ambos estragados? \\end{itemize} \\end{frame}","title":"Bancos de Dados"},{"location":"teaching/gbc074gsi028/disdb/#bancos-de-dados-distribuidos","text":"","title":"Bancos de Dados Distribu\u00eddos"},{"location":"teaching/gbc074gsi028/disdb/#nosql","text":"","title":"NoSQL"},{"location":"teaching/gbc074gsi028/disdb/#estruturas-de-dados-para-sd","text":"Qualquer que seja a escolha de algoritmo para fazer o particionamento dos dados entre servidores, sobra ainda a quest\u00e3o de como manipular os dados dentro do servidor. Idealmente, toda opera\u00e7\u00e3o seria executada a partir da mem\u00f3ria principal, tendo assim a menor lat\u00eancia poss\u00edvel. Contudo, para que se tenha tamb\u00e9m durabilidade das opera\u00e7\u00f5es executadas, para que os dados manipulados sobrevivam a reinicializa\u00e7\u00f5es do servidor, intencionais ou n\u00e3o, \u00e9 preciso armazenar os dados em mem\u00f3ria est\u00e1vel , da qual a mais comum \u00e9 s\u00e3o os discos r\u00edgidos . \u00c9 not\u00f3rio que escritas em disco s\u00e3o muito mais lentas que em mem\u00f3ria principal, mas o que exatamente \u00e9 lento no acesso ao disco? Essencialmente, o posicionamento da cabeca de leitura/escrita na trilha correta do disco, pois esta opera\u00e7\u00e3o \u00e9 mec\u00e2nica. Por esta raz\u00e3o, acessos aleat\u00f3rios s\u00e3o mais custosos que acessos sequenciais, pois neste o custo de posicionamento \u00e9 pago apenas uma vez. Por este motivo, muitos bancos de dados, especialmente DHT pois tem seu uso focado em quantidades muito grandes de dados, gerados e acessados com grande velocidade, tentam acessar o disco sempre de forma sequencial. Alguns bancos de dados, como o Cassandra, armazenam os dados na forma de uma Log Structured Merge Tree , ou LSMT.","title":"Estruturas de Dados para SD"},{"location":"teaching/gbc074gsi028/disdb/#log-structured-merge-tree","text":"Uma Log Structured Merge Tree \u00e9 uma forma de se armazenar dados em disco de forma de forma quase sempre sequencial, minimizando assim os o impacto da durabilidade no desempenho do sistema. Considere um banco armazenando uma pequena quantidade de dados, que cabe em mem\u00f3ria principal. Na LSMT, opera\u00e7\u00f5es de escrita s\u00e3o adicionadas a um commit log , em disco, e somente ent\u00e3o s\u00e3o executadas em mem\u00f3ria principal e confirmadas para o cliente; a estrutura que armazena os dados em mem\u00f3ria \u00e9 denominada memory table , ou simplesmente memtable . Neste cen\u00e1rio o acesso ao disco na escrita \u00e9 sequencial, o melhor que se pode ter em um disco, e a recupera\u00e7\u00e3o dos dados \u00e9 feita diretamente da mem\u00f3ria, r\u00e1pida. No caso de uma reinicializa\u00e7\u00e3o do processo, a reexecu\u00e7\u00e3o do commit log restaurar\u00e1 o estado da memtable. Contudo, se o commit log for extenso, reexecut\u00e1-lo demandar\u00e1 um tempo significativo. Uma forma de acelerar o processo \u00e9 fazer snapshots da memtable de forma sincronizada com a escrita no log. Isto \u00e9, digamos que todas as opera\u00e7\u00f5es de escrita, at\u00e9 a d\u00e9cima, est\u00e3o salvas no commit log e refletidas na memtable. Digamos tamb\u00e9m que todas as opera\u00e7\u00f5es s\u00e3o modifica\u00e7\u00f5es da mesma linha do banco de dados em mem\u00f3ria. Se um snapshot \u00e9 tomado, ele ser\u00e1 correspondente ao commit log, isto \u00e9, conter\u00e1 o efeito de exatamente as mesmas 10 opera\u00e7\u00f5es, mas de forma mais compacta que o log, uma vez que o log conter\u00e1 dez opera\u00e7\u00f5es e o snapshot somente uma linha de dados. Ap\u00f3s o snapshot ser conclu\u00eddo, o log correspondente pode ser apagado. Novas opera\u00e7\u00f5es de escrita devem ser armazenadas em um novo log e, no caso de uma reinicializa\u00e7\u00e3o, primeiro se deve restaurar o snapshot e ent\u00e3o o novo log. Para lidar com corrup\u00e7\u00f5es de arquivo no sistema, pode ser uma boa ideia manter mais do que o \u00faltimo log e snapshot , j\u00e1 que a recupera\u00e7\u00e3o do estado exigiria voltar mais atr\u00e1s na reexecu\u00e7\u00e3o de opera\u00e7\u00f5es. Observe que, al\u00e9m da escrita dos logs, todos os outros acessos ao disco tamb\u00e9m s\u00e3o sequenciais, seja o flush das memtables, ou a leitura dos snapshots para recupera\u00e7\u00e3o e do commit log para reexecu\u00e7\u00e3o, e j\u00e1 que opera\u00e7\u00f5es de leitura s\u00e3o todas respondidas da mem\u00f3ria, o sistema ter\u00e1 um excelente desempenho. Contudo, h\u00e1 outro limitante de desempenho importante, relacionado \u00e0 premissa pouco realista de que os dados cabem todos em mem\u00f3ria. Isto \u00e9, se os dados n\u00e3o cabem em mem\u00f3ria, snapshots ser\u00e3o importantes n\u00e3o somente para permitir coletar lixo dos logs, isto \u00e9, dados obsoletos, mas tamb\u00e9m, para usar a capacidade de armazenamento dos discos. Consideremos ent\u00e3o um cen\u00e1rio em que a memtable cabe apenas n entradas; quando a opera\u00e7\u00e3o para adicionar n+1 n+1 -\u00e9sima entrada \u00e0 memtable \u00e9 recebida, um flushs dos dados para um novo snapshot \u00e9 feito e a memtable \u00e9 resetada , liberando espa\u00e7o em mem\u00f3ria. Para melhorar o desempenho, estas descargas podem ser feitas proativamente antes da chegada de novas entradas e fora do caminho cr\u00edtico da opera\u00e7\u00e3o de escrita, mas isto \u00e9 apenas uma otimiza\u00e7\u00e3o e portanto n\u00e3o a consideraremos aqui. Neste novo fluxo, os arquivos em disco n\u00e3o correspondem mais a snapshots do banco de dados, ent\u00e3o nos referiremos a eles como stable storage tables , ou sstables , em oposi\u00e7\u00e3o \u00e0s memtables , pelo menos por enquanto.","title":"Log Structured Merge Tree"},{"location":"teaching/gbc074gsi028/disdb/#filtros-de-bloom","text":"De acordo com nossa fonte mais que confi\u00e1vel, a Wikipedia A Bloom filter is a **space-efficient* probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not, thus a Bloom filter has a 100% recall rate. In other words, a query returns either \"possibly in set\" or \"definitely not in set\" .* Se associarmos a cada sstable um filtro de Bloom, ent\u00e3o s\u00f3 ser\u00e1 preciso l\u00ea-la se o filtro correspondente disser que a chave possivelmente est\u00e1 contida, como no seguinte exemplo. Mas como exatamente constru\u00edmos um filtro de Bloom? Iniciamos com um vetor de bits inicialmente zerados e um conjunto finito de fun\u00e7\u00f5es de hash cujo resultado seja uniformemente distribu\u00eddo no tamanho do vetor de bits. Para cada elemento colocado no conjunto a ser refletido pelo filtro, aplicamos cada uma das fun\u00e7\u00f5es hash e colocamos o bit 1 na posi\u00e7\u00e3o do vetor igual ao resultado da fun\u00e7\u00e3o. No exemplo a seguir, inserimos os elementos x, y e z e usamos tr\u00eas fun\u00e7\u00f5es hash. Na consulta , cada elemento passa por pelas mesmas fun\u00e7\u00f5es hash. Se algum dos \u00edndices apontados n\u00e3o estiver com um 1, como no caso do w, no exemplo, o elemento n\u00e3o pertence ao conjunto. Caso contr\u00e1rio, o filtro responder\u00e1 que \u00e9 poss\u00edvel que perten\u00e7a. Mas qu\u00e3o bom \u00e9 um filtro de Bloom na identifica\u00e7\u00e3o do das sstables? Ou, de outra forma, quais fatores influenciam na taxa de falsos positivos do filtro? * o n\u00famero n n de elementos no conjunto, uma vez que quanto mais elementos, mais bits 1; * o n\u00famero k k de hashes, pois quanto mais hashes, mais bits transformados em 1; e, * o n\u00famero m m de bits no vetor, pois quanto menos bits, mais colis\u00f5es de bits. De forma mais precisa, * a probabilidade de setar um certo bit na inser\u00e7\u00e3o de um elemento \u00e9 1/m 1/m , e * a probabilidade de n\u00e3o setar tal bit \u00e9 1 - 1/m 1 - 1/m ; * a probabilidade de k k hashes n\u00e3o setarem um bit \u00e9 (1 - 1/m)^k (1 - 1/m)^k ; * a probabilidade de n\u00e3o setar um bit ap\u00f3s n n inser\u00e7\u00f5es \u00e9 (1 - 1/m)^{kn} (1 - 1/m)^{kn} ; * a probabilidade de setar um bit ap\u00f3s n n inser\u00e7\u00f5es \u00e9 1 - (1 - 1/m)^{kn} 1 - (1 - 1/m)^{kn} Logo, * a probabilidade de falso positivo p = (1 - (1 - 1/m)^{kn})^k \\approx (1 - e^{-kn/m})^k p = (1 - (1 - 1/m)^{kn})^k \\approx (1 - e^{-kn/m})^k O que nos permite chegar \u00e0 rela\u00e7\u00e3o * m/n = - 1.44\\log_2 p m/n = - 1.44\\log_2 p , em que podemos calcular m m em fun\u00e7\u00e3o do n n esperado e do p p desejado. E podemos tamb\u00e9m identificar o k k \u00f3timo para a situa\u00e7\u00e3o, pela equa\u00e7\u00e3o * k = - \\frac{\\ln p}{\\ln 2} = - \\log_2 p k = - \\frac{\\ln p}{\\ln 2} = - \\log_2 p Uma forma \"simples\" de visualizar este resultado \u00e9 dada pela figura a seguir, em que o eixo Y d\u00e1 a taxa de falsos positivos do filtro em fun\u00e7\u00e3o do n\u00famero de elementos inseridos, indicado no eixo X, para diversas configura\u00e7\u00f5es, apresentadas como curvas. Por exemplo, com um filtro com m = 2^{24}b = 2MB m = 2^{24}b = 2MB , ap\u00f3s 1 milh\u00e3o de inser\u00e7\u00f5es, tem-se probabilidade de falsos positivo p = 0,0001 p = 0,0001 .","title":"Filtros de Bloom"},{"location":"teaching/gbc074gsi028/fault/","text":"Toler\u00e2ncia a Falhas Neste cap\u00edtulo discutiremos o qu\u00ea s\u00e3o sistemas distribu\u00eddos, por qu\u00ea os desenvolvemos, e damos uma vis\u00e3o geral de como isto \u00e9 feito. Dependabilidade Ao escrevermos nossos softwares, queremos que sejam usados para resolver problemas, mesmo que import\u00e2ncia do problema esteja em um espectro bem vasto, indo, por exemplo, da execu\u00e7\u00e3o de um cirurgia ocular remota, ao controle de uma usina hidrel\u00e9trica, \u00e0 jogar truco contra um computador. Independentemente do problema sendo resolvido, gostar\u00edamos de poder contar com o sistema, de poder depender nele para executar sua tarefa. Desta situa\u00e7\u00e3o, surge a ideia de dependabilidade, isto \u00e9, de um sistema ter a propriedade de que podemos depender do mesmo. Em computa\u00e7\u00e3o distribu\u00edda, componentes dependem uns dos outros para a realiza\u00e7\u00e3o de tarefas. Assim, componentes que quer ser \"depend\u00e1veis\" (do ingl\u00eas, dependable ), pois se n\u00e3o o forem, os demais componentes n\u00e3o poder\u00e3o executar suas tarefas, rendendo o sistema como um todo in\u00fatil. Assim, dizemos que um componente C C depende de um componente C' C' se a corretude do comportamento de C C depende da corretude do componente C' C' . E que um componente \u00e9 ``depend\u00e1vel'' (\\emph{dependable}) na medida que outros podem depender dele. De acordo com Laprie et al , tem-se dependabilidade quando os seguintes atributos est\u00e3o presentes. Disponibilidade ( Availability ) - Prontid\u00e3o para uso. Confiabilidade/Fiabilidade (*Reliability) - Continuidade do servi\u00e7o. Manutenabilidade ( Maintainability ) - Facilidade de reparo. Seguran\u00e7a ( Safety ) - Toler\u00e2ncia a cat\u00e1strofes. Integridade ( Integrity ) - Toler\u00e2ncia a modifica\u00e7\u00f5es. Confidencialidade (*Confidentiality) - Informa\u00e7\u00e3o somente a quem devido. A combin\u00e7\u00e3o das tr\u00eas \u00faltimas propriedades \u00e9 tamb\u00e9m chamadas de Seguran\u00e7a ( Security ). Como obst\u00e1culos para se conseguir estes atributos est\u00e3o os seguintes obst\u00e1culos, ou amea\u00e7as: Fault - Falha (Falta): bug -- \\lstinline|<=| em vez de \\lstinline|<| (pode nunca afetar a execu\u00e7\u00e3o). Error - Erro (Erro): manifesta\u00e7\u00e3o do bug -- itera\u00e7\u00e3o passa do ponto. (Pode n\u00e3o ser observ\u00e1vel pelo usu\u00e1rio.) Failure - Defeito (Falha): problema vis\u00edvel -- tela azul Modelos \\section{Dependabilidade} \\subsection{Introdu\u00e7\u00e3o} \\begin{frame}{Dependabilidade} \\begin{block}{} Um componente prov\u00ea servi\u00e7os a um cliente.\\\\ Para prover o servi\u00e7o, o componente pode \\alert{depender} de outros. \\end{block} \\begin{block}{} Um componente $C$ depende de um componente $C'$ se a corretude do comportamento de $C$ depende da corretude do componente $C'$. \\end{block} \\begin{block}{} Um componente $C$ depende de um componente $C'$ se a corretude do comportamento de $C$ depende da corretude do componente $C'$. \\end{block} \\begin{block}{} Um componente \u00e9 ``depend\u00e1vel'' (\\emph{dependable}) na medida que outros podem depender dele. \\end{block} \\end{frame} \\begin{frame}{Dependabilidade} O que queremos (Atributos) \\begin{itemize} \\item Disponibilidade (\\emph{Availability})-- Prontid\u00e3o para uso. \\item Confiabilidade/Fiabilidade (\\emph{Reliability}) -- Continuidade do servi\u00e7o. \\item Manutenabilidade (\\emph{Maintainability}) -- Facilidade de reparo. \\~ \\~\\ 1 2 3 4 \\item Seguran\u00e7a (\\emph{Safety}) -- Toler\u00e2ncia a cat\u00e1strofes. \\item Integridade (\\emph{Integrity}) -- Toler\u00e2ncia a modifica\u00e7\u00f5es \\item Confidencialidade (\\emph{Confidentiality}) -- Informa\u00e7\u00e3o somente a quem devido. \\item Seguran\u00e7a (\\emph{Security}) -- Soma dos tr\u00eas anteriores. \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Dependabilidade} O que gostar\u00edamos de evitar (Amea\u00e7as) \\begin{itemize} \\item Fault -- Falha (Falta): bug -- \\lstinline|<=| em vez de \\lstinline|<| (pode nunca afetar a execu\u00e7\u00e3o). \\item Error -- Erro (Erro): manifesta\u00e7\u00e3o do bug -- itera\u00e7\u00e3o passa do ponto. (Pode n\u00e3o ser observ\u00e1vel pelo usu\u00e1rio.) \\item Failure -- Defeito (Falha): problema vis\u00edvel -- tela azul \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Dependabilidade} O que gostar\u00edamos de evitar (Amea\u00e7as) \\begin{itemize} \\item Fault -- Falha (Falta): bug -- \\lstinline|<=| em vez de \\lstinline|<| (pode nunca afetar a execu\u00e7\u00e3o). \\item Error -- Erro (Erro): manifesta\u00e7\u00e3o do bug -- itera\u00e7\u00e3o passa do ponto. (Pode n\u00e3o ser observ\u00e1vel pelo usu\u00e1rio.) \\item Failure -- Defeito (Falha): problema vis\u00edvel -- tela azul \\end{itemize} \\end{frame} \\begin{frame}{Ariane 5} ``The Explosion of the Ariane 5 On June 4, 1996 an unmanned Ariane 5 rocket launched by the European Space Agency exploded just forty seconds after its lift-off [...] after a decade of development costing $7B. The destroyed rocket and its cargo were valued at $500M. [...] the failure was a software error [...] a 64 bit floating point number [...] was converted to a 16 bit signed integer. The number was larger than 32,767, the largest integer storeable in a 16 bit signed integer, and thus the conversion failed.'' \\includegraphics[width=.7\\textwidth]{images/ariane5} \\href{ http://www-users.math.umn.edu/~arnold/disasters/ariane.html}{Fonte } \\end{frame} O erro gerado foi tratado como input, causando outros erros, que geraram instabilidade e que levou o sistema a se auto-destruir. \\begin{frame}{Dependabilidade} Como evitar (Meios) \\begin{itemize} \\item Preven\u00e7\u00e3o de falhas: \\pause escreva sem bugs!\\ Especifica\u00e7\u00f5es formais; prova de corretude; model checkers;... 1 2 3 4 5 6 7 \\item Remo\u00e7\u00e3o de falhas: \\pause resolva seus bugs!\\\\ Testes; manuten\u00e7\u00e3o. \\item Previs\u00e3o de falhas: \\pause estime quando elas se manifestar\u00e3o! Reinicie processos frequentemente. \\item Toler\u00e2ncia a falhas: \\pause conviva e mascare falhas. \\end{itemize} \\end{frame} \\begin{frame}{Subaru SUVs -- 2018} \\includegraphics[width=.45\\textwidth]{images/subaru} \\href{ https://spectrum.ieee.org/riskfactor/computing/it/coding-error-leads-293-subaru-ascents-to-the-car-crusher}{Fonte } \\end{frame} \\begin{frame}{Car Hack -- 2017} \\includegraphics[width=.4\\textwidth]{images/carhack} \\href{ https://www.wired.com/story/car-hack-shut-down-safety-features/}{Fonte } \\end{frame} \\begin{frame}{Toler\u00e2ncia a falhas} Dependendo dos efeitos e tratamentos. \\begin{itemize} \\item Fail safe -- defeito n\u00e3o leva a comportamento inseguro (sistema de entretenimento no avi\u00e3o) \\item Fail soft -- graceful degradation (sistema de controle de v\u00f4o) \\item Fail fast -- para o fluxo de defeitos (e poss\u00edvel rein\u00edcio) \\vspace{1cm} 1 2 \\item Robusto -- erros n\u00e3o atrapalham execu\u00e7\u00e3o (tratamento de exce\u00e7\u00f5es) \\item Quebradi\u00e7o (\\emph{brittle}) -- n\u00e3o resiliente a falhas \\end{itemize} \\end{frame} \\begin{frame}{Fail Fast -- Cadeia de supervis\u00e3o} \\includegraphics[width=.7\\textwidth]{images/httpatomoreillycomsourceoreillyimages300817} \\end{frame} \\begin{frame}{Fail Fast -- Cadeia de supervis\u00e3o} \\includegraphics[width=.7\\textwidth]{images/httpatomoreillycomsourceoreillyimages300817} \\end{frame} \\begin{frame}{Toler\u00e2ncia a Falhas -- Exemplos} \\begin{itemize} \\item Pneu estepe \\item Gerador de eletricidade em casa \\item Cal\u00e7a extra na mala \\item Uber, em vez do \u00f4nibus \\end{itemize} \\pause O que h\u00e1 de comum? \\end{frame} \\begin{frame}{Toler\u00e2ncia a Falhas -- Exemplos} \\begin{itemize} \\item Pneu estepe \\item Gerador de eletricidade em casa \\item Cal\u00e7a extra na mala \\item Uber, em vez do \u00f4nibus \\end{itemize} \\pause O que h\u00e1 de comum? \\end{frame} \\begin{frame}{Redund\u00e2ncia} Componentes extra, para uso em caso de defeitos. Aus\u00eancia de um SPOF -- \\emph{Single Point of Failure} \\pause \\begin{itemize} \\item Mais projeto \\item Mais testes \\item Mais custo \\item Mais tempo \\item Peso extra \\end{itemize} \\pause Custo x Beneficio -- Custo da redund\u00e2ncia, Probabilidade de falha, beneficio.\\ \\pause Pneu x Motor x Radio \\end{frame} \\begin{frame}[allowframebreaks]{Tipos de defeitos} \\begin{itemize} \\item Quebra/Crash: componente para de funcionar. \\begin{itemize} \\item Fail-stop -- defeito \u00e9 detect\u00e1vel (timeout, por exemplo).\\\\ E se o problema for a rede? \\item Fail-silent -- defeito pode n\u00e3o ser not\u00e1vel. \\item Fail-recover -- voltam a executar. \\end{itemize} 1 2 3 4 5 6 7 8 9 10 11 12 13 \\item Omiss\u00e3o: componente n\u00e3o executa a\u00e7\u00f5es. \\begin{itemize} \\item Requisi\u00e7\u00e3o n\u00e3o atendida \\item Mensagem n\u00e3o transmitida \\end{itemize} \\item Temporiza\u00e7\u00e3o: prazos n\u00e3o s\u00e3o respeitados. \\item Arbitr\u00e1ria: qualquer coisa pode acontecer. \\begin{itemize} \\item Resposta: a\u00e7\u00f5es s\u00e3o executadas incorretamente mas sem maldade. \\item Arbitr\u00e1ria com detec\u00e7\u00e3o por falha de identifica\u00e7\u00e3o \\end{itemize} \\end{itemize} Fail-stop \\in \\in Quebra \\in \\in Omiss\u00e3o \\in \\in Temporiza\u00e7\u00e3o \\in \\in Arbitr\u00e1ria \\end{frame} \\begin{frame}{Resposta} \\begin{itemize} \\item ALU defeituosa \\end{itemize} \\end{frame} \\begin{frame}{Resposta} \\begin{itemize} \\item ALU defeituosa \\end{itemize} \\end{frame} \\begin{frame}{Arbitr\u00e1ria} \\begin{itemize} \\item Bug \\item Hacking \\item V\u00edrus \\end{itemize} \\end{frame} \\begin{frame}{Arbitr\u00e1ria} \\begin{itemize} \\item Bug \\item Hacking \\item V\u00edrus \\end{itemize} \\end{frame} \\begin{frame}{Prepare-se para a vida de desenvolvedor} \\begin{itemize} \\item Falhas intermitentes -- e.g., picos de energia, comportamento emergente, \\item Heisenbugs -- inobserv\u00e1vel \\item Schroedinbugs -- inexistente at\u00e9 que observado \\end{itemize} \\end{frame} \\begin{frame}{Prepare-se para a vida de desenvolvedor} \\begin{itemize} \\item Falhas intermitentes -- e.g., picos de energia, comportamento emergente, \\item Heisenbugs -- inobserv\u00e1vel \\item Schroedinbugs -- inexistente at\u00e9 que observado \\end{itemize} \\end{frame} Heisenbug The name may seem to rhyme well with Heisenberg, but the Heisenbug is actually \"a bug that disappears or alters its behavior when one attempts to probe or isolate it.\" The Freenet Project describes a Heisenbug in certain Java virtual machines. Bohrbug The Bohrbug is a sort of antonym of the Heisenbug, as this bug does not disappear or alter its characteristics when it is researched. Mandelbug The Mandelbug, named after Benoit Mandelbrot (think Mandelbrot set), is a bug whose underlying causes are so complex and obscure as to make its behavior appear chaotic. Schroedinbug The Schroedinbug is a design or implementation bug in a program that doesn't manifest until someone reading source or using the program in an unusual way notices that it never should have worked, at which point the program promptly stops working for everybody until fixed. Here, an Office developer describes \"stupid SQL tricks\" to get rid of a \"classic Schroedinbug.\" \\begin{frame}{Correla\u00e7\u00e3o entre falhas?} N-Version programming \\begin{itemize} \\item M\u00faltiplos times \\item M\u00faltiplas implementa\u00e7\u00f5es do mesmo sistema \\item Falhas independentes \\vspace{1cm} \\item Custo maior \\item Erros de especifica\u00e7\u00e3o s\u00e3o reproduzidos \\item Times diferentes, mas erros iguais \\end{itemize} \\end{frame} \\begin{frame}{Correla\u00e7\u00e3o entre falhas?} N-Version programming \\begin{itemize} \\item M\u00faltiplos times \\item M\u00faltiplas implementa\u00e7\u00f5es do mesmo sistema \\item Falhas independentes \\vspace{1cm} \\item Custo maior \\item Erros de especifica\u00e7\u00e3o s\u00e3o reproduzidos \\item Times diferentes, mas erros iguais \\end{itemize} \\end{frame} \\begin{frame}{Foco} Falhas do tipo crash. \\end{frame} \\begin{frame}{Foco} Falhas do tipo crash. \\end{frame} \\begin{frame}{Redund\u00e2ncia de Processos} Como lidar com falhas de processos? Tenha m\u00faltiplos, tal que se um falha, outros podem continuar executando o servi\u00e7o. \\begin{itemize} \\item Ativo/Ativo \\item Mestre/Escravo \\item Replica\u00e7\u00e3o em cadeia \\item ... \\end{itemize} \\end{frame} \\subsection{Coordena\u00e7\u00e3o} \\begin{frame}{Coordena\u00e7\u00e3o} Para replicar, precisamos coordenar as execu\u00e7\u00f5es dos processos, mas como? \\end{frame} \\begin{frame}{Coordena\u00e7\u00e3o} Para replicar, precisamos coordenar as execu\u00e7\u00f5es dos processos, mas como? \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} \\begin{itemize} \\item A e B deve atacar C \\item Se A e B atacam juntos, ganham \\item Se atacarem separados, s\u00e3o ambos derrotados. \\item Comunica\u00e7\u00e3o por mensageiros, \\begin{itemize} \\item que podem se perder e levar muito tempo para chegar \\item podem ser mortos no caminho \\end{itemize} \\pause \\item Atacamos ao amanhecer! (rel\u00f3gios sincronizados) \\end{itemize} \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} \\begin{itemize} \\item A e B deve atacar C \\item Se A e B atacam juntos, ganham \\item Se atacarem separados, s\u00e3o ambos derrotados. \\item Comunica\u00e7\u00e3o por mensageiros, \\begin{itemize} \\item que podem se perder e levar muito tempo para chegar \\item podem ser mortos no caminho \\end{itemize} \\pause \\item Atacamos ao amanhecer! (rel\u00f3gios sincronizados) \\end{itemize} \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Ser\u00e1 que A n\u00e3o mandou uma resposta? Ser\u00e1 que A foi destru\u00eddo? Ser\u00e1 que o mensageiro morreu? Ser\u00e1 que parou em um inferninho? \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Ser\u00e1 que A n\u00e3o mandou uma resposta? Ser\u00e1 que A foi destru\u00eddo? Ser\u00e1 que o mensageiro morreu? Ser\u00e1 que parou em um inferninho? \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Como saber se o outro recebeu a mensagem e ir\u00e1 atacar ao mesmo tempo? \\pause Mensagem de confirma\u00e7\u00e3o. \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Como saber se o um recebeu a confirma\u00e7\u00e3o? \\pause Confirma\u00e7\u00e3o da confirma\u00e7\u00e3o! \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Como saber se o outro/um ...? \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Como saber se o outro/um ...? \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Nesse cen\u00e1rio, at\u00e9 simples, coordenar os dois processos \u00e9 \\alert{imposs\u00edvel}! \\pause \u00c9 imposs\u00edvel garantir que chegar\u00e3o a um \\emph{acordo}. \\end{frame} \\section{Acordo} \\subsection{Comunica\u00e7\u00e3o em Grupo} \\begin{frame}{Acordo} Dependendo do modelo, pode ser muito f\u00e1cil ou imposs\u00edvel fazer com que um grupo de processos concorde sobre como agir/entre em acordo. \\end{frame} Um dos fatores \u00e9 como o grupo \u00e9 organizado. \\begin{frame}{Grupos de Processos} Grupos podem ser organizados de diferentes formas, dependendo da aplica\u00e7\u00e3o. \\includegraphics[width=.5\\textwidth]{images/08-03} \\includegraphics[width=.45\\textwidth]{images/chain} Assumindo um grupo est\u00e1tico (sem entrada e sa\u00edda de processos), em que todos conversam com todos diretamente (grafo completo). \\end{frame} \u00c9 mais f\u00e1cil, mas n\u00e3o trivial neste modelo. Vejamos o problema de difus\u00e3o confi\u00e1vel. Mas antes, vamos definir. \\begin{frame}{Correto x Falho} Um processo \u00e9 correto se ele n\u00e3o falha. \\end{frame} \\begin{frame}{Correto x Falho} Um processo \u00e9 correto se ele n\u00e3o falha. \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} \\begin{itemize} \\item Corretude: Se um processo \\alert{correto} p p difunde uma mensagem m m para processos no grupo G G , ent\u00e3o todos os processos corretos em G G entregam a mensagem. 1 2 3 \\item Acordo: Se um processo correto em $G$ entrega uma mensagem $m$, ent\u00e3o todo processo correto em $G$ entrega $m$. \\item Validade: Somente mensagens difundidas s\u00e3o entregues. \\end{itemize} \\end{frame} \\begin{frame}{Terminologia} \\begin{itemize} \\item Enviar/Receber: rede \\item Difundir/Entregar: difus\u00e3o 1 \\item Corretude x Progresso \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Algoritmo? \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Algoritmo? \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Para p p difundir m m para G G \\begin{itemize} \\item <span><span class=\"MathJax_Preview\">p</span><script type=\"math/tex\">p envia m m para todo q \\in G q \\in G \\item Todo processo q\\in G q\\in G que receber a mensagem, envia m_{ack} m_{ack} para p p \\item Ao receber ack de todos os processos q \\in G q \\in G , p p para de retransmitir e entrega m m . \\end{itemize} \\pause Confi\u00e1vel? Isto \u00e9, satisfaz as duas propriedades? \\pause e se um dos receptores falhar? \\pause Assumamos detector de falhas perfeito. \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Para p p difundir m m para G G \\begin{itemize} \\item <span><span class=\"MathJax_Preview\">p</span><script type=\"math/tex\">p envia m m para todo q \\in G q \\in G \\item Todo processo q\\in G q\\in G que receber a mensagem, envia m_{ack} m_{ack} para p p \\item Ao receber ack de todos os processos \\alert{corretos} q \\in G q \\in G , p p para de retransmitir e entrega m m . \\end{itemize} \\pause Pq p p s\u00f3 entrega m m no final? \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Posso assumir TCP como protocolo de comunica\u00e7\u00e3o? \\begin{itemize} \\item $p$ envia $m$ para $G$ \\item $p$ entrega $m$ \\end{itemize} \\begin{itemize} \\item $p$ envia $m$ para $G$ \\item $p$ entrega $m$ \\end{itemize} \\pause N\u00e3o! TCP n\u00e3o \u00e9 confi\u00e1vel neste sentido. \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Assuma m\u00e1ximo de f f falhas, fail stop \\begin{itemize} \\item <span><span class=\"MathJax_Preview\">p</span><script type=\"math/tex\">p envia m m para processos em G G . \\item Todo processo q \\in G q \\in G que receber m m \\begin{itemize} \\item envia m_{ack} m_{ack} \\item repassa m m para G G processos. \\end{itemize} \\item Mensagens s\u00e3o retransmitidas de tempos em tempos. \\item Ao receber f+1 f+1 acks, entrega m m . \\end{itemize} % https://www.youtube.com/watch?v=uzcALT7sHew \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Assuma m\u00e1ximo de f f falhas e uso de TCP \\begin{itemize} \\item <span><span class=\"MathJax_Preview\">p</span><script type=\"math/tex\">p envia m m para processos em G G . \\item Em caso de quebra/falha de conex\u00e3o, substitua destinat\u00e1rio. \\item Todo processo q \\in G q \\in G que receber m m , repassa m m para os outros processos. \\item Entrega m m . \\end{itemize} \\pause Confi\u00e1vel? Somente se conex\u00f5es quebradas for reestabelecidas e mensagens reenviadas. \\pause Escal\u00e1vel? \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel FIFO} \\begin{itemize} \\item Corretude. \\item Acordo. \\item Validade. \\item FIFO: Se $p$ difunde $m$ e ent\u00e3o $n$, e se $q$ entrega $n$, ent\u00e3o $q$ entrega $m$ antes $n$. \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel FIFO} \\begin{itemize} \\item Corretude. \\item Acordo. \\item Validade. \\item FIFO: Se $p$ difunde $m$ e ent\u00e3o $n$, e se $q$ entrega $n$, ent\u00e3o $q$ entrega $m$ antes $n$. \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Totalmente Ordenada} \\begin{itemize} \\item Corretude: Se um processo p p difunde uma mensagem m m para processos no grupo G G , e se p p n\u00e3o falha, ent\u00e3o todos os processos corretos em G G entregam m m \\item Acordo: Se um processo correto q q em G G entrega uma mensagem m m , ent\u00e3o todo processo correto em G G entrega m m . \\item Ordena\u00e7\u00e3o: Se um processo entrega mensagem m m e depois n n , ent\u00e3o qualquer processo que entregue a mensagem n n deve primeiro entregar m m . \\item Validade: Somente mensagens difundidas s\u00e3o entregues. \\end{itemize} \\pause Algoritmo? \\pause Resolver diretamente este problema n\u00e3o \u00e9 trivial. Por isso, veremos primeiro o problema do Consenso Distribu\u00eddo. \\end{frame} \\begin{frame}{Consenso} Sejam v\u00e1rios processos. Cada um prop\u00f5e um \u00fanico valor por \\emph{inst\u00e2ncia de consenso}. O objetivo \u00e9 decidir um dentre os valores propostos: \\begin{itemize} \\item Validade: Somente um valor proposto pode ser decidido. \\item Termina\u00e7\u00e3o: Todo processo n\u00e3o falho decide-se. \\item Acordo: Se um processo decide-se por $v$ e outro por $w$, ent\u00e3o $v = w$ \\end{itemize} \\end{frame} \\begin{frame}{Consenso} Sejam v\u00e1rios processos. Cada um prop\u00f5e um \u00fanico valor por \\emph{inst\u00e2ncia de consenso}. O objetivo \u00e9 decidir um dentre os valores propostos: \\begin{itemize} \\item Validade: Somente um valor proposto pode ser decidido. \\item Termina\u00e7\u00e3o: Todo processo n\u00e3o falho decide-se. \\item Acordo: Se um processo decide-se por $v$ e outro por $w$, ent\u00e3o $v = w$ \\end{itemize} \\end{frame} \\begin{frame}{Consenso} \u00c9 imposs\u00edvel resolver deterministicamente o problema do consenso em sistema ass\u00edncrono sujeito a falhas. Fischer, Lynch, Patterson, 85 \\pause Mas o consenso \u00e9 resolvido frequentemente em sistemas ass\u00edncronos sujeitos a falhas. Isso porque normalmente estes sistemas se comportam sincronamente. \\end{frame} \\begin{frame}{Consenso} H\u00e1 diversos algoritmos de consenso que terminam quando o sistema se comporta bem. O mais famoso, atualmente, \u00e9 o Paxos. \\href{ http://paxos.systems/index.html}{Leia mais aqui} %TODO: Synod %TODO: Paxos \\end{frame} \\begin{frame}{Primitivas} \\begin{itemize} \\item send\\&receive/enviar\\&receber -- rede \\item propose\\&decide/propor\\&decidir -- consenso \\item broadcast\\&deliver/difundir\\&entregar -- difus\u00e3o \\end{itemize} \\end{frame} \\begin{frame}{Primitivas} \\begin{itemize} \\item send\\&receive/enviar\\&receber -- rede \\item propose\\&decide/propor\\&decidir -- consenso \\item broadcast\\&deliver/difundir\\&entregar -- difus\u00e3o \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Totalmente Ordenada} Dado infinitas inst\u00e2ncias de consenso, pode-se us\u00e1-las para resolver difus\u00e3o at\u00f4mica: \\begin{itemize} \\item Ordene as inst\u00e2ncias de consenso. \\item Para difundir mensagem $m$, proponha a mensagem na menor inst\u00e2ncia $i$ em que n\u00e3o tiver visto uma decis\u00e3o. \\item Se a decis\u00e3o de $i$ n\u00e3o \u00e9 $m$, volte para o passo anterior. \\item Entregue as decis\u00f5es na ordem das inst\u00e2ncias. \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Totalmente Ordenada} Dado infinitas inst\u00e2ncias de consenso, pode-se us\u00e1-las para resolver difus\u00e3o at\u00f4mica: \\begin{itemize} \\item Ordene as inst\u00e2ncias de consenso. \\item Para difundir mensagem $m$, proponha a mensagem na menor inst\u00e2ncia $i$ em que n\u00e3o tiver visto uma decis\u00e3o. \\item Se a decis\u00e3o de $i$ n\u00e3o \u00e9 $m$, volte para o passo anterior. \\item Entregue as decis\u00f5es na ordem das inst\u00e2ncias. \\end{itemize} \\end{frame} \\subsection{Replica\u00e7\u00e3o de M\u00e1quinas de Estados} \\begin{frame}{M\u00e1quina de Estados Replicada} Ativo/Ativo -- Se todos os processos executam a mesma sequ\u00eancia de comandos, todos avan\u00e7am pelos mesmos estados. \\begin{itemize} \\item Mesmo estado inicial \\item Comandos determin\u00edsticos \\item Comandos causalmente relacionados s\u00e3o executados em mesma ordem \\end{itemize} \\end{frame} \\begin{frame}{M\u00e1quina de Estados Replicada} Poss\u00edveis ordens com mesmo efeito? \\begin{itemize} \\item \\lstinline|touch /tmp/file1| \\item \\lstinline|echo \"teste testando\" $>>$ /tmp/file2| \\item \\lstinline|rm /tmp/file1| \\item \\lstinline|mkdir /dir1| \\end{itemize} \\end{frame} \\begin{frame}{M\u00e1quina de Estados Replicada} Poss\u00edveis ordens com mesmo efeito? \\begin{itemize} \\item \\lstinline|touch /tmp/file1| \\item \\lstinline|echo \"teste testando\" $>>$ /tmp/file2| \\item \\lstinline|rm /tmp/file1| \\item \\lstinline|mkdir /dir1| \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Causal} H\u00e1 diversos algoritmos, mas o mais recente e interessante \u00e9 denominado Generalized Paxos. Para saber mais, leia minha disserta\u00e7\u00e3o! \\end{frame} \\begin{frame}{Frameworks para Coordena\u00e7\u00e3o} Diversos sistemas abstraem problemas de coordena\u00e7\u00e3o em sistemas distribu\u00eddos. Estudaremos alguns nas aulas seguintes. \\end{frame} Antes, vamos nos aprofundar no estudo de um protocolo de Consenso/Difus\u00e3o at\u00f4mica. \\subsection{RSM: Estudo de Caso do Raft} \\begin{frame}{Raft} \\url{http://thesecretlivesofdata.com/raft/} \\end{frame} \\section{Estudo de Caso: Paxos} \\begin{frame}{Paxos} %\\begin{itemize} % \\item S\u00ednodo (Synod): consenso % \\item Paxos: Difus\u00e3o At\u00f4mica %\\end{itemize} \\end{frame} \\begin{frame}{Paxos} %\\begin{itemize} % \\item S\u00ednodo (Synod): consenso % \\item Paxos: Difus\u00e3o At\u00f4mica %\\end{itemize} \\end{frame} \\section{Estudo de caso: Atomix Copycat} \\begin{frame}{Atomix Copycat} \\begin{itemize} \\item Framework de replica\u00e7\u00e3o de m\u00e1quinas de estados implementada pela Atomix. \\item Implementa\u00e7\u00e3o do Raft \\item API simples \\item Java 8 (lambdas e futures) \\item \\url{http://atomix.io/copycat/} \\end{itemize} \\end{frame} \\begin{frame}[fragile,allowframebreaks]{Lambda} \\begin{itemize} \\item Classe com um \u00fanico m\u00e9todo. \\begin{lstlisting}[language=java] class Tarefa implements Runnable { public void run(){ while (true) System.out.println(\"Bem vindo a um loop infinito\"); } } new Thread(new Tarefa()).start(); \\end{lstlisting} \\framebreak 1 \\item Classe an\u00f4nima -- uso \u00fanico \\begin{lstlisting}[language=java] new Thread( new Runnable() { public void run(){ while (true) System.out.println(\"Bem vindo a um loop infinito\"); } }).start(); \\end{lstlisting} \\begin{lstlisting}[language=java] new Thread( new Runnable() { public void run(){ while (true) System.out.println(\"Bem vindo a um loop infinito\"); } }).start(); \\end{lstlisting} \\framebreak 1 \\item Lambda \\begin{lstlisting}[language=java] new Thread(() -> { while (true) System.out.println(\"Bem vindo a um loop infinito\"); }).start(); \\end{lstlisting} \\begin{lstlisting}[language=java] new Thread(() -> { while (true) System.out.println(\"Bem vindo a um loop infinito\"); }).start(); \\end{lstlisting} \\framebreak \\item Encadeamento (fluent) \\begin{lstlisting}[language=java] Collection<Pessoa> c = ...; c.stream() .filter(p -> p.idade > 33) .map(Pessoa::sobrenomeNome)//.map(p -> p.sobrenomeNome()) .forEach(s -> System.out.println(s)); \\end{lstlisting} \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Future} \\begin{itemize} \\item Promessa de computa\u00e7\u00e3o e resultado. \\begin{lstlisting}[language=java] ExecutorService executor = Executors.newSingleThreadExecutor(); Future<Integer> futFib = executor.submit(() -> { return Fibonacci(217)}; \\end{lstlisting} 1 2 \\item Quando ser\u00e1 executado? \\pause Em algum momento. \\item Como pegar o resultado? \\begin{lstlisting}[language=java] while (!futFib.isDone()) System.out.println(\"tah calculando...\"); int fib217 = futFib.get(); \\end{lstlisting} 1 \\item Em qual thread? \\pause Em algum thread. Depende do Executor Service usado. \\end{itemize} \\end{frame} \\begin{frame}{Atomix-Raft} \\begin{itemize} \\item Vers\u00e3o >= 2 do copycat \\item Melhor desempenho \\item Documenta\u00e7\u00e3o ruim \\item \\url{https://github.com/atomix/atomix} \\end{itemize} \\end{frame} \\begin{frame}{Atomix-Raft} \\begin{itemize} \\item Vers\u00e3o >= 2 do copycat \\item Melhor desempenho \\item Documenta\u00e7\u00e3o ruim \\item \\url{https://github.com/atomix/atomix} \\end{itemize} \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Vers\u00e3o 1.1.4 \\item Baseado em \\url{http://atomix.io/copycat/docs/getting-started/} \\item C\u00f3digo funcional em \\url{https://github.com/pluxos/atomix_labs} \\end{itemize} \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Vers\u00e3o 1.1.4 \\item Baseado em \\url{http://atomix.io/copycat/docs/getting-started/} \\item C\u00f3digo funcional em \\url{https://github.com/pluxos/atomix_labs} \\end{itemize} \\end{frame} \\begin{frame}{Clone e compile o projeto} \\begin{itemize} \\item Instale depend\u00eancias: git, maven e JDK >= 1.8 (lembre-se que gRPC precisa de JDK <= 1.8) \\item git clone https://github.com/pluxos/atomix\\_labs %https://www.baeldung.com/atomix \\item cd atomix\\_labs \\item cd replication \\item mvn compile \\item mvn test \\end{itemize} \\end{frame} \\begin{frame}{Clone e compile o projeto} \\begin{itemize} \\item Instale depend\u00eancias: git, maven e JDK >= 1.8 (lembre-se que gRPC precisa de JDK <= 1.8) \\item git clone https://github.com/pluxos/atomix\\_labs %https://www.baeldung.com/atomix \\item cd atomix\\_labs \\item cd replication \\item mvn compile \\item mvn test \\end{itemize} \\end{frame} \\begin{frame}[fragile]{mvn test} Resultado esperado. \\begin{verbatim} Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 [INFO] --------------------------------------- [INFO] BUILD SUCCESS [INFO] --------------------------------------- [INFO] Total time: 6.898 s [INFO] Finished at: 2017-10-25T08:38:08-02:00 [INFO] Final Memory: 15M/159M [INFO] --------------------------------------- \\end{verbatim} \\end{frame} \\begin{frame}{Estrutura} Explore o projeto. Na pasta/URL \\url{ https://github.com/pluxos/atomix_labs/tree/master/replication/src/main/java/atomix_lab/state_machine } H\u00e1 tr\u00eas pastas. Analise-as nesta ordem \\begin{itemize} \\item type -- tipos dos dados mantidos pela replica (Edge e Vertex)\\\\ Os tipos s\u00e3o serializable para que o Java saiba como transform\u00e1-los em bytes. \\item command -- estruturas que cont\u00eam informa\u00e7\u00f5es para modificar os tipos\\\\ Os comandos ser\u00e3o enviadas do cliente para o cluster e s\u00e3o naturalmente serializable. \\item client -- cria comandos e os envia para serem executados no cluster\\\\ Respostas podem ser esperadas s\u00edncrona ou assincronamente. \\item server -- recebe os comandos na ordem definida pelo Raft e os executa \\end{itemize} \\end{frame} \\begin{frame}{Lab} O projeto foi constru\u00eddo seguindo as instru\u00e7\u00f5es no tutorial mencionado antes, saltando-se a parte dos snapshots, isto \u00e9: \\begin{itemize} \\item crie um projeto maven\\\\ eclipse tem template para isso \\item adicione depend\u00eancias no pom.xml\\\\ como so criei um projeto, coloquei as depend\u00eancias tanto do cliente quando do servidor \\item defina Command que modifiquem o estado das r\u00e9plicas \\item defina Queries que consultem o estado das r\u00e9plicas \\item implemente a r\u00e9plica para lidar com os comandos \\item implemente o cliente para emitir comandos \\end{itemize} \\end{frame} \\begin{frame}{Lab} O projeto foi constru\u00eddo seguindo as instru\u00e7\u00f5es no tutorial mencionado antes, saltando-se a parte dos snapshots, isto \u00e9: \\begin{itemize} \\item crie um projeto maven\\\\ eclipse tem template para isso \\item adicione depend\u00eancias no pom.xml\\\\ como so criei um projeto, coloquei as depend\u00eancias tanto do cliente quando do servidor \\item defina Command que modifiquem o estado das r\u00e9plicas \\item defina Queries que consultem o estado das r\u00e9plicas \\item implemente a r\u00e9plica para lidar com os comandos \\item implemente o cliente para emitir comandos \\end{itemize} \\end{frame} \\begin{frame}{Lab} Para executar um servidor, voc\u00ea precisa passar como par\u00e2metro \\begin{itemize} \\item identificador do processo (inteiro) \\item IP do processo com identificador 0 \\item porta do processo com identificar 0 \\item IP do processo com identificador 1 \\item porta do processo com identificar 1 \\item ... \\end{itemize} Sabendo seu identificador, o servidor sabe em qual porta escutar e em quais IP/porta se conectar. \\end{frame} \\begin{frame}[fragile]{Lab} Execute tr\u00eas servidores. Usando o maven, da linha de comando, fica assim: \\begin{tiny} \\begin{verbatim} mvn exec:java \\ -Dexec.mainClass=\"atomix_lab.state_machine.server.GraphStateMachine\" \\ -Dexec.args=\"0 127.0.0.1 5000 127.0.0.1 5001 127.0.0.1 5002\" mvn exec:java \\ -Dexec.mainClass=\"atomix_lab.state_machine.server.GraphStateMachine\" \\ -Dexec.args=\"1 127.0.0.1 5000 127.0.0.1 5001 127.0.0.1 5002\" mvn exec:java \\ -Dexec.mainClass=\"atomix_lab.state_machine.server.GraphStateMachine\" \\ -Dexec.args=\"2 127.0.0.1 5000 127.0.0.1 5001 127.0.0.1 5002\" \\end{verbatim} \\end{tiny} %As instru\u00e7\u00f5es, sem quebra, est\u00e3o no README do reposit\u00f3rio. \\end{frame} \\begin{frame}[fragile]{Lab} O cliente n\u00e3o precisa de um identificador, apenas dos pares IP/porta dos servidores. \\begin{itemize} \\item IP do processo com identificador 0 \\item porta do processo com identificar 0 \\item IP do processo com identificador 1 \\item porta do processo com identificar 1 \\item ... \\end{itemize} Para execut\u00e1-lo, use o comando \\begin{tiny} \\begin{verbatim} mvn exec:java -Dexec.mainClass=\"atomix_lab.state_machine.client.GraphClient\" -Dexec.args=\"127.0.0.1 5000 127.0.0.1 5001 127.0.0.1 5002\" \\end{verbatim} \\end{tiny} \\end{frame} \\begin{frame}{Exerc\u00edcio} Uma vez executado o projeto, modifique-o para incluir uma nova opera\u00e7\u00e3o (Command) e nova consulta (Query). \\end{frame} \\section{Servi\u00e7os de Coordena\u00e7\u00e3o} \\begin{frame}{Servi\u00e7os de Coordena\u00e7\u00e3o} \\begin{itemize} \\item Zookeeper \\item Atomix \\item OpenReplica \\end{itemize} \\end{frame} \\begin{frame}{Servi\u00e7os de Coordena\u00e7\u00e3o} \\begin{itemize} \\item Zookeeper \\item Atomix \\item OpenReplica \\end{itemize} \\end{frame} \\subsection{Estudo de Caso: ZooKeeper} \\subsubsection{Vis\u00e3o Geral} \\begin{frame}{ZooKeeper} \\begin{center} \\includegraphics{images/zklogo} \\end{center} \\url{http://zookeeper.apache.org/} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Zoo?} Porqu\u00ea sistemas distribu\u00eddos s\u00e3o como zool\u00f3gicos, com animais de diversas esp\u00e9cies, sendo obrigados a conviver de forma anti-natural. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Zoo?} Porqu\u00ea sistemas distribu\u00eddos s\u00e3o como zool\u00f3gicos, com animais de diversas esp\u00e9cies, sendo obrigados a conviver de forma anti-natural. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{O qu\u00ea?} ZooKeeper is a \\alert{centralized} service for maintaining \\alert{configuration} information, \\alert{naming}, providing distributed \\alert{synchronization}, and providing \\alert{group services}. All of these kinds of services are used in some form or another by \\alert{distributed applications}. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management \\alert{complexity} when the applications are deployed. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{O qu\u00ea?} ZooKeeper is a \\alert{centralized} service for maintaining \\alert{configuration} information, \\alert{naming}, providing distributed \\alert{synchronization}, and providing \\alert{group services}. All of these kinds of services are used in some form or another by \\alert{distributed applications}. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management \\alert{complexity} when the applications are deployed. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{O qu\u00ea?} ZooKeeper is a \\alert{distributed}, open-source \\alert{coordination service for distributed applications}. It exposes a \\alert{simple set of primitives} that distributed applications can build upon to implement higher level services for synchronization, configuration maintenance, and groups and naming. It is designed to be easy to program to, and uses a data model styled after the familiar \\alert{directory tree structure of file systems}. It runs in Java and has bindings for both \\alert{Java} and \\alert{C}. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{O qu\u00ea?} ZooKeeper is a \\alert{distributed}, open-source \\alert{coordination service for distributed applications}. It exposes a \\alert{simple set of primitives} that distributed applications can build upon to implement higher level services for synchronization, configuration maintenance, and groups and naming. It is designed to be easy to program to, and uses a data model styled after the familiar \\alert{directory tree structure of file systems}. It runs in Java and has bindings for both \\alert{Java} and \\alert{C}. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Por qu\u00ea?} Coordination services are notoriously hard to get right. They are especially prone to errors such as race conditions and deadlock. The motivation behind ZooKeeper is to relieve distributed applications the responsibility of implementing coordination services from scratch. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Por qu\u00ea?} Coordination services are notoriously hard to get right. They are especially prone to errors such as race conditions and deadlock. The motivation behind ZooKeeper is to relieve distributed applications the responsibility of implementing coordination services from scratch. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Como?} ZooKeeper allows distributed processes to coordinate with each other through a \\alert{shared hierarchal namespace which is organized similarly to a standard file system}. The name space consists of data registers - called \\alert{znodes}, in ZooKeeper parlance - and these are \\alert{similar to files and directories}. Unlike a typical file system, which is designed for storage, ZooKeeper data is kept \\alert{in-memory}, which means ZooKeeper can achieve \\alert{high throughput and low latency} numbers. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\includegraphics[width=.7\\textwidth]{images/zknamespace} \\end{frame} \\begin{frame}{ZooKeeper} \\includegraphics[width=.7\\textwidth]{images/zknamespace} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Como?} ZooKeeper is replicated.\\\\ ZooKeeper is ordered. \\end{block} \\includegraphics[width=1\\textwidth]{images/zkservice} \\end{frame} \\begin{frame}{ZooKeeper} \\includegraphics[width=1\\textwidth]{images/zkcomponents} \\end{frame} \\begin{frame}{ZooKeeper} \\includegraphics[width=1\\textwidth]{images/zkcomponents} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Como?} ZooKeeper is fast [...] and it performs best where reads are more common than writes, at ratios of around 10:1. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Como?} ZooKeeper is fast [...] and it performs best where reads are more common than writes, at ratios of around 10:1. \\end{block} \\end{frame} \\begin{frame}{Desempenho} \\includegraphics[width=1\\textwidth]{images/zkperfRW_3_2} \\end{frame} \\begin{frame}{Desempenho} \\includegraphics[width=1\\textwidth]{images/zkperfRW_3_2} \\end{frame} \\subsubsection{Uso} \\begin{frame}{ZNodes} \\includegraphics[width=.6\\textwidth]{images/zknamespace} \\begin{itemize} \\item Arquivo e diret\u00f3rio ao mesmo tempo. \\item S\u00e3o (devem ser) pequenos. \\item Operados atomicamente: todo o dado \u00e9 lido/escrito. \\item API simples \\begin{itemize} \\item C: create \\item R: get \\item U: set \\item D: delete \\item *: get children \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Lab} \\begin{itemize} \\item Download: wget \\url{www-eu.apache.org/dist/zookeeper/zookeeper-3.4.10} \\item Unpack: tar xvzf zookeeper*.tgz \\item Config: \\verb|conf/zoo.cfg| $\\Leftarrow$ Copie o exemplo\\\\ %\\verb|tickTime=2000|\\\\ %\\verb|dataDir=/tmp/seuNome/zk0| $\\Leftarrow$\\\\ %\\verb|clientPort=2181| $\\Leftarrow$ \\item \\verb|./bin/zkServer.sh start-foreground| \\item \\verb|./bin/zkCli.sh -server 127.0.0.1:2181| $\\Leftarrow$ \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Lab} \\begin{itemize} \\item Download: wget \\url{www-eu.apache.org/dist/zookeeper/zookeeper-3.4.10} \\item Unpack: tar xvzf zookeeper*.tgz \\item Config: \\verb|conf/zoo.cfg| $\\Leftarrow$ Copie o exemplo\\\\ %\\verb|tickTime=2000|\\\\ %\\verb|dataDir=/tmp/seuNome/zk0| $\\Leftarrow$\\\\ %\\verb|clientPort=2181| $\\Leftarrow$ \\item \\verb|./bin/zkServer.sh start-foreground| \\item \\verb|./bin/zkCli.sh -server 127.0.0.1:2181| $\\Leftarrow$ \\end{itemize} \\end{frame} \\frame{Exemplo} \\begin{frame}{ZNodes} \\begin{itemize} \\item Stat(istics): vers\u00e3o, ACL, timestamps. \\end{itemize} \\end{frame} \\begin{frame}{ZNodes} \\begin{itemize} \\item Stat(istics): vers\u00e3o, ACL, timestamps. \\end{itemize} \\end{frame} \\frame{Exemplo} \\begin{frame}{ZNodes} \\begin{itemize} \\item Updates condicionais. \\end{itemize} \\end{frame} \\begin{frame}{ZNodes} \\begin{itemize} \\item Updates condicionais. \\end{itemize} \\end{frame} \\frame{Exemplo} \\begin{frame}{ZNodes} \\begin{itemize} \\item N\u00f3s ef\u00eameros: presentes enquanto a sess\u00e3o que os criou estiver ativa. \\end{itemize} \\end{frame} \\begin{frame}{ZNodes} \\begin{itemize} \\item N\u00f3s ef\u00eameros: presentes enquanto a sess\u00e3o que os criou estiver ativa. \\end{itemize} \\end{frame} \\frame{Exemplo} \\begin{frame}{ZNodes} \\begin{itemize} \\item Watches: notificam clientes de mudan\u00e7as no n\u00f3 ou em seus filhos. \\item Uso \u00fanico. \\end{itemize} \\end{frame} \\begin{frame}{ZNodes} \\begin{itemize} \\item Watches: notificam clientes de mudan\u00e7as no n\u00f3 ou em seus filhos. \\item Uso \u00fanico. \\end{itemize} \\end{frame} \\frame{Exemplo} \\begin{frame}{Durabilidade?} Todas as opera\u00e7\u00f5es s\u00e3o colocadas em um log em disco. \\end{frame} \\begin{frame}{Durabilidade?} Todas as opera\u00e7\u00f5es s\u00e3o colocadas em um log em disco. \\end{frame} \\subsubsection{Receitas} \\begin{frame}{Receitas} \u00c9 poss\u00edvel resolver diversos problemas encontrados em sistemas distribu\u00eddos usando-se o ZooKeeper. \\end{frame} \\begin{frame}{Rendezvous} Ponto de encontro de processos. \\pause \\begin{itemize} \\item Defina um zNode raiz a ser usado: /rendezvous/app1/ \\pause \\item Cada filho de /rendezvous/app1 corresponde a um processo: \\begin{itemize} \\item IP \\item Porta \\item N\u00famero de processadores \\item ... \\end{itemize} \\item Processo p ao ser iniciado: \\begin{itemize} \\item procura /rendezvous/app1/p \\begin{itemize} \\item se achar, continua \\item se n\u00e3o achar, cria /rendezvous/app1/p \\end{itemize} \\item lista os filhos de /rendezvous/app1 \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Como lidar com sa\u00edda de processos?} \\pause Fa\u00e7a todos os zNodes s\u00e3o ef\u00eameros. \\\\ Quando um n\u00f3 \u00e9 desconectado, o zNode correspondente ser\u00e1 destru\u00eddo. \\end{frame} \\begin{frame}{Como lidar com sa\u00edda de processos?} \\pause Fa\u00e7a todos os zNodes s\u00e3o ef\u00eameros. \\\\ Quando um n\u00f3 \u00e9 desconectado, o zNode correspondente ser\u00e1 destru\u00eddo. \\end{frame} \\begin{frame}{Como detectar mudan\u00e7as no grupo de processos?} Monitore os filhos de /rendezvous/app1\\\\ Sempre que receber notifica\u00e7\u00f5es, refa\u00e7a o c\u00e1lculo do \\emph{membership}. \\end{frame} \\begin{frame}{Como detectar mudan\u00e7as no grupo de processos?} Monitore os filhos de /rendezvous/app1\\\\ Sempre que receber notifica\u00e7\u00f5es, refa\u00e7a o c\u00e1lculo do \\emph{membership}. \\end{frame} \\begin{frame}{Elei\u00e7\u00e3o de L\u00edderes} \\pause Rendezvous.\\\\ \\pause Fa\u00e7a os zNodes sequenciais. \\pause Ordene os zNodes e escolha o primeiro. \\pause Monitore o zNode. Se ele sumir, eleja outro l\u00edder. \\end{frame} \\begin{frame}{Elei\u00e7\u00e3o de L\u00edderes} \\pause Rendezvous.\\\\ \\pause Fa\u00e7a os zNodes sequenciais. \\pause Ordene os zNodes e escolha o primeiro. \\pause Monitore o zNode. Se ele sumir, eleja outro l\u00edder. \\end{frame} \\begin{frame}{Exclus\u00e3o M\u00fatua} Construa uma fila usando n\u00f3s ef\u00eameros e sequenciais. O processo na cabe\u00e7a da fila tem direito de acesso. Em caso de falhas, o processo \u00e9 removido da cabe\u00e7a da fila. \\end{frame} \\begin{frame}{Exclus\u00e3o M\u00fatua} Construa uma fila usando n\u00f3s ef\u00eameros e sequenciais. O processo na cabe\u00e7a da fila tem direito de acesso. Em caso de falhas, o processo \u00e9 removido da cabe\u00e7a da fila. \\end{frame} \\begin{frame}{Compartilhamento de Par\u00e2metros de Configura\u00e7\u00e3o} Pronto! \\end{frame} \\begin{frame}{Compartilhamento de Par\u00e2metros de Configura\u00e7\u00e3o} Pronto! \\end{frame} \\begin{frame}{Receitas} \\begin{itemize} \\item Lock distribu\u00eddo \\item Filas, e.g. de prioridades \\item Barreira \\item Servi\u00e7o de nomes \\item Termina\u00e7\u00e3o em duas fases \\item Contador at\u00f4mico \\end{itemize} \\url{ http://zookeeper.apache.org/doc/trunk/recipes.html } \\end{frame} \\begin{frame}{Curator} \\includegraphics{images/curator-logo} Um livro de receitas implementadas em ZK. \\url{ http://curator.apache.org } \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Crie um zNode /teste \\item Debaixo de /teste, crie tr\u00eas outros, sequenciais \\end{itemize} \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Crie um zNode /teste \\item Debaixo de /teste, crie tr\u00eas outros, sequenciais \\end{itemize} \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Crie um zNode /teste2 \\item Crie um zNode ef\u00eamero \\item Conecte-se com outro cliente \\item Coloque um watch em /teste2 \\item Desconecte o primeiro cliente \\item Observe o evento gerado no segundo cliente \\item Reconecte o primeiro cliente \\end{itemize} \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Crie um zNode /teste2 \\item Crie um zNode ef\u00eamero \\item Conecte-se com outro cliente \\item Coloque um watch em /teste2 \\item Desconecte o primeiro cliente \\item Observe o evento gerado no segundo cliente \\item Reconecte o primeiro cliente \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Multi-node} Crie tr\u00eas arquivos, zoo1.cfg, zoo2.cfg e zoo3.cfg.\\Por exemplo, zoo1.cfg fica assim: \\begin{itemize} \\item \\verb|dataDir=/tmp/lasaro/zoo1| \\Leftarrow \\Leftarrow Diret\u00f3rios distintos. \\item \\verb|server.1=zoo1:2888:3888| \\Leftarrow \\Leftarrow Portas distintas. \\item \\verb|server.2=zoo2:2889:3889| \\item \\verb|server.3=zoo3:2890:3890| \\item \\verb|clientPort=2181| \\Leftarrow \\Leftarrow Portas distintas. \\end{itemize} Crie diret\u00f3rios e arquivos de identifica\u00e7\u00e3o. \\begin{itemize} \\item \\verb|mkdir /tmp/lasaro/zoo1| \\item \\verb|echo 1 > /tmp/lasaro/zoo1/myid| \\end{itemize} Execute servidores. \\begin{itemize} \\item \\verb|./bin/zkServer.sh start conf/zoo1.cfg| \\end{itemize} Use \\verb|start-foreground| para acompanhar a execu\u00e7\u00e3o. \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Crie um znode /contador com valor 0 \\item Descreva como fazer para que os clientes incrementem atomicamente o valor de /contador. \\end{itemize} \\end{frame} \\subsection{Falhas Bizantinas} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos -- Vers\u00e3o 2} Ex\u00e9rcitos est\u00e3o \u00e0s portas de Biz\u00e2ncio, aka Constantinopla, aka Istambul. Todos os ex\u00e9rcitos tem que atacar em conjunto ou se retirar em conjunto. Cada ex\u00e9rcito \u00e9 comandado por um General. Alguns destes preferem atacar, enquanto outros preferem se retirar. Alguns generais podem ter sido comprados, e mandar mensagens discrepantes para os outros, ou simplesmente n\u00e3o mandar mensagens. Fonte: \\href{ http://research.microsoft.com/en-us/um/people/lamport/pubs/byz.pdf}{Lamport , L.; Shostak, R.; Pease, M. (1982). \"The Byzantine Generals Problem\" (PDF). ACM Transactions on Programming Languages and Systems. 4 (3): 382\u2013401. doi:10.1145/357172.357176.} \\end{frame} \\begin{frame}{Generais e Tenentes} Problema pode ser mudado para: \\begin{itemize} \\item Comandante envia ordem. \\item Todos os tenentes leais executam ordem recebida. \\item Comandante pode ser traidor. \\end{itemize} \\end{frame} \\begin{frame}{Generais e Tenentes} Problema pode ser mudado para: \\begin{itemize} \\item Comandante envia ordem. \\item Todos os tenentes leais executam ordem recebida. \\item Comandante pode ser traidor. \\end{itemize} \\end{frame} \\begin{frame}{Generais e Tenentes} Suponha 3 ex\u00e9rcitos. \\ Comandante (traidor) diz \"Ataque!\" Tenente A e \"Retirada!\" tenente B.\\ Ou \\ Comandante diz \"Ataque!\" a ambos. Tenente A segue a ordem mas B se retira. \\pause E se os tenentes trocarem informa\u00e7\u00f5es? \\pause Como diferenciar casos em que Comandante ou Tenente \u00e9 traidor? \\end{frame} \\begin{frame}{Generais e Tenentes} S\u00f3 h\u00e1 solu\u00e7\u00e3o se mais de $\\frac{2}{3}$ dos Generais/Tenentes s\u00e3o leais. \\end{frame} \\begin{frame}{Generais e Tenentes} S\u00f3 h\u00e1 solu\u00e7\u00e3o se mais de $\\frac{2}{3}$ dos Generais/Tenentes s\u00e3o leais. \\end{frame} % http://www.drdobbs.com/cpp/the-byzantine-generals-problem/206904396?pgno=5 \\begin{frame}{Comunica\u00e7\u00e3o} \\begin{itemize} \\item Toda mensagem enviada \u00e9 entregue corretamente. \\item A aus\u00eancia de mensagem pode ser detectada (mensagem Null \u00e9 entregue no lugar) (Sistema s\u00edncrono) \\end{itemize} \\end{frame} \\begin{frame}{Comunica\u00e7\u00e3o} \\begin{itemize} \\item Toda mensagem enviada \u00e9 entregue corretamente. \\item A aus\u00eancia de mensagem pode ser detectada (mensagem Null \u00e9 entregue no lugar) (Sistema s\u00edncrono) \\end{itemize} \\end{frame} \\begin{frame}{4/0} General manda ordens. Aus\u00eancia de ordem = Retirada Tenente repassa ordens Maioria de comandos \u00e9 comando a ser seguido \\end{frame} \\begin{frame}{4/0} General manda ordens. Aus\u00eancia de ordem = Retirada Tenente repassa ordens Maioria de comandos \u00e9 comando a ser seguido \\end{frame} \\begin{frame}{Comunica\u00e7\u00e3o} \\begin{itemize} \\item Toda mensagem enviada \u00e9 entregue corretamente. \\item Toda mensagem \u00e9 assinada. \\item A aus\u00eancia de mensagem pode ser detectada (mensagem Null \u00e9 entregue no lugar) (Sistema s\u00edncrono) \\end{itemize} \\pause \u00c9 poss\u00edvel detectar inconsist\u00eancias e processos bizantinos. \\end{frame} % http://cs.brown.edu/courses/cs138/s16/lectures/19consen-notes.pdf \\section{Outros t\u00f3picos} %TODO \\subsection{Detectores de Falhas} \\subsection{Reconfigura\u00e7\u00e3o} \\begin{frame}{Reconfigura\u00e7\u00e3o da Aplica\u00e7\u00e3o} Na segunda entrega do projeto, voc\u00ea distribuiu a carga do seu banco de dados entre v\u00e1rios n\u00f3s. Caso um n\u00f3 falhe, parte dos seus dados ser\u00e1 perdida. Para corrigir esta defici\u00eancia, na terceira entrega, cada n\u00f3 ser\u00e1 replicado em tr\u00eas vias e, assim, caso um n\u00f3 falhe, outros dois continuar\u00e3o a manter o dado. \\end{frame} \\begin{frame}{Reconfigura\u00e7\u00e3o da Aplica\u00e7\u00e3o} Ainda assim, h\u00e1 problemas. E se mais de um, de um mesmo conjunto de r\u00e9plicas, falhar? \\pause Embora seja pequena a probabilidade de dois n\u00f3s de um mesmo grupo falharem em instantes pr\u00f3ximos, dado tempo suficiente, qualquer evento com probabilidade diferente de 0 acontecer\u00e1. \\pause Precisamos de uma forma de trocar n\u00f3s da aplica\u00e7\u00e3o que falharam por novos n\u00f3s. Este \u00e9 problema denominado Pertin\u00eancia de Grupo ou \\emph{Group Membership} \\end{frame} \\begin{frame}{Group Membership} Para n\u00e3o correr o risco, retire o processo falhos do grupo e coloque outro no lugar! I.e., mude a vis\u00e3o que o sistema de quem \u00e9 o grupo. \\end{frame} \\begin{frame}{Vis\u00f5es} \\includegraphics[width=.7\\textwidth]{images/vc} Fonte: \\href{ https://www.cs.rutgers.edu/~pxk/417/notes/virtual_synchrony.html}{Paul Krzyzanowski} G G \u00e9 o grupo de processos participando do sistema, \u00e9 a Vis\u00e3o do Sistema. \\end{frame} Inicialmente, G G consiste de apenas o processo p p , como o processo que cria o cluster no Atomix. Na sequ\u00eancia, outros processo v\u00e3o se unindo ao grupo atrav\u00e9s de View Changes. Uma vez que p p e q q est\u00e3o no grupo, inicia-se a comunica\u00e7\u00e3o entre eles. Quando r, s r, s e t t aparecem, tamb\u00e9m entram no grupo por meio de uma nova vis\u00e3o. Finalmente, quando ambos p p e q q falham, os outros processo os excluem da vis\u00e3o, e continuam funcionando normalmente. \\begin{frame}{Impossibilidade de Detec\u00e7\u00e3o de Falhas} Em um sistema distribu\u00eddo ass\u00edncrono, \u00e9 imposs\u00edvel distinguir com toda certeza um processo falho (parou de funcionar) de um que est\u00e1 lento. \\pause Como decidir se mudar ou n\u00e3o de vis\u00e3o? \\end{frame} Ou aceita a imprecis\u00e3o e muda quando suspeitar de uma falha, ou corre o risco de ficar esperando \\emph{ad eternum} e n\u00e3o mudar, mesmo quando uma falha aconteceu. \\begin{frame}{Uma ``solu\u00e7\u00e3o''!} Quando suspeitar de falha, reporte suspeita a outros processos, que tamb\u00e9m passar\u00e3o a suspeitar. Tome decis\u00e3o baseado na suspeita, isto \u00e9, troque de vis\u00e3o quando houver suspeita. Pague o pre\u00e7o de uma suspeita errada, isto \u00e9, quando um processo for removido da vis\u00e3o indevidamente, adicione-o novamente. \\end{frame} \\begin{frame}{Sincronismos Virtual} Gerenciamento de Grupo/Group Membership e Comunica\u00e7\u00e3o em Grupo \\begin{itemize} \\item Processos se unem ao grupo \\item Processos saem do grupo \\item Processos enviam mensagens para o grupo \\item Diferentes ordena\u00e7\u00f5es \\begin{itemize} \\item Atomic Multicast \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Sincronismos Virtual} Gerenciamento de Grupo/Group Membership e Comunica\u00e7\u00e3o em Grupo \\begin{itemize} \\item Processos se unem ao grupo \\item Processos saem do grupo \\item Processos enviam mensagens para o grupo \\item Diferentes ordena\u00e7\u00f5es \\begin{itemize} \\item Atomic Multicast \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Vis\u00e3o de Grupo} \\begin{itemize} \\item Vis\u00e3o: conjunto de processos no sistema. \\item Multicast feito para processos na vis\u00e3o. \\item Vis\u00e3o \u00e9 consistente entre os processos. \\item Entrada e sa\u00edda de processos muda a vis\u00e3o. \\end{itemize} \\end{frame} \\begin{frame}{Vis\u00e3o de Grupo} \\begin{itemize} \\item Vis\u00e3o: conjunto de processos no sistema. \\item Multicast feito para processos na vis\u00e3o. \\item Vis\u00e3o \u00e9 consistente entre os processos. \\item Entrada e sa\u00edda de processos muda a vis\u00e3o. \\end{itemize} \\end{frame} \\begin{frame}{Eventos} \\begin{itemize} \\item Mensagem \\item Mudan\u00e7a de Vis\u00e3o \\item Checkpoint \\end{itemize} \\end{frame} \\begin{frame}{Eventos} \\begin{itemize} \\item Mensagem \\item Mudan\u00e7a de Vis\u00e3o \\item Checkpoint \\end{itemize} \\end{frame} \\begin{frame}{Vis\u00f5es} \\includegraphics[width=.7\\textwidth]{images/vc} Fonte: \\href{ https://www.cs.rutgers.edu/~pxk/417/notes/virtual_synchrony.html}{Paul Krzyzanowski} \\end{frame} \\begin{frame}{Sincronismo Virtual} Deve satisfazer \\begin{itemize} \\item Se uma mensagem \u00e9 enviada em uma vis\u00e3o, ela s\u00f3 pode ser entregue naquela vis\u00e3o. \\item Se uma mensagem \u00e9 entregue a um processo correto em uma vis\u00e3o, ent\u00e3o \u00e9 entregue a todos os processos corretos naquela vis\u00e3o. \\item Se um processo n\u00e3o recebe a mensagem, ele n\u00e3o estar\u00e1 na pr\u00f3xima vis\u00e3o. \\item Ao entrar em uma vis\u00e3o, o processo recebe o estado dos outros processos e seu estado se torna equivalente ao de um processo que recebeu todas as mensagens j\u00e1 entregues. \\end{itemize} A troca de Vis\u00e3o \u00e9 uma barreira. \\end{frame} \\begin{frame}{ISIS Toolkit} Sistema de Sincronismo Virtual tolerante a falhas desenvolvido por Ken Birman, Cornell University (\\url{ http://www.cs.cornell.edu/Info/Projects/Isis/ })\\ ISIS: An Environment for Constructing Fault-Tolerant Distributed Systems. Kenneth Birman, D. Skeen, A. El Abbadi, W. C. Dietrich and T. Raeuchle. May 1983. \\begin{itemize} \\item 100.000's/s \\item Em uso at\u00e9 2009 \\item NY Stock Exchange \\item Swiss Exchange \\item US Navy \\item Precursos de sistemas como Zookeeker \\item Totem, ISIS, Horus, Transis (Parti\u00e7\u00f5es), \\alert{Spread}, \\alert{Ensamble}, \\alert{JGroups}, Appia, QuickSilver, vSynch (n\u00e9e ISIS 2) \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Totalmente Ordenada} \\begin{itemize} \\item Corretude: Se um processo p p envia uma mensagem m m para processos no grupo G G , ent\u00e3o se p p n\u00e3o falha, todos os processos corretos em G G recebem a mensagem. 1 2 3 4 5 \\item Acordo: Se um processo correto em $G$ recebe uma mensagem $m$, ent\u00e3o todo processo correto em $G$ recebe $m$ \\item Ordena\u00e7\u00e3o: Se um processo recebe mensagem $m$ e depois $n$, ent\u00e3o qualquer processo que receba a mensagem $n$ deve primeiro receber $m$ \\item Validade: Somente mensagens difundidas s\u00e3o entregues. \\end{itemize} E se mandarmos mensagens do tipo ``A partir da entrega desta mensagem, o grupo de processos \u00e9 G G .'' \\end{frame} \\begin{frame}{Sincronismo Virtual} Deve satisfazer \\begin{itemize} \\item Se uma mensagem \u00e9 enviada em uma vis\u00e3o, ela s\u00f3 pode ser entregue naquela vis\u00e3o.\\ Mensagens de troca de vis\u00e3o podem incrementar um contador\\ Mensagens normais carregam o valor atual do contador\\ Mensagem descartada se valor na mensagem \u00e9 maior contador no destinat\u00e1rio 1 2 3 4 5 6 7 8 9 \\item Se uma mensagem \u00e9 entregue a um processo correto em uma vis\u00e3o, ent\u00e3o \u00e9 entregue a todos os processos corretos naquela vis\u00e3o.\\\\ Pela difus\u00e3o, se a mensagem de troca for entregue para um processo, ser\u00e1 entregue para todos os corretos, na mesma ordem Se mensagem comum for entregue antes para algum, ser\u00e1 entregue ante para todos. \\item Se um processo n\u00e3o recebe a mensagem, ele n\u00e3o estar\u00e1 na pr\u00f3xima vis\u00e3o.\\\\ Se um processo n\u00e3o recebe uma mensagem comum que foi entregue pelos outros, ent\u00e3o ele n\u00e3o troca de vis\u00e3o. \\item Ao entrar em uma vis\u00e3o, o processo recebe o estado dos outros processos e seu estado se torna equivalente ao de um processo que recebeu todas as mensagens j\u00e1 entregues.\\\\ Caso contr\u00e1rio, n\u00e3o haveria porqu\u00ea trocar os processos \\end{itemize} \\end{frame} \\begin{frame}{State Transfer} \\includegraphics[width=.7\\textwidth]{images/state_transfer} \\href{ http://www.gsd.inesc-id.pt/~ler/docencia/tfd0405/bib/BSRNA.pdf}{Building Secure and Reliable Network Applications} \\end{frame} \\begin{frame}{Difus\u00e3o At\u00f4mica \\equiv \\equiv Sincronismo Virtual?} Seria uma boa aproxima\u00e7\u00e3o, mas que poderia ser relaxada. Em certas aplica\u00e7\u00f5es, FIFO ou Causal seriam suficientes dentro da vis\u00e3o, desde que a mensagem de mudan\u00e7a da vis\u00e3o seja totalmente ordenada com as comuns. \\end{frame} \\begin{frame}{Particionamento} E se dois subconjuntos mutuamente exclusivos se formarem e criarem vis\u00f5es independentes? \\pause \\emph{Primary Partition Model} -- Somente a parti\u00e7\u00e3o prim\u00e1ria pode mudar de vis\u00e3o. \\pause Lembram-se que no Raft somente uma parti\u00e7\u00e3o com uma maioria de processo pode decidir? \u00c9 exatamente a mesma situa\u00e7\u00e3o, pois os processos est\u00e3o chegando a um Consenso sobre quem \u00e9 a nova vis\u00e3o. \\end{frame} \\begin{frame}{Extended Virtual Synchrony} \\emph{Primary Partition Model} -- N\u00e3o \u00e9 adequado a uma rede geograficamente distribu\u00edda (Internet scale). \\pause Lembram-se que no Raft somente uma parti\u00e7\u00e3o com uma maioria de processo pode decidir? \u00c9 exatamente a mesma situa\u00e7\u00e3o, pois os processos est\u00e3o chegando a um Consenso sobre quem \u00e9 a nova vis\u00e3o. \\end{frame} \u00c9 poss\u00edvel que no trabalho dois, alguns de voc\u00eas tenham tentado gerar locks do sistema para manipular objetos distribu\u00eddos no sistema. Esse locks s\u00e3o perigosos por qu\u00ea processos pode travar/quebrar/falhar e nunca liberarem os locks. O uso de um algoritmo VS poderia ser usado para resolver o problema.\\right Swim Lista de Falhas Reais","title":"Toler\u00e2ncia a Falhas"},{"location":"teaching/gbc074gsi028/fault/#tolerancia-a-falhas","text":"Neste cap\u00edtulo discutiremos o qu\u00ea s\u00e3o sistemas distribu\u00eddos, por qu\u00ea os desenvolvemos, e damos uma vis\u00e3o geral de como isto \u00e9 feito.","title":"Toler\u00e2ncia a Falhas"},{"location":"teaching/gbc074gsi028/fault/#dependabilidade","text":"Ao escrevermos nossos softwares, queremos que sejam usados para resolver problemas, mesmo que import\u00e2ncia do problema esteja em um espectro bem vasto, indo, por exemplo, da execu\u00e7\u00e3o de um cirurgia ocular remota, ao controle de uma usina hidrel\u00e9trica, \u00e0 jogar truco contra um computador. Independentemente do problema sendo resolvido, gostar\u00edamos de poder contar com o sistema, de poder depender nele para executar sua tarefa. Desta situa\u00e7\u00e3o, surge a ideia de dependabilidade, isto \u00e9, de um sistema ter a propriedade de que podemos depender do mesmo. Em computa\u00e7\u00e3o distribu\u00edda, componentes dependem uns dos outros para a realiza\u00e7\u00e3o de tarefas. Assim, componentes que quer ser \"depend\u00e1veis\" (do ingl\u00eas, dependable ), pois se n\u00e3o o forem, os demais componentes n\u00e3o poder\u00e3o executar suas tarefas, rendendo o sistema como um todo in\u00fatil. Assim, dizemos que um componente C C depende de um componente C' C' se a corretude do comportamento de C C depende da corretude do componente C' C' . E que um componente \u00e9 ``depend\u00e1vel'' (\\emph{dependable}) na medida que outros podem depender dele. De acordo com Laprie et al , tem-se dependabilidade quando os seguintes atributos est\u00e3o presentes. Disponibilidade ( Availability ) - Prontid\u00e3o para uso. Confiabilidade/Fiabilidade (*Reliability) - Continuidade do servi\u00e7o. Manutenabilidade ( Maintainability ) - Facilidade de reparo. Seguran\u00e7a ( Safety ) - Toler\u00e2ncia a cat\u00e1strofes. Integridade ( Integrity ) - Toler\u00e2ncia a modifica\u00e7\u00f5es. Confidencialidade (*Confidentiality) - Informa\u00e7\u00e3o somente a quem devido. A combin\u00e7\u00e3o das tr\u00eas \u00faltimas propriedades \u00e9 tamb\u00e9m chamadas de Seguran\u00e7a ( Security ). Como obst\u00e1culos para se conseguir estes atributos est\u00e3o os seguintes obst\u00e1culos, ou amea\u00e7as: Fault - Falha (Falta): bug -- \\lstinline|<=| em vez de \\lstinline|<| (pode nunca afetar a execu\u00e7\u00e3o). Error - Erro (Erro): manifesta\u00e7\u00e3o do bug -- itera\u00e7\u00e3o passa do ponto. (Pode n\u00e3o ser observ\u00e1vel pelo usu\u00e1rio.) Failure - Defeito (Falha): problema vis\u00edvel -- tela azul","title":"Dependabilidade"},{"location":"teaching/gbc074gsi028/fault/#modelos","text":"\\section{Dependabilidade} \\subsection{Introdu\u00e7\u00e3o} \\begin{frame}{Dependabilidade} \\begin{block}{} Um componente prov\u00ea servi\u00e7os a um cliente.\\\\ Para prover o servi\u00e7o, o componente pode \\alert{depender} de outros. \\end{block} \\begin{block}{} Um componente $C$ depende de um componente $C'$ se a corretude do comportamento de $C$ depende da corretude do componente $C'$. \\end{block} \\begin{block}{} Um componente $C$ depende de um componente $C'$ se a corretude do comportamento de $C$ depende da corretude do componente $C'$. \\end{block} \\begin{block}{} Um componente \u00e9 ``depend\u00e1vel'' (\\emph{dependable}) na medida que outros podem depender dele. \\end{block} \\end{frame} \\begin{frame}{Dependabilidade} O que queremos (Atributos) \\begin{itemize} \\item Disponibilidade (\\emph{Availability})-- Prontid\u00e3o para uso. \\item Confiabilidade/Fiabilidade (\\emph{Reliability}) -- Continuidade do servi\u00e7o. \\item Manutenabilidade (\\emph{Maintainability}) -- Facilidade de reparo. \\~ \\~\\ 1 2 3 4 \\item Seguran\u00e7a (\\emph{Safety}) -- Toler\u00e2ncia a cat\u00e1strofes. \\item Integridade (\\emph{Integrity}) -- Toler\u00e2ncia a modifica\u00e7\u00f5es \\item Confidencialidade (\\emph{Confidentiality}) -- Informa\u00e7\u00e3o somente a quem devido. \\item Seguran\u00e7a (\\emph{Security}) -- Soma dos tr\u00eas anteriores. \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Dependabilidade} O que gostar\u00edamos de evitar (Amea\u00e7as) \\begin{itemize} \\item Fault -- Falha (Falta): bug -- \\lstinline|<=| em vez de \\lstinline|<| (pode nunca afetar a execu\u00e7\u00e3o). \\item Error -- Erro (Erro): manifesta\u00e7\u00e3o do bug -- itera\u00e7\u00e3o passa do ponto. (Pode n\u00e3o ser observ\u00e1vel pelo usu\u00e1rio.) \\item Failure -- Defeito (Falha): problema vis\u00edvel -- tela azul \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Dependabilidade} O que gostar\u00edamos de evitar (Amea\u00e7as) \\begin{itemize} \\item Fault -- Falha (Falta): bug -- \\lstinline|<=| em vez de \\lstinline|<| (pode nunca afetar a execu\u00e7\u00e3o). \\item Error -- Erro (Erro): manifesta\u00e7\u00e3o do bug -- itera\u00e7\u00e3o passa do ponto. (Pode n\u00e3o ser observ\u00e1vel pelo usu\u00e1rio.) \\item Failure -- Defeito (Falha): problema vis\u00edvel -- tela azul \\end{itemize} \\end{frame} \\begin{frame}{Ariane 5} ``The Explosion of the Ariane 5 On June 4, 1996 an unmanned Ariane 5 rocket launched by the European Space Agency exploded just forty seconds after its lift-off [...] after a decade of development costing $7B. The destroyed rocket and its cargo were valued at $500M. [...] the failure was a software error [...] a 64 bit floating point number [...] was converted to a 16 bit signed integer. The number was larger than 32,767, the largest integer storeable in a 16 bit signed integer, and thus the conversion failed.'' \\includegraphics[width=.7\\textwidth]{images/ariane5} \\href{ http://www-users.math.umn.edu/~arnold/disasters/ariane.html}{Fonte } \\end{frame} O erro gerado foi tratado como input, causando outros erros, que geraram instabilidade e que levou o sistema a se auto-destruir. \\begin{frame}{Dependabilidade} Como evitar (Meios) \\begin{itemize} \\item Preven\u00e7\u00e3o de falhas: \\pause escreva sem bugs!\\ Especifica\u00e7\u00f5es formais; prova de corretude; model checkers;... 1 2 3 4 5 6 7 \\item Remo\u00e7\u00e3o de falhas: \\pause resolva seus bugs!\\\\ Testes; manuten\u00e7\u00e3o. \\item Previs\u00e3o de falhas: \\pause estime quando elas se manifestar\u00e3o! Reinicie processos frequentemente. \\item Toler\u00e2ncia a falhas: \\pause conviva e mascare falhas. \\end{itemize} \\end{frame} \\begin{frame}{Subaru SUVs -- 2018} \\includegraphics[width=.45\\textwidth]{images/subaru} \\href{ https://spectrum.ieee.org/riskfactor/computing/it/coding-error-leads-293-subaru-ascents-to-the-car-crusher}{Fonte } \\end{frame} \\begin{frame}{Car Hack -- 2017} \\includegraphics[width=.4\\textwidth]{images/carhack} \\href{ https://www.wired.com/story/car-hack-shut-down-safety-features/}{Fonte } \\end{frame} \\begin{frame}{Toler\u00e2ncia a falhas} Dependendo dos efeitos e tratamentos. \\begin{itemize} \\item Fail safe -- defeito n\u00e3o leva a comportamento inseguro (sistema de entretenimento no avi\u00e3o) \\item Fail soft -- graceful degradation (sistema de controle de v\u00f4o) \\item Fail fast -- para o fluxo de defeitos (e poss\u00edvel rein\u00edcio) \\vspace{1cm} 1 2 \\item Robusto -- erros n\u00e3o atrapalham execu\u00e7\u00e3o (tratamento de exce\u00e7\u00f5es) \\item Quebradi\u00e7o (\\emph{brittle}) -- n\u00e3o resiliente a falhas \\end{itemize} \\end{frame} \\begin{frame}{Fail Fast -- Cadeia de supervis\u00e3o} \\includegraphics[width=.7\\textwidth]{images/httpatomoreillycomsourceoreillyimages300817} \\end{frame} \\begin{frame}{Fail Fast -- Cadeia de supervis\u00e3o} \\includegraphics[width=.7\\textwidth]{images/httpatomoreillycomsourceoreillyimages300817} \\end{frame} \\begin{frame}{Toler\u00e2ncia a Falhas -- Exemplos} \\begin{itemize} \\item Pneu estepe \\item Gerador de eletricidade em casa \\item Cal\u00e7a extra na mala \\item Uber, em vez do \u00f4nibus \\end{itemize} \\pause O que h\u00e1 de comum? \\end{frame} \\begin{frame}{Toler\u00e2ncia a Falhas -- Exemplos} \\begin{itemize} \\item Pneu estepe \\item Gerador de eletricidade em casa \\item Cal\u00e7a extra na mala \\item Uber, em vez do \u00f4nibus \\end{itemize} \\pause O que h\u00e1 de comum? \\end{frame} \\begin{frame}{Redund\u00e2ncia} Componentes extra, para uso em caso de defeitos. Aus\u00eancia de um SPOF -- \\emph{Single Point of Failure} \\pause \\begin{itemize} \\item Mais projeto \\item Mais testes \\item Mais custo \\item Mais tempo \\item Peso extra \\end{itemize} \\pause Custo x Beneficio -- Custo da redund\u00e2ncia, Probabilidade de falha, beneficio.\\ \\pause Pneu x Motor x Radio \\end{frame} \\begin{frame}[allowframebreaks]{Tipos de defeitos} \\begin{itemize} \\item Quebra/Crash: componente para de funcionar. \\begin{itemize} \\item Fail-stop -- defeito \u00e9 detect\u00e1vel (timeout, por exemplo).\\\\ E se o problema for a rede? \\item Fail-silent -- defeito pode n\u00e3o ser not\u00e1vel. \\item Fail-recover -- voltam a executar. \\end{itemize} 1 2 3 4 5 6 7 8 9 10 11 12 13 \\item Omiss\u00e3o: componente n\u00e3o executa a\u00e7\u00f5es. \\begin{itemize} \\item Requisi\u00e7\u00e3o n\u00e3o atendida \\item Mensagem n\u00e3o transmitida \\end{itemize} \\item Temporiza\u00e7\u00e3o: prazos n\u00e3o s\u00e3o respeitados. \\item Arbitr\u00e1ria: qualquer coisa pode acontecer. \\begin{itemize} \\item Resposta: a\u00e7\u00f5es s\u00e3o executadas incorretamente mas sem maldade. \\item Arbitr\u00e1ria com detec\u00e7\u00e3o por falha de identifica\u00e7\u00e3o \\end{itemize} \\end{itemize} Fail-stop \\in \\in Quebra \\in \\in Omiss\u00e3o \\in \\in Temporiza\u00e7\u00e3o \\in \\in Arbitr\u00e1ria \\end{frame} \\begin{frame}{Resposta} \\begin{itemize} \\item ALU defeituosa \\end{itemize} \\end{frame} \\begin{frame}{Resposta} \\begin{itemize} \\item ALU defeituosa \\end{itemize} \\end{frame} \\begin{frame}{Arbitr\u00e1ria} \\begin{itemize} \\item Bug \\item Hacking \\item V\u00edrus \\end{itemize} \\end{frame} \\begin{frame}{Arbitr\u00e1ria} \\begin{itemize} \\item Bug \\item Hacking \\item V\u00edrus \\end{itemize} \\end{frame} \\begin{frame}{Prepare-se para a vida de desenvolvedor} \\begin{itemize} \\item Falhas intermitentes -- e.g., picos de energia, comportamento emergente, \\item Heisenbugs -- inobserv\u00e1vel \\item Schroedinbugs -- inexistente at\u00e9 que observado \\end{itemize} \\end{frame} \\begin{frame}{Prepare-se para a vida de desenvolvedor} \\begin{itemize} \\item Falhas intermitentes -- e.g., picos de energia, comportamento emergente, \\item Heisenbugs -- inobserv\u00e1vel \\item Schroedinbugs -- inexistente at\u00e9 que observado \\end{itemize} \\end{frame} Heisenbug The name may seem to rhyme well with Heisenberg, but the Heisenbug is actually \"a bug that disappears or alters its behavior when one attempts to probe or isolate it.\" The Freenet Project describes a Heisenbug in certain Java virtual machines. Bohrbug The Bohrbug is a sort of antonym of the Heisenbug, as this bug does not disappear or alter its characteristics when it is researched. Mandelbug The Mandelbug, named after Benoit Mandelbrot (think Mandelbrot set), is a bug whose underlying causes are so complex and obscure as to make its behavior appear chaotic. Schroedinbug The Schroedinbug is a design or implementation bug in a program that doesn't manifest until someone reading source or using the program in an unusual way notices that it never should have worked, at which point the program promptly stops working for everybody until fixed. Here, an Office developer describes \"stupid SQL tricks\" to get rid of a \"classic Schroedinbug.\" \\begin{frame}{Correla\u00e7\u00e3o entre falhas?} N-Version programming \\begin{itemize} \\item M\u00faltiplos times \\item M\u00faltiplas implementa\u00e7\u00f5es do mesmo sistema \\item Falhas independentes \\vspace{1cm} \\item Custo maior \\item Erros de especifica\u00e7\u00e3o s\u00e3o reproduzidos \\item Times diferentes, mas erros iguais \\end{itemize} \\end{frame} \\begin{frame}{Correla\u00e7\u00e3o entre falhas?} N-Version programming \\begin{itemize} \\item M\u00faltiplos times \\item M\u00faltiplas implementa\u00e7\u00f5es do mesmo sistema \\item Falhas independentes \\vspace{1cm} \\item Custo maior \\item Erros de especifica\u00e7\u00e3o s\u00e3o reproduzidos \\item Times diferentes, mas erros iguais \\end{itemize} \\end{frame} \\begin{frame}{Foco} Falhas do tipo crash. \\end{frame} \\begin{frame}{Foco} Falhas do tipo crash. \\end{frame} \\begin{frame}{Redund\u00e2ncia de Processos} Como lidar com falhas de processos? Tenha m\u00faltiplos, tal que se um falha, outros podem continuar executando o servi\u00e7o. \\begin{itemize} \\item Ativo/Ativo \\item Mestre/Escravo \\item Replica\u00e7\u00e3o em cadeia \\item ... \\end{itemize} \\end{frame} \\subsection{Coordena\u00e7\u00e3o} \\begin{frame}{Coordena\u00e7\u00e3o} Para replicar, precisamos coordenar as execu\u00e7\u00f5es dos processos, mas como? \\end{frame} \\begin{frame}{Coordena\u00e7\u00e3o} Para replicar, precisamos coordenar as execu\u00e7\u00f5es dos processos, mas como? \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} \\begin{itemize} \\item A e B deve atacar C \\item Se A e B atacam juntos, ganham \\item Se atacarem separados, s\u00e3o ambos derrotados. \\item Comunica\u00e7\u00e3o por mensageiros, \\begin{itemize} \\item que podem se perder e levar muito tempo para chegar \\item podem ser mortos no caminho \\end{itemize} \\pause \\item Atacamos ao amanhecer! (rel\u00f3gios sincronizados) \\end{itemize} \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} \\begin{itemize} \\item A e B deve atacar C \\item Se A e B atacam juntos, ganham \\item Se atacarem separados, s\u00e3o ambos derrotados. \\item Comunica\u00e7\u00e3o por mensageiros, \\begin{itemize} \\item que podem se perder e levar muito tempo para chegar \\item podem ser mortos no caminho \\end{itemize} \\pause \\item Atacamos ao amanhecer! (rel\u00f3gios sincronizados) \\end{itemize} \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Ser\u00e1 que A n\u00e3o mandou uma resposta? Ser\u00e1 que A foi destru\u00eddo? Ser\u00e1 que o mensageiro morreu? Ser\u00e1 que parou em um inferninho? \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Ser\u00e1 que A n\u00e3o mandou uma resposta? Ser\u00e1 que A foi destru\u00eddo? Ser\u00e1 que o mensageiro morreu? Ser\u00e1 que parou em um inferninho? \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Como saber se o outro recebeu a mensagem e ir\u00e1 atacar ao mesmo tempo? \\pause Mensagem de confirma\u00e7\u00e3o. \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Como saber se o um recebeu a confirma\u00e7\u00e3o? \\pause Confirma\u00e7\u00e3o da confirma\u00e7\u00e3o! \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Como saber se o outro/um ...? \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Como saber se o outro/um ...? \\end{frame} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos} Nesse cen\u00e1rio, at\u00e9 simples, coordenar os dois processos \u00e9 \\alert{imposs\u00edvel}! \\pause \u00c9 imposs\u00edvel garantir que chegar\u00e3o a um \\emph{acordo}. \\end{frame} \\section{Acordo} \\subsection{Comunica\u00e7\u00e3o em Grupo} \\begin{frame}{Acordo} Dependendo do modelo, pode ser muito f\u00e1cil ou imposs\u00edvel fazer com que um grupo de processos concorde sobre como agir/entre em acordo. \\end{frame} Um dos fatores \u00e9 como o grupo \u00e9 organizado. \\begin{frame}{Grupos de Processos} Grupos podem ser organizados de diferentes formas, dependendo da aplica\u00e7\u00e3o. \\includegraphics[width=.5\\textwidth]{images/08-03} \\includegraphics[width=.45\\textwidth]{images/chain} Assumindo um grupo est\u00e1tico (sem entrada e sa\u00edda de processos), em que todos conversam com todos diretamente (grafo completo). \\end{frame} \u00c9 mais f\u00e1cil, mas n\u00e3o trivial neste modelo. Vejamos o problema de difus\u00e3o confi\u00e1vel. Mas antes, vamos definir. \\begin{frame}{Correto x Falho} Um processo \u00e9 correto se ele n\u00e3o falha. \\end{frame} \\begin{frame}{Correto x Falho} Um processo \u00e9 correto se ele n\u00e3o falha. \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} \\begin{itemize} \\item Corretude: Se um processo \\alert{correto} p p difunde uma mensagem m m para processos no grupo G G , ent\u00e3o todos os processos corretos em G G entregam a mensagem. 1 2 3 \\item Acordo: Se um processo correto em $G$ entrega uma mensagem $m$, ent\u00e3o todo processo correto em $G$ entrega $m$. \\item Validade: Somente mensagens difundidas s\u00e3o entregues. \\end{itemize} \\end{frame} \\begin{frame}{Terminologia} \\begin{itemize} \\item Enviar/Receber: rede \\item Difundir/Entregar: difus\u00e3o 1 \\item Corretude x Progresso \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Algoritmo? \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Algoritmo? \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Para p p difundir m m para G G \\begin{itemize} \\item <span><span class=\"MathJax_Preview\">p</span><script type=\"math/tex\">p envia m m para todo q \\in G q \\in G \\item Todo processo q\\in G q\\in G que receber a mensagem, envia m_{ack} m_{ack} para p p \\item Ao receber ack de todos os processos q \\in G q \\in G , p p para de retransmitir e entrega m m . \\end{itemize} \\pause Confi\u00e1vel? Isto \u00e9, satisfaz as duas propriedades? \\pause e se um dos receptores falhar? \\pause Assumamos detector de falhas perfeito. \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Para p p difundir m m para G G \\begin{itemize} \\item <span><span class=\"MathJax_Preview\">p</span><script type=\"math/tex\">p envia m m para todo q \\in G q \\in G \\item Todo processo q\\in G q\\in G que receber a mensagem, envia m_{ack} m_{ack} para p p \\item Ao receber ack de todos os processos \\alert{corretos} q \\in G q \\in G , p p para de retransmitir e entrega m m . \\end{itemize} \\pause Pq p p s\u00f3 entrega m m no final? \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Posso assumir TCP como protocolo de comunica\u00e7\u00e3o? \\begin{itemize} \\item $p$ envia $m$ para $G$ \\item $p$ entrega $m$ \\end{itemize} \\begin{itemize} \\item $p$ envia $m$ para $G$ \\item $p$ entrega $m$ \\end{itemize} \\pause N\u00e3o! TCP n\u00e3o \u00e9 confi\u00e1vel neste sentido. \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Assuma m\u00e1ximo de f f falhas, fail stop \\begin{itemize} \\item <span><span class=\"MathJax_Preview\">p</span><script type=\"math/tex\">p envia m m para processos em G G . \\item Todo processo q \\in G q \\in G que receber m m \\begin{itemize} \\item envia m_{ack} m_{ack} \\item repassa m m para G G processos. \\end{itemize} \\item Mensagens s\u00e3o retransmitidas de tempos em tempos. \\item Ao receber f+1 f+1 acks, entrega m m . \\end{itemize} % https://www.youtube.com/watch?v=uzcALT7sHew \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel} Assuma m\u00e1ximo de f f falhas e uso de TCP \\begin{itemize} \\item <span><span class=\"MathJax_Preview\">p</span><script type=\"math/tex\">p envia m m para processos em G G . \\item Em caso de quebra/falha de conex\u00e3o, substitua destinat\u00e1rio. \\item Todo processo q \\in G q \\in G que receber m m , repassa m m para os outros processos. \\item Entrega m m . \\end{itemize} \\pause Confi\u00e1vel? Somente se conex\u00f5es quebradas for reestabelecidas e mensagens reenviadas. \\pause Escal\u00e1vel? \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel FIFO} \\begin{itemize} \\item Corretude. \\item Acordo. \\item Validade. \\item FIFO: Se $p$ difunde $m$ e ent\u00e3o $n$, e se $q$ entrega $n$, ent\u00e3o $q$ entrega $m$ antes $n$. \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Confi\u00e1vel FIFO} \\begin{itemize} \\item Corretude. \\item Acordo. \\item Validade. \\item FIFO: Se $p$ difunde $m$ e ent\u00e3o $n$, e se $q$ entrega $n$, ent\u00e3o $q$ entrega $m$ antes $n$. \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Totalmente Ordenada} \\begin{itemize} \\item Corretude: Se um processo p p difunde uma mensagem m m para processos no grupo G G , e se p p n\u00e3o falha, ent\u00e3o todos os processos corretos em G G entregam m m \\item Acordo: Se um processo correto q q em G G entrega uma mensagem m m , ent\u00e3o todo processo correto em G G entrega m m . \\item Ordena\u00e7\u00e3o: Se um processo entrega mensagem m m e depois n n , ent\u00e3o qualquer processo que entregue a mensagem n n deve primeiro entregar m m . \\item Validade: Somente mensagens difundidas s\u00e3o entregues. \\end{itemize} \\pause Algoritmo? \\pause Resolver diretamente este problema n\u00e3o \u00e9 trivial. Por isso, veremos primeiro o problema do Consenso Distribu\u00eddo. \\end{frame} \\begin{frame}{Consenso} Sejam v\u00e1rios processos. Cada um prop\u00f5e um \u00fanico valor por \\emph{inst\u00e2ncia de consenso}. O objetivo \u00e9 decidir um dentre os valores propostos: \\begin{itemize} \\item Validade: Somente um valor proposto pode ser decidido. \\item Termina\u00e7\u00e3o: Todo processo n\u00e3o falho decide-se. \\item Acordo: Se um processo decide-se por $v$ e outro por $w$, ent\u00e3o $v = w$ \\end{itemize} \\end{frame} \\begin{frame}{Consenso} Sejam v\u00e1rios processos. Cada um prop\u00f5e um \u00fanico valor por \\emph{inst\u00e2ncia de consenso}. O objetivo \u00e9 decidir um dentre os valores propostos: \\begin{itemize} \\item Validade: Somente um valor proposto pode ser decidido. \\item Termina\u00e7\u00e3o: Todo processo n\u00e3o falho decide-se. \\item Acordo: Se um processo decide-se por $v$ e outro por $w$, ent\u00e3o $v = w$ \\end{itemize} \\end{frame} \\begin{frame}{Consenso} \u00c9 imposs\u00edvel resolver deterministicamente o problema do consenso em sistema ass\u00edncrono sujeito a falhas. Fischer, Lynch, Patterson, 85 \\pause Mas o consenso \u00e9 resolvido frequentemente em sistemas ass\u00edncronos sujeitos a falhas. Isso porque normalmente estes sistemas se comportam sincronamente. \\end{frame} \\begin{frame}{Consenso} H\u00e1 diversos algoritmos de consenso que terminam quando o sistema se comporta bem. O mais famoso, atualmente, \u00e9 o Paxos. \\href{ http://paxos.systems/index.html}{Leia mais aqui} %TODO: Synod %TODO: Paxos \\end{frame} \\begin{frame}{Primitivas} \\begin{itemize} \\item send\\&receive/enviar\\&receber -- rede \\item propose\\&decide/propor\\&decidir -- consenso \\item broadcast\\&deliver/difundir\\&entregar -- difus\u00e3o \\end{itemize} \\end{frame} \\begin{frame}{Primitivas} \\begin{itemize} \\item send\\&receive/enviar\\&receber -- rede \\item propose\\&decide/propor\\&decidir -- consenso \\item broadcast\\&deliver/difundir\\&entregar -- difus\u00e3o \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Totalmente Ordenada} Dado infinitas inst\u00e2ncias de consenso, pode-se us\u00e1-las para resolver difus\u00e3o at\u00f4mica: \\begin{itemize} \\item Ordene as inst\u00e2ncias de consenso. \\item Para difundir mensagem $m$, proponha a mensagem na menor inst\u00e2ncia $i$ em que n\u00e3o tiver visto uma decis\u00e3o. \\item Se a decis\u00e3o de $i$ n\u00e3o \u00e9 $m$, volte para o passo anterior. \\item Entregue as decis\u00f5es na ordem das inst\u00e2ncias. \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Totalmente Ordenada} Dado infinitas inst\u00e2ncias de consenso, pode-se us\u00e1-las para resolver difus\u00e3o at\u00f4mica: \\begin{itemize} \\item Ordene as inst\u00e2ncias de consenso. \\item Para difundir mensagem $m$, proponha a mensagem na menor inst\u00e2ncia $i$ em que n\u00e3o tiver visto uma decis\u00e3o. \\item Se a decis\u00e3o de $i$ n\u00e3o \u00e9 $m$, volte para o passo anterior. \\item Entregue as decis\u00f5es na ordem das inst\u00e2ncias. \\end{itemize} \\end{frame} \\subsection{Replica\u00e7\u00e3o de M\u00e1quinas de Estados} \\begin{frame}{M\u00e1quina de Estados Replicada} Ativo/Ativo -- Se todos os processos executam a mesma sequ\u00eancia de comandos, todos avan\u00e7am pelos mesmos estados. \\begin{itemize} \\item Mesmo estado inicial \\item Comandos determin\u00edsticos \\item Comandos causalmente relacionados s\u00e3o executados em mesma ordem \\end{itemize} \\end{frame} \\begin{frame}{M\u00e1quina de Estados Replicada} Poss\u00edveis ordens com mesmo efeito? \\begin{itemize} \\item \\lstinline|touch /tmp/file1| \\item \\lstinline|echo \"teste testando\" $>>$ /tmp/file2| \\item \\lstinline|rm /tmp/file1| \\item \\lstinline|mkdir /dir1| \\end{itemize} \\end{frame} \\begin{frame}{M\u00e1quina de Estados Replicada} Poss\u00edveis ordens com mesmo efeito? \\begin{itemize} \\item \\lstinline|touch /tmp/file1| \\item \\lstinline|echo \"teste testando\" $>>$ /tmp/file2| \\item \\lstinline|rm /tmp/file1| \\item \\lstinline|mkdir /dir1| \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Causal} H\u00e1 diversos algoritmos, mas o mais recente e interessante \u00e9 denominado Generalized Paxos. Para saber mais, leia minha disserta\u00e7\u00e3o! \\end{frame} \\begin{frame}{Frameworks para Coordena\u00e7\u00e3o} Diversos sistemas abstraem problemas de coordena\u00e7\u00e3o em sistemas distribu\u00eddos. Estudaremos alguns nas aulas seguintes. \\end{frame} Antes, vamos nos aprofundar no estudo de um protocolo de Consenso/Difus\u00e3o at\u00f4mica. \\subsection{RSM: Estudo de Caso do Raft} \\begin{frame}{Raft} \\url{http://thesecretlivesofdata.com/raft/} \\end{frame} \\section{Estudo de Caso: Paxos} \\begin{frame}{Paxos} %\\begin{itemize} % \\item S\u00ednodo (Synod): consenso % \\item Paxos: Difus\u00e3o At\u00f4mica %\\end{itemize} \\end{frame} \\begin{frame}{Paxos} %\\begin{itemize} % \\item S\u00ednodo (Synod): consenso % \\item Paxos: Difus\u00e3o At\u00f4mica %\\end{itemize} \\end{frame} \\section{Estudo de caso: Atomix Copycat} \\begin{frame}{Atomix Copycat} \\begin{itemize} \\item Framework de replica\u00e7\u00e3o de m\u00e1quinas de estados implementada pela Atomix. \\item Implementa\u00e7\u00e3o do Raft \\item API simples \\item Java 8 (lambdas e futures) \\item \\url{http://atomix.io/copycat/} \\end{itemize} \\end{frame} \\begin{frame}[fragile,allowframebreaks]{Lambda} \\begin{itemize} \\item Classe com um \u00fanico m\u00e9todo. \\begin{lstlisting}[language=java] class Tarefa implements Runnable { public void run(){ while (true) System.out.println(\"Bem vindo a um loop infinito\"); } } new Thread(new Tarefa()).start(); \\end{lstlisting} \\framebreak 1 \\item Classe an\u00f4nima -- uso \u00fanico \\begin{lstlisting}[language=java] new Thread( new Runnable() { public void run(){ while (true) System.out.println(\"Bem vindo a um loop infinito\"); } }).start(); \\end{lstlisting} \\begin{lstlisting}[language=java] new Thread( new Runnable() { public void run(){ while (true) System.out.println(\"Bem vindo a um loop infinito\"); } }).start(); \\end{lstlisting} \\framebreak 1 \\item Lambda \\begin{lstlisting}[language=java] new Thread(() -> { while (true) System.out.println(\"Bem vindo a um loop infinito\"); }).start(); \\end{lstlisting} \\begin{lstlisting}[language=java] new Thread(() -> { while (true) System.out.println(\"Bem vindo a um loop infinito\"); }).start(); \\end{lstlisting} \\framebreak \\item Encadeamento (fluent) \\begin{lstlisting}[language=java] Collection<Pessoa> c = ...; c.stream() .filter(p -> p.idade > 33) .map(Pessoa::sobrenomeNome)//.map(p -> p.sobrenomeNome()) .forEach(s -> System.out.println(s)); \\end{lstlisting} \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Future} \\begin{itemize} \\item Promessa de computa\u00e7\u00e3o e resultado. \\begin{lstlisting}[language=java] ExecutorService executor = Executors.newSingleThreadExecutor(); Future<Integer> futFib = executor.submit(() -> { return Fibonacci(217)}; \\end{lstlisting} 1 2 \\item Quando ser\u00e1 executado? \\pause Em algum momento. \\item Como pegar o resultado? \\begin{lstlisting}[language=java] while (!futFib.isDone()) System.out.println(\"tah calculando...\"); int fib217 = futFib.get(); \\end{lstlisting} 1 \\item Em qual thread? \\pause Em algum thread. Depende do Executor Service usado. \\end{itemize} \\end{frame} \\begin{frame}{Atomix-Raft} \\begin{itemize} \\item Vers\u00e3o >= 2 do copycat \\item Melhor desempenho \\item Documenta\u00e7\u00e3o ruim \\item \\url{https://github.com/atomix/atomix} \\end{itemize} \\end{frame} \\begin{frame}{Atomix-Raft} \\begin{itemize} \\item Vers\u00e3o >= 2 do copycat \\item Melhor desempenho \\item Documenta\u00e7\u00e3o ruim \\item \\url{https://github.com/atomix/atomix} \\end{itemize} \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Vers\u00e3o 1.1.4 \\item Baseado em \\url{http://atomix.io/copycat/docs/getting-started/} \\item C\u00f3digo funcional em \\url{https://github.com/pluxos/atomix_labs} \\end{itemize} \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Vers\u00e3o 1.1.4 \\item Baseado em \\url{http://atomix.io/copycat/docs/getting-started/} \\item C\u00f3digo funcional em \\url{https://github.com/pluxos/atomix_labs} \\end{itemize} \\end{frame} \\begin{frame}{Clone e compile o projeto} \\begin{itemize} \\item Instale depend\u00eancias: git, maven e JDK >= 1.8 (lembre-se que gRPC precisa de JDK <= 1.8) \\item git clone https://github.com/pluxos/atomix\\_labs %https://www.baeldung.com/atomix \\item cd atomix\\_labs \\item cd replication \\item mvn compile \\item mvn test \\end{itemize} \\end{frame} \\begin{frame}{Clone e compile o projeto} \\begin{itemize} \\item Instale depend\u00eancias: git, maven e JDK >= 1.8 (lembre-se que gRPC precisa de JDK <= 1.8) \\item git clone https://github.com/pluxos/atomix\\_labs %https://www.baeldung.com/atomix \\item cd atomix\\_labs \\item cd replication \\item mvn compile \\item mvn test \\end{itemize} \\end{frame} \\begin{frame}[fragile]{mvn test} Resultado esperado. \\begin{verbatim} Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 [INFO] --------------------------------------- [INFO] BUILD SUCCESS [INFO] --------------------------------------- [INFO] Total time: 6.898 s [INFO] Finished at: 2017-10-25T08:38:08-02:00 [INFO] Final Memory: 15M/159M [INFO] --------------------------------------- \\end{verbatim} \\end{frame} \\begin{frame}{Estrutura} Explore o projeto. Na pasta/URL \\url{ https://github.com/pluxos/atomix_labs/tree/master/replication/src/main/java/atomix_lab/state_machine } H\u00e1 tr\u00eas pastas. Analise-as nesta ordem \\begin{itemize} \\item type -- tipos dos dados mantidos pela replica (Edge e Vertex)\\\\ Os tipos s\u00e3o serializable para que o Java saiba como transform\u00e1-los em bytes. \\item command -- estruturas que cont\u00eam informa\u00e7\u00f5es para modificar os tipos\\\\ Os comandos ser\u00e3o enviadas do cliente para o cluster e s\u00e3o naturalmente serializable. \\item client -- cria comandos e os envia para serem executados no cluster\\\\ Respostas podem ser esperadas s\u00edncrona ou assincronamente. \\item server -- recebe os comandos na ordem definida pelo Raft e os executa \\end{itemize} \\end{frame} \\begin{frame}{Lab} O projeto foi constru\u00eddo seguindo as instru\u00e7\u00f5es no tutorial mencionado antes, saltando-se a parte dos snapshots, isto \u00e9: \\begin{itemize} \\item crie um projeto maven\\\\ eclipse tem template para isso \\item adicione depend\u00eancias no pom.xml\\\\ como so criei um projeto, coloquei as depend\u00eancias tanto do cliente quando do servidor \\item defina Command que modifiquem o estado das r\u00e9plicas \\item defina Queries que consultem o estado das r\u00e9plicas \\item implemente a r\u00e9plica para lidar com os comandos \\item implemente o cliente para emitir comandos \\end{itemize} \\end{frame} \\begin{frame}{Lab} O projeto foi constru\u00eddo seguindo as instru\u00e7\u00f5es no tutorial mencionado antes, saltando-se a parte dos snapshots, isto \u00e9: \\begin{itemize} \\item crie um projeto maven\\\\ eclipse tem template para isso \\item adicione depend\u00eancias no pom.xml\\\\ como so criei um projeto, coloquei as depend\u00eancias tanto do cliente quando do servidor \\item defina Command que modifiquem o estado das r\u00e9plicas \\item defina Queries que consultem o estado das r\u00e9plicas \\item implemente a r\u00e9plica para lidar com os comandos \\item implemente o cliente para emitir comandos \\end{itemize} \\end{frame} \\begin{frame}{Lab} Para executar um servidor, voc\u00ea precisa passar como par\u00e2metro \\begin{itemize} \\item identificador do processo (inteiro) \\item IP do processo com identificador 0 \\item porta do processo com identificar 0 \\item IP do processo com identificador 1 \\item porta do processo com identificar 1 \\item ... \\end{itemize} Sabendo seu identificador, o servidor sabe em qual porta escutar e em quais IP/porta se conectar. \\end{frame} \\begin{frame}[fragile]{Lab} Execute tr\u00eas servidores. Usando o maven, da linha de comando, fica assim: \\begin{tiny} \\begin{verbatim} mvn exec:java \\ -Dexec.mainClass=\"atomix_lab.state_machine.server.GraphStateMachine\" \\ -Dexec.args=\"0 127.0.0.1 5000 127.0.0.1 5001 127.0.0.1 5002\" mvn exec:java \\ -Dexec.mainClass=\"atomix_lab.state_machine.server.GraphStateMachine\" \\ -Dexec.args=\"1 127.0.0.1 5000 127.0.0.1 5001 127.0.0.1 5002\" mvn exec:java \\ -Dexec.mainClass=\"atomix_lab.state_machine.server.GraphStateMachine\" \\ -Dexec.args=\"2 127.0.0.1 5000 127.0.0.1 5001 127.0.0.1 5002\" \\end{verbatim} \\end{tiny} %As instru\u00e7\u00f5es, sem quebra, est\u00e3o no README do reposit\u00f3rio. \\end{frame} \\begin{frame}[fragile]{Lab} O cliente n\u00e3o precisa de um identificador, apenas dos pares IP/porta dos servidores. \\begin{itemize} \\item IP do processo com identificador 0 \\item porta do processo com identificar 0 \\item IP do processo com identificador 1 \\item porta do processo com identificar 1 \\item ... \\end{itemize} Para execut\u00e1-lo, use o comando \\begin{tiny} \\begin{verbatim} mvn exec:java -Dexec.mainClass=\"atomix_lab.state_machine.client.GraphClient\" -Dexec.args=\"127.0.0.1 5000 127.0.0.1 5001 127.0.0.1 5002\" \\end{verbatim} \\end{tiny} \\end{frame} \\begin{frame}{Exerc\u00edcio} Uma vez executado o projeto, modifique-o para incluir uma nova opera\u00e7\u00e3o (Command) e nova consulta (Query). \\end{frame} \\section{Servi\u00e7os de Coordena\u00e7\u00e3o} \\begin{frame}{Servi\u00e7os de Coordena\u00e7\u00e3o} \\begin{itemize} \\item Zookeeper \\item Atomix \\item OpenReplica \\end{itemize} \\end{frame} \\begin{frame}{Servi\u00e7os de Coordena\u00e7\u00e3o} \\begin{itemize} \\item Zookeeper \\item Atomix \\item OpenReplica \\end{itemize} \\end{frame} \\subsection{Estudo de Caso: ZooKeeper} \\subsubsection{Vis\u00e3o Geral} \\begin{frame}{ZooKeeper} \\begin{center} \\includegraphics{images/zklogo} \\end{center} \\url{http://zookeeper.apache.org/} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Zoo?} Porqu\u00ea sistemas distribu\u00eddos s\u00e3o como zool\u00f3gicos, com animais de diversas esp\u00e9cies, sendo obrigados a conviver de forma anti-natural. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Zoo?} Porqu\u00ea sistemas distribu\u00eddos s\u00e3o como zool\u00f3gicos, com animais de diversas esp\u00e9cies, sendo obrigados a conviver de forma anti-natural. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{O qu\u00ea?} ZooKeeper is a \\alert{centralized} service for maintaining \\alert{configuration} information, \\alert{naming}, providing distributed \\alert{synchronization}, and providing \\alert{group services}. All of these kinds of services are used in some form or another by \\alert{distributed applications}. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management \\alert{complexity} when the applications are deployed. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{O qu\u00ea?} ZooKeeper is a \\alert{centralized} service for maintaining \\alert{configuration} information, \\alert{naming}, providing distributed \\alert{synchronization}, and providing \\alert{group services}. All of these kinds of services are used in some form or another by \\alert{distributed applications}. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management \\alert{complexity} when the applications are deployed. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{O qu\u00ea?} ZooKeeper is a \\alert{distributed}, open-source \\alert{coordination service for distributed applications}. It exposes a \\alert{simple set of primitives} that distributed applications can build upon to implement higher level services for synchronization, configuration maintenance, and groups and naming. It is designed to be easy to program to, and uses a data model styled after the familiar \\alert{directory tree structure of file systems}. It runs in Java and has bindings for both \\alert{Java} and \\alert{C}. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{O qu\u00ea?} ZooKeeper is a \\alert{distributed}, open-source \\alert{coordination service for distributed applications}. It exposes a \\alert{simple set of primitives} that distributed applications can build upon to implement higher level services for synchronization, configuration maintenance, and groups and naming. It is designed to be easy to program to, and uses a data model styled after the familiar \\alert{directory tree structure of file systems}. It runs in Java and has bindings for both \\alert{Java} and \\alert{C}. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Por qu\u00ea?} Coordination services are notoriously hard to get right. They are especially prone to errors such as race conditions and deadlock. The motivation behind ZooKeeper is to relieve distributed applications the responsibility of implementing coordination services from scratch. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Por qu\u00ea?} Coordination services are notoriously hard to get right. They are especially prone to errors such as race conditions and deadlock. The motivation behind ZooKeeper is to relieve distributed applications the responsibility of implementing coordination services from scratch. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Como?} ZooKeeper allows distributed processes to coordinate with each other through a \\alert{shared hierarchal namespace which is organized similarly to a standard file system}. The name space consists of data registers - called \\alert{znodes}, in ZooKeeper parlance - and these are \\alert{similar to files and directories}. Unlike a typical file system, which is designed for storage, ZooKeeper data is kept \\alert{in-memory}, which means ZooKeeper can achieve \\alert{high throughput and low latency} numbers. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\includegraphics[width=.7\\textwidth]{images/zknamespace} \\end{frame} \\begin{frame}{ZooKeeper} \\includegraphics[width=.7\\textwidth]{images/zknamespace} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Como?} ZooKeeper is replicated.\\\\ ZooKeeper is ordered. \\end{block} \\includegraphics[width=1\\textwidth]{images/zkservice} \\end{frame} \\begin{frame}{ZooKeeper} \\includegraphics[width=1\\textwidth]{images/zkcomponents} \\end{frame} \\begin{frame}{ZooKeeper} \\includegraphics[width=1\\textwidth]{images/zkcomponents} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Como?} ZooKeeper is fast [...] and it performs best where reads are more common than writes, at ratios of around 10:1. \\end{block} \\end{frame} \\begin{frame}{ZooKeeper} \\begin{block}{Como?} ZooKeeper is fast [...] and it performs best where reads are more common than writes, at ratios of around 10:1. \\end{block} \\end{frame} \\begin{frame}{Desempenho} \\includegraphics[width=1\\textwidth]{images/zkperfRW_3_2} \\end{frame} \\begin{frame}{Desempenho} \\includegraphics[width=1\\textwidth]{images/zkperfRW_3_2} \\end{frame} \\subsubsection{Uso} \\begin{frame}{ZNodes} \\includegraphics[width=.6\\textwidth]{images/zknamespace} \\begin{itemize} \\item Arquivo e diret\u00f3rio ao mesmo tempo. \\item S\u00e3o (devem ser) pequenos. \\item Operados atomicamente: todo o dado \u00e9 lido/escrito. \\item API simples \\begin{itemize} \\item C: create \\item R: get \\item U: set \\item D: delete \\item *: get children \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Lab} \\begin{itemize} \\item Download: wget \\url{www-eu.apache.org/dist/zookeeper/zookeeper-3.4.10} \\item Unpack: tar xvzf zookeeper*.tgz \\item Config: \\verb|conf/zoo.cfg| $\\Leftarrow$ Copie o exemplo\\\\ %\\verb|tickTime=2000|\\\\ %\\verb|dataDir=/tmp/seuNome/zk0| $\\Leftarrow$\\\\ %\\verb|clientPort=2181| $\\Leftarrow$ \\item \\verb|./bin/zkServer.sh start-foreground| \\item \\verb|./bin/zkCli.sh -server 127.0.0.1:2181| $\\Leftarrow$ \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Lab} \\begin{itemize} \\item Download: wget \\url{www-eu.apache.org/dist/zookeeper/zookeeper-3.4.10} \\item Unpack: tar xvzf zookeeper*.tgz \\item Config: \\verb|conf/zoo.cfg| $\\Leftarrow$ Copie o exemplo\\\\ %\\verb|tickTime=2000|\\\\ %\\verb|dataDir=/tmp/seuNome/zk0| $\\Leftarrow$\\\\ %\\verb|clientPort=2181| $\\Leftarrow$ \\item \\verb|./bin/zkServer.sh start-foreground| \\item \\verb|./bin/zkCli.sh -server 127.0.0.1:2181| $\\Leftarrow$ \\end{itemize} \\end{frame} \\frame{Exemplo} \\begin{frame}{ZNodes} \\begin{itemize} \\item Stat(istics): vers\u00e3o, ACL, timestamps. \\end{itemize} \\end{frame} \\begin{frame}{ZNodes} \\begin{itemize} \\item Stat(istics): vers\u00e3o, ACL, timestamps. \\end{itemize} \\end{frame} \\frame{Exemplo} \\begin{frame}{ZNodes} \\begin{itemize} \\item Updates condicionais. \\end{itemize} \\end{frame} \\begin{frame}{ZNodes} \\begin{itemize} \\item Updates condicionais. \\end{itemize} \\end{frame} \\frame{Exemplo} \\begin{frame}{ZNodes} \\begin{itemize} \\item N\u00f3s ef\u00eameros: presentes enquanto a sess\u00e3o que os criou estiver ativa. \\end{itemize} \\end{frame} \\begin{frame}{ZNodes} \\begin{itemize} \\item N\u00f3s ef\u00eameros: presentes enquanto a sess\u00e3o que os criou estiver ativa. \\end{itemize} \\end{frame} \\frame{Exemplo} \\begin{frame}{ZNodes} \\begin{itemize} \\item Watches: notificam clientes de mudan\u00e7as no n\u00f3 ou em seus filhos. \\item Uso \u00fanico. \\end{itemize} \\end{frame} \\begin{frame}{ZNodes} \\begin{itemize} \\item Watches: notificam clientes de mudan\u00e7as no n\u00f3 ou em seus filhos. \\item Uso \u00fanico. \\end{itemize} \\end{frame} \\frame{Exemplo} \\begin{frame}{Durabilidade?} Todas as opera\u00e7\u00f5es s\u00e3o colocadas em um log em disco. \\end{frame} \\begin{frame}{Durabilidade?} Todas as opera\u00e7\u00f5es s\u00e3o colocadas em um log em disco. \\end{frame} \\subsubsection{Receitas} \\begin{frame}{Receitas} \u00c9 poss\u00edvel resolver diversos problemas encontrados em sistemas distribu\u00eddos usando-se o ZooKeeper. \\end{frame} \\begin{frame}{Rendezvous} Ponto de encontro de processos. \\pause \\begin{itemize} \\item Defina um zNode raiz a ser usado: /rendezvous/app1/ \\pause \\item Cada filho de /rendezvous/app1 corresponde a um processo: \\begin{itemize} \\item IP \\item Porta \\item N\u00famero de processadores \\item ... \\end{itemize} \\item Processo p ao ser iniciado: \\begin{itemize} \\item procura /rendezvous/app1/p \\begin{itemize} \\item se achar, continua \\item se n\u00e3o achar, cria /rendezvous/app1/p \\end{itemize} \\item lista os filhos de /rendezvous/app1 \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Como lidar com sa\u00edda de processos?} \\pause Fa\u00e7a todos os zNodes s\u00e3o ef\u00eameros. \\\\ Quando um n\u00f3 \u00e9 desconectado, o zNode correspondente ser\u00e1 destru\u00eddo. \\end{frame} \\begin{frame}{Como lidar com sa\u00edda de processos?} \\pause Fa\u00e7a todos os zNodes s\u00e3o ef\u00eameros. \\\\ Quando um n\u00f3 \u00e9 desconectado, o zNode correspondente ser\u00e1 destru\u00eddo. \\end{frame} \\begin{frame}{Como detectar mudan\u00e7as no grupo de processos?} Monitore os filhos de /rendezvous/app1\\\\ Sempre que receber notifica\u00e7\u00f5es, refa\u00e7a o c\u00e1lculo do \\emph{membership}. \\end{frame} \\begin{frame}{Como detectar mudan\u00e7as no grupo de processos?} Monitore os filhos de /rendezvous/app1\\\\ Sempre que receber notifica\u00e7\u00f5es, refa\u00e7a o c\u00e1lculo do \\emph{membership}. \\end{frame} \\begin{frame}{Elei\u00e7\u00e3o de L\u00edderes} \\pause Rendezvous.\\\\ \\pause Fa\u00e7a os zNodes sequenciais. \\pause Ordene os zNodes e escolha o primeiro. \\pause Monitore o zNode. Se ele sumir, eleja outro l\u00edder. \\end{frame} \\begin{frame}{Elei\u00e7\u00e3o de L\u00edderes} \\pause Rendezvous.\\\\ \\pause Fa\u00e7a os zNodes sequenciais. \\pause Ordene os zNodes e escolha o primeiro. \\pause Monitore o zNode. Se ele sumir, eleja outro l\u00edder. \\end{frame} \\begin{frame}{Exclus\u00e3o M\u00fatua} Construa uma fila usando n\u00f3s ef\u00eameros e sequenciais. O processo na cabe\u00e7a da fila tem direito de acesso. Em caso de falhas, o processo \u00e9 removido da cabe\u00e7a da fila. \\end{frame} \\begin{frame}{Exclus\u00e3o M\u00fatua} Construa uma fila usando n\u00f3s ef\u00eameros e sequenciais. O processo na cabe\u00e7a da fila tem direito de acesso. Em caso de falhas, o processo \u00e9 removido da cabe\u00e7a da fila. \\end{frame} \\begin{frame}{Compartilhamento de Par\u00e2metros de Configura\u00e7\u00e3o} Pronto! \\end{frame} \\begin{frame}{Compartilhamento de Par\u00e2metros de Configura\u00e7\u00e3o} Pronto! \\end{frame} \\begin{frame}{Receitas} \\begin{itemize} \\item Lock distribu\u00eddo \\item Filas, e.g. de prioridades \\item Barreira \\item Servi\u00e7o de nomes \\item Termina\u00e7\u00e3o em duas fases \\item Contador at\u00f4mico \\end{itemize} \\url{ http://zookeeper.apache.org/doc/trunk/recipes.html } \\end{frame} \\begin{frame}{Curator} \\includegraphics{images/curator-logo} Um livro de receitas implementadas em ZK. \\url{ http://curator.apache.org } \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Crie um zNode /teste \\item Debaixo de /teste, crie tr\u00eas outros, sequenciais \\end{itemize} \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Crie um zNode /teste \\item Debaixo de /teste, crie tr\u00eas outros, sequenciais \\end{itemize} \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Crie um zNode /teste2 \\item Crie um zNode ef\u00eamero \\item Conecte-se com outro cliente \\item Coloque um watch em /teste2 \\item Desconecte o primeiro cliente \\item Observe o evento gerado no segundo cliente \\item Reconecte o primeiro cliente \\end{itemize} \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Crie um zNode /teste2 \\item Crie um zNode ef\u00eamero \\item Conecte-se com outro cliente \\item Coloque um watch em /teste2 \\item Desconecte o primeiro cliente \\item Observe o evento gerado no segundo cliente \\item Reconecte o primeiro cliente \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Multi-node} Crie tr\u00eas arquivos, zoo1.cfg, zoo2.cfg e zoo3.cfg.\\Por exemplo, zoo1.cfg fica assim: \\begin{itemize} \\item \\verb|dataDir=/tmp/lasaro/zoo1| \\Leftarrow \\Leftarrow Diret\u00f3rios distintos. \\item \\verb|server.1=zoo1:2888:3888| \\Leftarrow \\Leftarrow Portas distintas. \\item \\verb|server.2=zoo2:2889:3889| \\item \\verb|server.3=zoo3:2890:3890| \\item \\verb|clientPort=2181| \\Leftarrow \\Leftarrow Portas distintas. \\end{itemize} Crie diret\u00f3rios e arquivos de identifica\u00e7\u00e3o. \\begin{itemize} \\item \\verb|mkdir /tmp/lasaro/zoo1| \\item \\verb|echo 1 > /tmp/lasaro/zoo1/myid| \\end{itemize} Execute servidores. \\begin{itemize} \\item \\verb|./bin/zkServer.sh start conf/zoo1.cfg| \\end{itemize} Use \\verb|start-foreground| para acompanhar a execu\u00e7\u00e3o. \\end{frame} \\begin{frame}{Lab} \\begin{itemize} \\item Crie um znode /contador com valor 0 \\item Descreva como fazer para que os clientes incrementem atomicamente o valor de /contador. \\end{itemize} \\end{frame} \\subsection{Falhas Bizantinas} \\begin{frame}{Uma hist\u00f3ria de tr\u00eas ex\u00e9rcitos -- Vers\u00e3o 2} Ex\u00e9rcitos est\u00e3o \u00e0s portas de Biz\u00e2ncio, aka Constantinopla, aka Istambul. Todos os ex\u00e9rcitos tem que atacar em conjunto ou se retirar em conjunto. Cada ex\u00e9rcito \u00e9 comandado por um General. Alguns destes preferem atacar, enquanto outros preferem se retirar. Alguns generais podem ter sido comprados, e mandar mensagens discrepantes para os outros, ou simplesmente n\u00e3o mandar mensagens. Fonte: \\href{ http://research.microsoft.com/en-us/um/people/lamport/pubs/byz.pdf}{Lamport , L.; Shostak, R.; Pease, M. (1982). \"The Byzantine Generals Problem\" (PDF). ACM Transactions on Programming Languages and Systems. 4 (3): 382\u2013401. doi:10.1145/357172.357176.} \\end{frame} \\begin{frame}{Generais e Tenentes} Problema pode ser mudado para: \\begin{itemize} \\item Comandante envia ordem. \\item Todos os tenentes leais executam ordem recebida. \\item Comandante pode ser traidor. \\end{itemize} \\end{frame} \\begin{frame}{Generais e Tenentes} Problema pode ser mudado para: \\begin{itemize} \\item Comandante envia ordem. \\item Todos os tenentes leais executam ordem recebida. \\item Comandante pode ser traidor. \\end{itemize} \\end{frame} \\begin{frame}{Generais e Tenentes} Suponha 3 ex\u00e9rcitos. \\ Comandante (traidor) diz \"Ataque!\" Tenente A e \"Retirada!\" tenente B.\\ Ou \\ Comandante diz \"Ataque!\" a ambos. Tenente A segue a ordem mas B se retira. \\pause E se os tenentes trocarem informa\u00e7\u00f5es? \\pause Como diferenciar casos em que Comandante ou Tenente \u00e9 traidor? \\end{frame} \\begin{frame}{Generais e Tenentes} S\u00f3 h\u00e1 solu\u00e7\u00e3o se mais de $\\frac{2}{3}$ dos Generais/Tenentes s\u00e3o leais. \\end{frame} \\begin{frame}{Generais e Tenentes} S\u00f3 h\u00e1 solu\u00e7\u00e3o se mais de $\\frac{2}{3}$ dos Generais/Tenentes s\u00e3o leais. \\end{frame} % http://www.drdobbs.com/cpp/the-byzantine-generals-problem/206904396?pgno=5 \\begin{frame}{Comunica\u00e7\u00e3o} \\begin{itemize} \\item Toda mensagem enviada \u00e9 entregue corretamente. \\item A aus\u00eancia de mensagem pode ser detectada (mensagem Null \u00e9 entregue no lugar) (Sistema s\u00edncrono) \\end{itemize} \\end{frame} \\begin{frame}{Comunica\u00e7\u00e3o} \\begin{itemize} \\item Toda mensagem enviada \u00e9 entregue corretamente. \\item A aus\u00eancia de mensagem pode ser detectada (mensagem Null \u00e9 entregue no lugar) (Sistema s\u00edncrono) \\end{itemize} \\end{frame} \\begin{frame}{4/0} General manda ordens. Aus\u00eancia de ordem = Retirada Tenente repassa ordens Maioria de comandos \u00e9 comando a ser seguido \\end{frame} \\begin{frame}{4/0} General manda ordens. Aus\u00eancia de ordem = Retirada Tenente repassa ordens Maioria de comandos \u00e9 comando a ser seguido \\end{frame} \\begin{frame}{Comunica\u00e7\u00e3o} \\begin{itemize} \\item Toda mensagem enviada \u00e9 entregue corretamente. \\item Toda mensagem \u00e9 assinada. \\item A aus\u00eancia de mensagem pode ser detectada (mensagem Null \u00e9 entregue no lugar) (Sistema s\u00edncrono) \\end{itemize} \\pause \u00c9 poss\u00edvel detectar inconsist\u00eancias e processos bizantinos. \\end{frame} % http://cs.brown.edu/courses/cs138/s16/lectures/19consen-notes.pdf \\section{Outros t\u00f3picos} %TODO \\subsection{Detectores de Falhas} \\subsection{Reconfigura\u00e7\u00e3o} \\begin{frame}{Reconfigura\u00e7\u00e3o da Aplica\u00e7\u00e3o} Na segunda entrega do projeto, voc\u00ea distribuiu a carga do seu banco de dados entre v\u00e1rios n\u00f3s. Caso um n\u00f3 falhe, parte dos seus dados ser\u00e1 perdida. Para corrigir esta defici\u00eancia, na terceira entrega, cada n\u00f3 ser\u00e1 replicado em tr\u00eas vias e, assim, caso um n\u00f3 falhe, outros dois continuar\u00e3o a manter o dado. \\end{frame} \\begin{frame}{Reconfigura\u00e7\u00e3o da Aplica\u00e7\u00e3o} Ainda assim, h\u00e1 problemas. E se mais de um, de um mesmo conjunto de r\u00e9plicas, falhar? \\pause Embora seja pequena a probabilidade de dois n\u00f3s de um mesmo grupo falharem em instantes pr\u00f3ximos, dado tempo suficiente, qualquer evento com probabilidade diferente de 0 acontecer\u00e1. \\pause Precisamos de uma forma de trocar n\u00f3s da aplica\u00e7\u00e3o que falharam por novos n\u00f3s. Este \u00e9 problema denominado Pertin\u00eancia de Grupo ou \\emph{Group Membership} \\end{frame} \\begin{frame}{Group Membership} Para n\u00e3o correr o risco, retire o processo falhos do grupo e coloque outro no lugar! I.e., mude a vis\u00e3o que o sistema de quem \u00e9 o grupo. \\end{frame} \\begin{frame}{Vis\u00f5es} \\includegraphics[width=.7\\textwidth]{images/vc} Fonte: \\href{ https://www.cs.rutgers.edu/~pxk/417/notes/virtual_synchrony.html}{Paul Krzyzanowski} G G \u00e9 o grupo de processos participando do sistema, \u00e9 a Vis\u00e3o do Sistema. \\end{frame} Inicialmente, G G consiste de apenas o processo p p , como o processo que cria o cluster no Atomix. Na sequ\u00eancia, outros processo v\u00e3o se unindo ao grupo atrav\u00e9s de View Changes. Uma vez que p p e q q est\u00e3o no grupo, inicia-se a comunica\u00e7\u00e3o entre eles. Quando r, s r, s e t t aparecem, tamb\u00e9m entram no grupo por meio de uma nova vis\u00e3o. Finalmente, quando ambos p p e q q falham, os outros processo os excluem da vis\u00e3o, e continuam funcionando normalmente. \\begin{frame}{Impossibilidade de Detec\u00e7\u00e3o de Falhas} Em um sistema distribu\u00eddo ass\u00edncrono, \u00e9 imposs\u00edvel distinguir com toda certeza um processo falho (parou de funcionar) de um que est\u00e1 lento. \\pause Como decidir se mudar ou n\u00e3o de vis\u00e3o? \\end{frame} Ou aceita a imprecis\u00e3o e muda quando suspeitar de uma falha, ou corre o risco de ficar esperando \\emph{ad eternum} e n\u00e3o mudar, mesmo quando uma falha aconteceu. \\begin{frame}{Uma ``solu\u00e7\u00e3o''!} Quando suspeitar de falha, reporte suspeita a outros processos, que tamb\u00e9m passar\u00e3o a suspeitar. Tome decis\u00e3o baseado na suspeita, isto \u00e9, troque de vis\u00e3o quando houver suspeita. Pague o pre\u00e7o de uma suspeita errada, isto \u00e9, quando um processo for removido da vis\u00e3o indevidamente, adicione-o novamente. \\end{frame} \\begin{frame}{Sincronismos Virtual} Gerenciamento de Grupo/Group Membership e Comunica\u00e7\u00e3o em Grupo \\begin{itemize} \\item Processos se unem ao grupo \\item Processos saem do grupo \\item Processos enviam mensagens para o grupo \\item Diferentes ordena\u00e7\u00f5es \\begin{itemize} \\item Atomic Multicast \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Sincronismos Virtual} Gerenciamento de Grupo/Group Membership e Comunica\u00e7\u00e3o em Grupo \\begin{itemize} \\item Processos se unem ao grupo \\item Processos saem do grupo \\item Processos enviam mensagens para o grupo \\item Diferentes ordena\u00e7\u00f5es \\begin{itemize} \\item Atomic Multicast \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Vis\u00e3o de Grupo} \\begin{itemize} \\item Vis\u00e3o: conjunto de processos no sistema. \\item Multicast feito para processos na vis\u00e3o. \\item Vis\u00e3o \u00e9 consistente entre os processos. \\item Entrada e sa\u00edda de processos muda a vis\u00e3o. \\end{itemize} \\end{frame} \\begin{frame}{Vis\u00e3o de Grupo} \\begin{itemize} \\item Vis\u00e3o: conjunto de processos no sistema. \\item Multicast feito para processos na vis\u00e3o. \\item Vis\u00e3o \u00e9 consistente entre os processos. \\item Entrada e sa\u00edda de processos muda a vis\u00e3o. \\end{itemize} \\end{frame} \\begin{frame}{Eventos} \\begin{itemize} \\item Mensagem \\item Mudan\u00e7a de Vis\u00e3o \\item Checkpoint \\end{itemize} \\end{frame} \\begin{frame}{Eventos} \\begin{itemize} \\item Mensagem \\item Mudan\u00e7a de Vis\u00e3o \\item Checkpoint \\end{itemize} \\end{frame} \\begin{frame}{Vis\u00f5es} \\includegraphics[width=.7\\textwidth]{images/vc} Fonte: \\href{ https://www.cs.rutgers.edu/~pxk/417/notes/virtual_synchrony.html}{Paul Krzyzanowski} \\end{frame} \\begin{frame}{Sincronismo Virtual} Deve satisfazer \\begin{itemize} \\item Se uma mensagem \u00e9 enviada em uma vis\u00e3o, ela s\u00f3 pode ser entregue naquela vis\u00e3o. \\item Se uma mensagem \u00e9 entregue a um processo correto em uma vis\u00e3o, ent\u00e3o \u00e9 entregue a todos os processos corretos naquela vis\u00e3o. \\item Se um processo n\u00e3o recebe a mensagem, ele n\u00e3o estar\u00e1 na pr\u00f3xima vis\u00e3o. \\item Ao entrar em uma vis\u00e3o, o processo recebe o estado dos outros processos e seu estado se torna equivalente ao de um processo que recebeu todas as mensagens j\u00e1 entregues. \\end{itemize} A troca de Vis\u00e3o \u00e9 uma barreira. \\end{frame} \\begin{frame}{ISIS Toolkit} Sistema de Sincronismo Virtual tolerante a falhas desenvolvido por Ken Birman, Cornell University (\\url{ http://www.cs.cornell.edu/Info/Projects/Isis/ })\\ ISIS: An Environment for Constructing Fault-Tolerant Distributed Systems. Kenneth Birman, D. Skeen, A. El Abbadi, W. C. Dietrich and T. Raeuchle. May 1983. \\begin{itemize} \\item 100.000's/s \\item Em uso at\u00e9 2009 \\item NY Stock Exchange \\item Swiss Exchange \\item US Navy \\item Precursos de sistemas como Zookeeker \\item Totem, ISIS, Horus, Transis (Parti\u00e7\u00f5es), \\alert{Spread}, \\alert{Ensamble}, \\alert{JGroups}, Appia, QuickSilver, vSynch (n\u00e9e ISIS 2) \\end{itemize} \\end{frame} \\begin{frame}{Difus\u00e3o Totalmente Ordenada} \\begin{itemize} \\item Corretude: Se um processo p p envia uma mensagem m m para processos no grupo G G , ent\u00e3o se p p n\u00e3o falha, todos os processos corretos em G G recebem a mensagem. 1 2 3 4 5 \\item Acordo: Se um processo correto em $G$ recebe uma mensagem $m$, ent\u00e3o todo processo correto em $G$ recebe $m$ \\item Ordena\u00e7\u00e3o: Se um processo recebe mensagem $m$ e depois $n$, ent\u00e3o qualquer processo que receba a mensagem $n$ deve primeiro receber $m$ \\item Validade: Somente mensagens difundidas s\u00e3o entregues. \\end{itemize} E se mandarmos mensagens do tipo ``A partir da entrega desta mensagem, o grupo de processos \u00e9 G G .'' \\end{frame} \\begin{frame}{Sincronismo Virtual} Deve satisfazer \\begin{itemize} \\item Se uma mensagem \u00e9 enviada em uma vis\u00e3o, ela s\u00f3 pode ser entregue naquela vis\u00e3o.\\ Mensagens de troca de vis\u00e3o podem incrementar um contador\\ Mensagens normais carregam o valor atual do contador\\ Mensagem descartada se valor na mensagem \u00e9 maior contador no destinat\u00e1rio 1 2 3 4 5 6 7 8 9 \\item Se uma mensagem \u00e9 entregue a um processo correto em uma vis\u00e3o, ent\u00e3o \u00e9 entregue a todos os processos corretos naquela vis\u00e3o.\\\\ Pela difus\u00e3o, se a mensagem de troca for entregue para um processo, ser\u00e1 entregue para todos os corretos, na mesma ordem Se mensagem comum for entregue antes para algum, ser\u00e1 entregue ante para todos. \\item Se um processo n\u00e3o recebe a mensagem, ele n\u00e3o estar\u00e1 na pr\u00f3xima vis\u00e3o.\\\\ Se um processo n\u00e3o recebe uma mensagem comum que foi entregue pelos outros, ent\u00e3o ele n\u00e3o troca de vis\u00e3o. \\item Ao entrar em uma vis\u00e3o, o processo recebe o estado dos outros processos e seu estado se torna equivalente ao de um processo que recebeu todas as mensagens j\u00e1 entregues.\\\\ Caso contr\u00e1rio, n\u00e3o haveria porqu\u00ea trocar os processos \\end{itemize} \\end{frame} \\begin{frame}{State Transfer} \\includegraphics[width=.7\\textwidth]{images/state_transfer} \\href{ http://www.gsd.inesc-id.pt/~ler/docencia/tfd0405/bib/BSRNA.pdf}{Building Secure and Reliable Network Applications} \\end{frame} \\begin{frame}{Difus\u00e3o At\u00f4mica \\equiv \\equiv Sincronismo Virtual?} Seria uma boa aproxima\u00e7\u00e3o, mas que poderia ser relaxada. Em certas aplica\u00e7\u00f5es, FIFO ou Causal seriam suficientes dentro da vis\u00e3o, desde que a mensagem de mudan\u00e7a da vis\u00e3o seja totalmente ordenada com as comuns. \\end{frame} \\begin{frame}{Particionamento} E se dois subconjuntos mutuamente exclusivos se formarem e criarem vis\u00f5es independentes? \\pause \\emph{Primary Partition Model} -- Somente a parti\u00e7\u00e3o prim\u00e1ria pode mudar de vis\u00e3o. \\pause Lembram-se que no Raft somente uma parti\u00e7\u00e3o com uma maioria de processo pode decidir? \u00c9 exatamente a mesma situa\u00e7\u00e3o, pois os processos est\u00e3o chegando a um Consenso sobre quem \u00e9 a nova vis\u00e3o. \\end{frame} \\begin{frame}{Extended Virtual Synchrony} \\emph{Primary Partition Model} -- N\u00e3o \u00e9 adequado a uma rede geograficamente distribu\u00edda (Internet scale). \\pause Lembram-se que no Raft somente uma parti\u00e7\u00e3o com uma maioria de processo pode decidir? \u00c9 exatamente a mesma situa\u00e7\u00e3o, pois os processos est\u00e3o chegando a um Consenso sobre quem \u00e9 a nova vis\u00e3o. \\end{frame} \u00c9 poss\u00edvel que no trabalho dois, alguns de voc\u00eas tenham tentado gerar locks do sistema para manipular objetos distribu\u00eddos no sistema. Esse locks s\u00e3o perigosos por qu\u00ea processos pode travar/quebrar/falhar e nunca liberarem os locks. O uso de um algoritmo VS poderia ser usado para resolver o problema.\\right Swim Lista de Falhas Reais","title":"Modelos"},{"location":"teaching/gbc074gsi028/intro/","text":"Introdu\u00e7\u00e3o Escrever bons sistemas distribu\u00eddos \u00e9 uma tarefa que esbarra em diversos obst\u00e1culos, sendo a defini\u00e7\u00e3o do que \u00e9 um sistema distribu\u00eddo e do que \u00e9 ser \"bom\" neste contexto sendo nossos primeiros obst\u00e1culos. O qu\u00ea s\u00e3o Sistemas Distribu\u00eddos? Para entendermos o que \u00e9 um Sistema Distribu\u00eddo, talvez seja mais f\u00e1cil por um sistema n\u00e3o-distribu\u00eddo ou, como os denominaremos aqui, sistema monol\u00edtico 1 . Pense na maioria das aplica\u00e7\u00f5es que desenvolveu no curso at\u00e9 agora. Mesmo que use diferentes bibliotecas e frameworks , toda a l\u00f3gica de neg\u00f3cio, armazenamento e interface com usu\u00e1rio est\u00e1 contida em um mesmo execut\u00e1vel e, quando executado, em um \u00fanico processo. Quando come\u00e7ou a programar este tipo de aplica\u00e7\u00e3o, o trabalho era basicamente colar blocos que se encaixavam perfeitamente, como Lego , bastando importar a biblioteca correta e invocar suas fun\u00e7\u00f5es. O cen\u00e1rio deve ter mudado um pouco no decorrer do curso e com o in\u00edcio de sua atividade profissional, quando passou a usar muito mais bibliotecas de muitos desenvolvedores diferentes, em equipes com v\u00e1rias pessoas, aumentando consideravelmente a complexidade do desenvolvimento; o resultado, contudo, continua sendo um artefato s\u00f3. Programar sistemas distribu\u00eddos \u00e9 dar outro salto em complexidade, pois frequentemente temos que usar pe\u00e7as que nunca foram pensadas para trabalharem juntas, nos for\u00e7ando a usar um pouco de , e fios, no caso, um tipo especial de fio conhecido como cabo de rede. De fato, a principal caracter\u00edstica de um sistema distribu\u00eddo em rela\u00e7\u00e3o a um n\u00e3o-distribu\u00eddo, \u00e9 a separa\u00e7\u00e3o e disper\u00e7\u00e3o de suas partes em v\u00e1rios componentes independentes (processos, sensores, atuadores, etc), mas que se coordenam para execu\u00e7\u00e3o de alguma tarefa. Assim, uma poss\u00edvel defini\u00e7\u00e3o de Sistema Distribu\u00eddo, que me agrada, \u00e9 a seguinte: Sistema Distribu\u00eddo Cole\u00e7\u00e3o de sistemas computacionais (software ou hardware), independentes mas com alguma forma de comunica\u00e7\u00e3o , que colaboram na execu\u00e7\u00e3o de alguma tarefa . No jarg\u00e3o da \u00e1rea, os componentes indepedentes s\u00e3o denominados n\u00f3s . Frequentemente, cada n\u00f3 do sistema ser\u00e1 na pr\u00e1tica um processo em um computador hospedeiro, um host , mas possivelmente m\u00faltiplos podem ser executados em um mesmo host ; isso n\u00e3o muda o fato de que s\u00e3o independentes e poderiam ser distanciados. Quanto \u00e0 comunica\u00e7\u00e3o, Os n\u00f3s podem compartilhar um espa\u00e7o de endere\u00e7amento comum, seja por que est\u00e3o co-locados no mesmo hospedeiro ou seja porqu\u00ea tem acesso a alguma forma de mem\u00f3ria compartilhada distribu\u00edda, que veremos mais adiante. Eles tamb\u00e9m podem se comunicar por mensagens trocadas via uma rede de comunica\u00e7\u00e3o, como a Internet. Quanto \u00e0 tarefa em comum, veja o seguinte exemplo, em que v\u00e1rios clientes trocam emails por meio de uma m\u00e1quina com a qual se comunicam para entregar mensagens a serem enviadas e receber mensagens a eles destinadas; enquanto aguardam a entrega, mensagens s\u00e3o armazenadas em um Sistema Gerenciador de Banco de Dados (SGBD) em uma outra m\u00e1quina, da qual os usu\u00e1rios n\u00e3o ttem ci\u00eancia. Neste exemplo, cada celular \u00e9 um n\u00f3 do sistema, assim como o processo respons\u00e1vel por receber os emails e encaminh\u00e1-los para o banco, bem como ler do banco e entregar para os destinat\u00e1rios. Neste exemplo, se o banco de dados para de funcionar, o processo na outra m\u00e1quina passa a ser in\u00fatil, uma vez que n\u00e3o pode armazenar novas mensagens e nem recuperar mensagens j\u00e1 armazenadas. Neste contexto, uma defini\u00e7\u00e3o mais c\u00ednica mas definitivamente realista \u00e9 a de Leslie Lamport , que certa vez disse: A distributed system is one in which the failure of a computer you didn't even know existed can render your own computer unusable. Mas se esta \u00e9 a realidade da programa\u00e7\u00e3o distribu\u00edda, por qu\u00ea faz\u00ea-lo? Por qu\u00ea desenvolvemos sistemas distribu\u00eddos? Aqui diremos que um sistema \u00e9 bom se est\u00e1 sempre funcional, mesmo que partes do sistema deixem de funcionar, com bom desempenho, i.e., respostas r\u00e1pidas s\u00e3o dadas para o usu\u00e1rio, e com baixo custo, ou pelo menos t\u00e3o baixo qunto poss\u00edvel para realizar a tarefa para a qual foi constru\u00eddo. Enquanto ainda subjetiva, nossa defin\u00e7\u00e3o j\u00e1 nos permite estabelecer um pano de fundo para delinear as dificuldades de se implementar tais sistemas. Pensemos em algumas aplica\u00e7\u00f5es distribu\u00eddas com as quais interagimos todos os dias e que por seu sucesso devem ser bons sistemas distribu\u00eddos: Alguns exemplos \u00f3bvios s\u00e3o Amazon.com , Facebook , e GMail . Estes sistemas rodam em grandes data centers com milhares de m\u00e1quinas , estando constantemente sujeitos fontes queimadas, discos corruptos, mem\u00f3rias defeituosas. Apesar disto, dificilmente estes servi\u00e7os s\u00e3o reportados como fora do ar, s\u00e3o altamente respons\u00edveis e, goste ou n\u00e3o do que fazem, s\u00e3o bem sucedidos porqu\u00ea cumprem bem suas tarefas. Enquanto a primeira vista possa se pensar que as t\u00e9cnicas usadas na constru\u00e7\u00e3o destes sistemas devem ser muito especializadas e fora da realidade dos sistemas que n\u00f3s desenvolvemos, a verdade n\u00e3o poderia ser mais longe disto. O fato \u00e9 que computadores individuais tem capacidade limitada de processamento e armazenamento, mas nossa necessidade de poder computacional cresce exponencialmente. Assim, precisamos crescer nosso poder computacional, mas aumentar a capacidade de um dispositivo ( scale up ) mesmo de forma linear tem custo exponencial. O que nos resta ent\u00e3o \u00e9 agregar o poder computacional de diversos computadores \"baratos\" ( scale out ) para satisfazer nossas necessidades. De fato, praticamente qualquer sistema de informa\u00e7\u00e3o de sucesso necessitar\u00e1 aplicar as mesmas t\u00e9cnicas de computa\u00e7\u00e3o distribu\u00edda e superar as mesmas barreiras para conseguir atender a n\u00famero crescente de clientes (computacionais ou humanos), aumentar sua \u00e1rea de cobertura, e melhorar ou manter a qualidade do servi\u00e7o que presta, mesmo que n\u00e3o chegue a escala dos exemplos acima. Este \u00faltimo ponto, sobre qualidade do servi\u00e7o, tem a ver com a capacidade de um sistema se manter no ar a despeito de problemas, isto \u00e9, de ser tolerante a falhas. Toler\u00e2ncia a falhas implica em redund\u00e2ncia, em c\u00f3pias, o que fatidicamente implica em distribui\u00e7\u00e3o e em Sistemas Distribu\u00eddos . O rem\u00e9dio, contudo, \u00e9 bem amargo: com muitos computadores conectados, vem a necessidade de coorden\u00e1-los, de forma a agir de forma coerente, mesmo quando alguns deles falhem, e quanto mais computadores, maior \u00e9 a probabilidade de que pelo menos um deles tenha uma CPU, disco, fonte, ou que quer que seja, falhando. E estejam certos, computadores falham o tempo todo! N\u00f3s precisamos ent\u00e3o entender este ambiente, determinar e especificar v\u00e1rias de suas propriedades e comportamentos. Qual a probabilidade de um n\u00f3 parar de funcionar? Como os hospedeiros, ou melhor, como os processos se comunicam? Via mem\u00f3ria compartilhada ou por troca de mensagens? Se por mensagens, estas podem ser perdidas, atrasadas, corrompidas? Os rel\u00f3gios dos hospedeiros marcam o mesmo valor no mesmo instante, ou melhor, s\u00e3o sincronizados? Quanto tempo leva uma mensagem para sair de um n\u00f3 A e chegar a um n\u00f3 B? H\u00e1 agentes que possam querer perturbar o sistema, por exemplo para ganhar acesso a mais recursos do que seria justo? Quais os padr\u00f5es de acesso ao servi\u00e7os, isto \u00e9, se aumentam \u00e0 noite, diminuem no ver\u00e3o, etc? Assim, definimos modelos computacionais , que nos permitem desenvolver algoritmos adequados aos diversos problemas que enfrentamos. Definido ou identificado o modelo computacional, podemos distribuir nosso sistema, isto \u00e9, dividir a computa\u00e7\u00e3o/armazenamento em diversas m\u00e1quinas, e coordenar suas a\u00e7\u00f5es para que sejam consistentes com a especifica\u00e7\u00e3o, de forma a minimizar o tempo que o servi\u00e7o fica fora do ar, entregando o servi\u00e7o de acordo com expectativas especificadas. Modelos cl\u00e1ssicos englobam tr\u00eas vari\u00e1veis: Comunica\u00e7\u00e3o , Sincronismo e Falhas . Com rela\u00e7\u00e3o \u00e0 comunica\u00e7\u00e3o, como j\u00e1 indicado acima, as possibilidades s\u00e3o por acesso a uma mem\u00f3ria compartilhada ou via troca de mensagens, o modelo mais comum. Quanto ao sincronismo, se considera se h\u00e1 limites de tempo para execu\u00e7\u00e3o de opera\u00e7\u00f5es, para troca de mensagens (caso seja este o modelo de comunica\u00e7\u00e3o), e se os hospedeiros do sistema tem acesso a rel\u00f3gios e, finalmente, qu\u00e3o sincronizados estes s\u00e3o. Quanto a falhas, \u00e9 preciso entender como estas (bugs, por exemplo) afetam a execu\u00e7\u00e3o do sistema, se o levam componentes falhos a parar de funcionar totalmente e de forma identific\u00e1vel por outros ou n\u00e3o, se h\u00e1 falhas \"maliciosas\", se os limites de tempo estabelecidos acima podem ser violados, se mensagens podem ser perdidas ou corrompidas. O objetivo \u00e9 entender como evitar que a falha de algum componente possa levar o sistema a parar como um todo e garantir que clientes em qualquer lugar do mundo tenham a mesma facilidade em acessar o servi\u00e7o. N\u00f3s voltaremos a falar sobre modelos computacionais adiante. Por enquanto, vejamos alguns exemplos de tarefas executadas por sistemas distribu\u00eddos, que voc\u00ea usa hoje. Sistema de e-mail Entregue este email para fulano@knowhere.uni . Envie o item X para este endere\u00e7o, ap\u00f3s cobran\u00e7a de Y dinheiros da conta Z. Em um ambiente de simula\u00e7\u00e3o de batalhas em 3D, simule o disparo de um proj\u00e9til nesta dire\u00e7\u00e3o e sentido, com velocidade v, enquanto movimenta o avatar A para a esquerda. Autorize a transfer\u00eancia de X dinheiros da conta C para a conta C'. Movimente o bra\u00e7o mec\u00e2nico que est\u00e1 segurando um bisturi, 3cm \u00e0 direita, ent\u00e3o abaixe-o 3mm, e movimente-o 4cm para a esquerda Inclua o coment\u00e1rio ``LOL!!!'' na lista de coment\u00e1rios do item XYZ, com marca de tempo T Leia o valor do sensor de temperatura S e, caso seu valor supere V, emita alarme luminoso vermelho intermitente e alarme sonoro Fica claro por estes exemplos que h\u00e1 comunica\u00e7\u00e3o entre diversos componentes, por exemplo o console de videogame e um servi\u00e7o que mantem uma \"sala\" aberta para um jogo. Tamb\u00e9m fica claro pelo mesmo exemplo que a lat\u00eancia desta comunica\u00e7\u00e3o deve ser mantida dentro certos patamares, para n\u00e3o inviabilizar a intera\u00e7\u00e3o entre jogares. Al\u00e9m disso, pode-se dizer que algumas aplica\u00e7\u00f5es \u00e3o cr\u00edticas, como no exemplo de tele-cirurgia, enquanto outras s\u00e3o muito menos imoportantes, como acessar sua rede social de fotos. Voltando \u00e0 defini\u00e7\u00e3o, acima, sistemas distribu\u00eddos implicam em algum tipo de colabora\u00e7\u00e3o entre componentes para permitir que recursos de um sejam usados por outro. Colabora\u00e7\u00e3o cria depend\u00eancia e, nos exemplos acima, \u00e9 claro que problemas em alguns compontes pode fazer com que a tarefa que o sistema executa seja inviabilizada, como no caso do sensor do \u00faltimo exemplo, que se parar de funcionar, impede a medi\u00e7\u00e3o da temperatura e o disparo adequado do alarme. Entre os recursos compartilhados por componentes em um sistema distribu\u00eddo est\u00e3o alguns \u00f3bvios, como capacidade de armazenamento e de processamento , mas tamb\u00e9m a localiza\u00e7\u00e3o de um n\u00f3, que pode ser geograficamente mais pr\u00f3xima e de menor lat\u00eancia at\u00e9 um ponto de interesse, ou at\u00e9 mesmo a disponibilidade de uma conex\u00e3o f\u00edsica com um recurso especial, como uma impressora. Assim, podemos concluir que as principais raz\u00f5es para se desenvolver sistemas distribu\u00eddos s\u00e3o alcan\u00e7ar escalabilidade e toler\u00e2ncia a falhas , ambas resultantes da agrega\u00e7\u00e3o (correta) do poder computacional de m\u00faltiplos componentes. Como desenvolvemos Sistemas Distribu\u00eddos? Refor\u00e7ando, distribuir \u00e9 dividir a computa\u00e7\u00e3o/armazenamento em diversos componentes, possivelmente geograficamente distantes , e coordenar suas a\u00e7\u00f5es para que resolvam a tarefa em quest\u00e3o de forma correta. Com a distribui\u00e7\u00e3o objetiva-se usar recursos dispon\u00edveis nos hosts onde os componentes s\u00e3o executados e usar de redund\u00e2ncia para garantir que o servi\u00e7o sofra degrada\u00e7\u00e3o graciosa em caso de falhas, ou seja, fazer com que o servi\u00e7o continue funcionando, mesmo que com vaz\u00e3o reduzida, lat\u00eancia aumentada, menor capacidade de tratamento de requisi\u00e7\u00f5es concorrentes, ou com funcionalidades desabilitadas. Para colaborar, as diversas partes do sistema distribu\u00eddo devem se comunicar. Isto pode ser feito de diversas formas e em diversos n\u00edveis de abstra\u00e7\u00e3o. Por exemplo, no caso troca de mensagens, estas podem ser desde pacotes de bytes entregues pelo IP/UDP como por troca de mensagens ordenadas, fluxos de dados , ou invoca\u00e7\u00e3o remota de procedimentos . Implementar estas abstra\u00e7\u00f5es em si j\u00e1 \u00e9 uma tarefa complicada, pois \u00e9 preciso levar em considera\u00e7\u00e3o que os componentes de um sistema distribu\u00eddo falham independentemente , executam em hosts com rel\u00f3gios dessincronizados , s\u00e3o desenvolvidos usando-se linguagens diversas , sistemas operacionais distintos , com arquiteturas diferentes e por times independentes . Apesar de tantas vari\u00e1veis, as abstra\u00e7\u00f5es precisam permitir que as aplica\u00e7\u00f5es que as usem possam se coordenar nos m\u00ednimos detalhes. Quero dizer, a complexidade de se implementar estas abstra\u00e7\u00f5es j\u00e1 \u00e9 grande por si s\u00f3 e se formos reinventar a roda a cada novo sistema, n\u00e3o faremos muitos avan\u00e7os. Mas, como voc\u00eas bem sabem, camadas de abstra\u00e7\u00e3o s\u00e3o a chave para se lidar com complexidade. Assim, sistemas distribu\u00eddos s\u00e3o como cebolas, cheias de camadas e que nos fazem chorar quando precisamos manipul\u00e1-las. Mas lembrem-se, tamb\u00e9m que e voc\u00ea n\u00e3o quer que seu sistema seja como ogros, temperamentais e mal-cheirosos. Felizmente, para cada problema que tenha que resolver, h\u00e1 uma boa probabilidade de que algu\u00e9m j\u00e1 o tenha atacado e disponibilizado uma solu\u00e7\u00e3o, de forma comercial ou n\u00e3o. Com sistemas distribu\u00eddos, n\u00e3o \u00e9 diferente, e no caso da comunica\u00e7\u00e3o entre componentes distribu\u00eddos, a solu\u00e7\u00e3o normalmente \u00e9 usar um middleware . Middleware De acordo com Tanenbaum & Van Steen , middleware \u00e9 ... the software layer that lies between the operating system and applications on each side of a distributed computing system in a network. Isto \u00e9, o middleware \u00e9 a camada ware que fica no middle , entre, o software e o hardware . Software, no caso, \u00e9 a aplica\u00e7\u00e3o distribu\u00edda sendo desenvolvida e hardware \u00e9 a abstra\u00e7\u00e3o do host em que se executam os componentes, provida pelo sistema operacional. Uso aqui o termo abstra\u00e7\u00e3o porqu\u00ea o sistema operacional pode encapsular hardware real, mas tamb\u00e9m pode encapsular outra abstra\u00e7\u00e3o de hardware , por exemplo, uma m\u00e1quina virtual ou cont\u00eainer. A figura seguinte 2 mostra um exemplo com tr\u00eas aplica\u00e7\u00f5es executando sobre um middleware , que por sua vez \u00e9 executado sobre diferentes sistemas operacionais, em hosts conectados por uma rede de comunica\u00e7\u00e3o. Com este cen\u00e1rio em mente, \u00e9 importante entender o que diz Sacha Krakowiak quando afirma que as principais fun\u00e7\u00f5es do middleware s\u00e3o: esconder a distribui\u00e7\u00e3o e o fato de que um aplica\u00e7\u00e3o \u00e9 geralmente composta por m\u00faltiplas partes, executando em localiza\u00e7\u00f5es geograficamente distintas, esconder a heterogeneidade dos v\u00e1rios componentes de hardware, sistemas operacionais e protocolos de comunica\u00e7\u00e3o prover interfaces uniformes, de alto n\u00edvel e padronizadas para os desenvolvedores de aplica\u00e7\u00e3o e integradores, de forma que aplica\u00e7\u00f5es possam ser facilmente compostas, reusadas, portadas e feitas interoper\u00e1veis. Assim, os middleware facilitam a conex\u00e3o entre componentes e permitem o uso de protocolos mais abstratos que as opera\u00e7\u00f5es de write(byte[]) e read(): byte[] dos protocolos de baixo n\u00edvel, escondendo a complexidade da coordena\u00e7\u00e3o de sistemas independentes. Desenvolver sistemas distribu\u00eddos sem usar um middleware \u00e9 como desenvolver um aplicativo sem usar quaisquer bibliotecas: poss\u00edvel, mas complicado, e estar\u00e1 certamente reinventando a roda. Isto \u00e9, voc\u00ea praticamente tem que refazer o middleware antes de desenvolver o sistema em si. Idealmente, com o middleware o desenvolvedor conseguiria facilmente implementar uma aplica\u00e7\u00e3o em a distribui\u00e7\u00e3o fosse totalmente transparente, levando o sistema, uma cole\u00e7\u00e3o de sistemas computacionais (software ou hardware) independentes, a se apresentar para o usu\u00e1rio como um sistema \u00fanico , monol\u00edtico. Pense no browser e na WWW, por exemplo; o quanto voc\u00ea sabe sobre as p\u00e1ginas estarem particionadas em milh\u00f5es de servidores? Isso \u00e9 o que chamamos de transpar\u00eancia. Transpar\u00eancia Se n\u00e3o h\u00e1 qualquer ind\u00edcio de que a aplica\u00e7\u00e3o \u00e9 distribu\u00edda, ent\u00e3o temos transpar\u00eancia total . Podemos quebrar esta transpar\u00eancia total em v\u00e1rias transpar\u00eancias mais simples: Acesso , Localiza\u00e7\u00e3o , Reloca\u00e7\u00e3o , Migra\u00e7\u00e3o , Replica\u00e7\u00e3o , e Falha . Vejamos cada uma destas separadamente. Transpar\u00eancia de Acesso A transpar\u00eancia de acesso diz respeito \u00e0 representa\u00e7\u00e3o de dados e mecanismos de invoca\u00e7\u00e3o (arquitetura, formatos, linguagens...). Cada computador tem uma arquitetura e uma forma de representar seus dados. Por exemplo, considere os padr\u00f5es para representa\u00e7\u00e3o de n\u00fameros em ponto flutuante IEEE e IBM. Ambos dividem os bits em sinal, expoente e mantissa, mas com tamanhos diferentes. IEEE 3 Precis\u00e3o Tamanho total (bits) Sinal (bits) Expoente (bits) Mantissa (bits) Half 16 1 5 10 Single 32 1 8 23 Double 64 1 11 52 Quadruple 128 1 15 112 IBM 4 Precis\u00e3o Tamanho total (bits) Sinal (bits) Expoente (bits) Mantissa (bits) Single 32 1 7 24 Double 64 1 7 56 Quadruple 128 1 7 112 (8b ignorados) E se dois componentes de um SD executam em m\u00e1quinas com arquiteturas diferentes, como trocam n\u00fameros em ponto flutuante? \u00c9 preciso que usem um padr\u00e3o conhecido por ambos os hosts , seja o padr\u00e3o a arquitura \"nativa\" do host ou um padr\u00e3o intermedi\u00e1rio, definido pelo middleware . A mesma quest\u00e3o \u00e9 v\u00e1lida para representa\u00e7\u00f5es de strings e classes, e diferen\u00e7as de sistemas operacionais e linguagens. No caso espec\u00edfico das strings, pense em um programa escrito em linguagem C e que este programa deva comunicar-se com um outro, escrito em Java, e trocar strings com o mesmo. Enquanto em C uma string \u00e9 uma sequ\u00eancia de bytes imprim\u00edveis terminadas por um \\0 , em Java uma string \u00e9 uma classe que encapsula uma sequ\u00eancia de chars, sendo que cada char \u00e9 um c\u00f3digo 16 bits representativo de um c\u00f3digo Unicode 5 . Como transferir strings entre duas plataforms? N\u00e3o faz\u00ea-lo? Simplificar a string Java? Estender a string C? Transpar\u00eancia de Acesso Para se tentar obter transapar\u00eancia de acesso, \u00e9 importante que se use padr\u00f5es implementados em m\u00faltiplas arquiteturas, abertos e bem conhecidos, com interfaces bem definidas . Transpar\u00eancia de Localiza\u00e7\u00e3o A transpar\u00eancia de localiza\u00e7\u00e3o diz respeito a onde est\u00e1 o objeto acessado pela aplica\u00e7\u00e3o, seja um BD, p\u00e1gina Web ou servi\u00e7o de echo: pouco importa ao usu\u00e1rio, se est\u00e1 dentro da mesma m\u00e1quina de onde executa o acesso, se na sala ao lado ou em um servidor do outro lado do globo, desde que o servi\u00e7o seja provido de forma r\u00e1pida e confi\u00e1vel. A esta transpar\u00eancia \u00e9 essencial uma boa distribui\u00e7\u00e3o do servi\u00e7o, sobre uma rede com baixa lat\u00eancia, ou o uso de t\u00e9cnicas que permitam esconder a lat\u00eancia. Escondendo a Lat\u00eancia Para se esconder a lat\u00eancia, v\u00e1rias t\u00e1ticas s\u00e3o utiliz\u00e1veis: Caching de dados Em vez de sempre buscar os dados no servidor, mantenha c\u00f3pias locais dos dados que mudam menos (e.g., o CSS do stackoverflow). Use paralelismo Em vez de validar formul\u00e1rio ap\u00f3s preenchimento de cada campo, valide em paralelo enquanto usu\u00e1rio preenche o campo seguinte. Use callbacks para indicar campos com problemas a serem corrigidos. Saiba que nem todo problema \u00e9 paraleliz\u00e1vel, por exemplo, autentica\u00e7\u00e3o Use programa\u00e7\u00e3o ass\u00edncrona AsyncIO C# await/async Futures e Promises Outra forma de diminuir lat\u00eancia \u00e9 trazer para pr\u00f3ximo do usu\u00e1rio parte da computa\u00e7\u00e3o. Isto \u00e9 comumente feito com a interface com usu\u00e1rio, mas pode ser usado tamb\u00e9m para outras partes do sistema. Como exemplo do primeiro, pense em consoles de video-game que fazem o processamento gr\u00e1fico pesado de jogos online na casa do usu\u00e1rio 6 . Como exemplo do segundo, pense em aplicativos que mant\u00e9m os dados em celulares at\u00e9 que uma boa conex\u00e3o, por exemplo WiFi, esteja dispon\u00edvel para sincronizar com o servidor. De forma geral, pense em esconder lat\u00eancia pelos seguintes passos: Distribua tarefas Delegue computa\u00e7\u00e3o aos clientes (e.g., JavaScript e Applets Java) Particione dados entre servidores (e.g., Domain Name Service e World Wide Web) para dividir a carga e aumentar a vaz\u00e3o Aproxime dados dos clientes Mantenha c\u00f3pias de dados em m\u00faltiplos lugares. Atualize dados de acordo com necessidade (e.g., cache do navegador, com c\u00f3digo do google.com sendo atualizado a cada 4 dias) Transpar\u00eancia de Reloca\u00e7\u00e3o As vezes componentes do sistema distribu\u00eddo precisam ser movimentados de uma localiza\u00e7\u00e3o \u00e0 outra, por exemplo porqu\u00ea um novo host foi contratado. Se implementadas corretamente, as t\u00e9cnicas que entregam transpar\u00eancia de localiza\u00e7\u00e3o n\u00e3o deixam que o cliente perceba a movimenta\u00e7\u00e3o, no que chamamos transpar\u00eancia de Reloca\u00e7\u00e3o. Rede de baixa lat\u00eancia Distribui\u00e7\u00e3o inteligente E.g: Servi\u00e7os de nome M\u00faltiplas c\u00f3pias C\u00f3pias tempor\u00e1rias Transpar\u00eancia de Migra\u00e7\u00e3o Do ponto de vista do pr\u00f3prio servi\u00e7o, n\u00e3o perceber que se est\u00e1 sendo movimentado \u00e9 chamado transpar\u00eancia de Migra\u00e7\u00e3o. Um servi\u00e7o com esta propriedade, n\u00e3o precisa ser parado e reconfigurado quando a mudan\u00e7a acontece. Uma das formas de se implementar esta propriedade \u00e9 atrav\u00e9s da migra\u00e7\u00e3o provida por m\u00e1quinas virtuais, usado, por exemplo, para consolidar o uso de servidores em nuvens computacionais. Veja o exemplo do VMotion da VMware Na verdade, a movimenta\u00e7\u00e3o neste cen\u00e1rio, \u00e9 uma c\u00f3pia da m\u00e1quina virtual. Uma vez que a c\u00f3pia esteja pr\u00f3xima do fim, a imagem original \u00e9 congelada, a c\u00f3pia conclu\u00edda, e h\u00e1 um chaveamento na rede para se direcionar toda comunica\u00e7\u00e3o para nova c\u00f3pia. O m\u00e1quina original \u00e9 ent\u00e3o descartada. Transpar\u00eancia de Replica\u00e7\u00e3o A capacidade de ter c\u00f3pias de um servi\u00e7o e de direcionar trabalho de uma para outra \u00e9 tamb\u00e9m \u00fatil para se obter transpar\u00eancia no caso de falhas. Isto porqu\u00ea para se manter um servi\u00e7o funcional a despeito de falhas, \u00e9 preciso ter m\u00faltiplas c\u00f3pias, prontas para funcionar a qualquer momento. Dependendo das garantias desejadas na manuten\u00e7\u00e3o da consist\u00eancia entre as c\u00f3pias, o custo pode variar muito, de forma que para se ter um custo menor, tem-se garantias mais fracas, por exemplo, que as r\u00e9plicas tem um atraso entre elas de no m\u00e1ximo X X minutos. Este \u00e9 um dilema parecido com o TCP x UDP, em que mais garantias implicam em maior custo de comunica\u00e7\u00e3o. Algumas aplica\u00e7\u00f5es toleram inconsist\u00eancias e podem viver com menores custos. Um exemplo famoso \u00e9 o dos \"carrinhos de compra\" da Amazon.com , que podem fechar pedidos com conte\u00fado diferente do desejado pelo cliente. Outras aplica\u00e7\u00f5es s\u00e3o normalmente constru\u00eddas com requisitos de consist\u00eancia forte entre as r\u00e9plicas, como sistemas financeiros. Para estas aplica\u00e7\u00f5es, uma t\u00e9cnica importante para se conseguir replica\u00e7\u00e3o \u00e9 o uso de frameworks de comunica\u00e7\u00e3o em grupo , que entregam para m\u00faltiplas inst\u00e2ncias de um mesmo servi\u00e7o, as mesmas mensagens, permitindo que elas se mantenham como c\u00f3pias. Esta t\u00e9cnica funciona se os servi\u00e7os forem m\u00e1quinas de estado determin\u00edsticas, que consideram como eventos as mensagens entregues pelo protocolo de comunica\u00e7\u00e3o em grupo e \u00e9 denominada replica\u00e7\u00e3o de m\u00e1quinas de estado . stateDiagram [Estado Inicial] --> Estado 1 Estado 1 --> Estado 2 Estado 2 --> Estado 1 Estado 1 --> Estado N Todo Figura com state machine replication Novamente \u00e9 preciso chamar \u00e0 aten\u00e7\u00e3o a quest\u00e3o dos custos desta t\u00e9cnica. Replica\u00e7\u00e3o de M\u00e1quinas de Estados \u00e9 muito custosa e por isso faz-se um esfor\u00e7o para n\u00e3o utiliz\u00e1-la ou para utiliz\u00e1-la em \"cantinhos\" do sistema onde inconsist\u00eancias s\u00e3o absolutamente caras demais para sere permitidas. Isto porqu\u00ea manter m\u00faltiplas c\u00f3pias \\Rightarrow \\Rightarrow sincroniza\u00e7\u00e3o \\Rightarrow \\Rightarrow custos. Se houver mudan\u00e7as frequentes nos dados, tal custo precisa ser pago tamb\u00e9m frequentemente. Mitiga\u00e7\u00f5es incluem uso de r\u00e9plicas tempor\u00e1rias, protocolos de invalida\u00e7\u00e3o de cache, contrata\u00e7\u00e3o de redes com mais largura de banda e menor lat\u00eancia, sendo que estes \u00faltimos esbarram em limita\u00e7\u00f5es financeiras e f\u00edsicas. Transpar\u00eancia de Concorr\u00eancia Outra transpar\u00eancia almej\u00e1vel \u00e9 de concorr\u00eancia. Isto \u00e9, quem acessa um servi\u00e7o deveria ser indiferente ao fato de que o mesmo pode estar sendo acessado por outros. Isto \u00e9 importante tanto em termos de seguran\u00e7a, no sentido de que um cliente n\u00e3o deveria acessar os dados do outro, caso isso seja um requisito do sistema, quanto tem termos de desempenho. Nuvens computacionais s\u00e3o um exemplo de onde este tipo de transpar\u00eancia \u00e9 essencial. Considere um servi\u00e7o de banco de dados em uma nuvem qualquer. Para prover a mesma interface com a qual usu\u00e1rios est\u00e3o acostumados a anos, \u00e9 poss\u00edvel que este servi\u00e7o seja simplesmente um wrapper ao redor do SGBD que se comprava e instalava in-house anteriormente. Para se tornar vi\u00e1vel, contudo, uma mesma inst\u00e2ncia deve servir m\u00faltiplos clientes, os tenants , sem que a carga de trabalho introduzida por um, interfira no desempenho do outro. No meio, chamamos esta propriedade de multi-tenancy , mas \u00e9 apenas um exemplo de transpar\u00eancia de concorr\u00eancia. Esta transpar\u00eancia est\u00e1 fundamentalmente ligada \u00e0 escalabilidade, isto \u00e9, \u00e0 adequa\u00e7\u00e3o dos pool de recursos \u00e0s demandas dos clientes: se mais clientes est\u00e3o presentes, ent\u00e3o aumente a quantidade de servidores ( scale up ) e separe as cargas ( sharding ); se menos clientes est\u00e3o presentes, ent\u00e3o desligue algumas m\u00e1quinas ( scale down ) e consolide recursos. Desafios para se obter transpar\u00eancia Apesar de desej\u00e1veis, as transpar\u00eancia discutidas s\u00e3o dif\u00edceis de se conseguir, principalmente se em conjunto. Isto porqu\u00ea, do ponto de vista de usu\u00e1rios espalhados pelo globo, atr\u00e1s de redes heterog\u00eaneas e com possibilidade de erros, acontecer\u00e3o atrasos e perdas na comunica\u00e7\u00e3o, denunciando a distribui\u00e7\u00e3o. Do ponto de vista do desenvolvedor , \u00e9 preciso tomar decis\u00f5es baseado em premissas ligadas \u00e0 realidade da rede. Por exemplo, se uma requisi\u00e7\u00e3o n\u00e3o foi respondida, quanto tempo um cliente deve esperar antes de reenvi\u00e1-la, possivelmente para outro servidor, sem incorrer em risco significativo da requisi\u00e7\u00e3o ser processada duas vezes? A resposta para esta pergunta \u00e9 muito mais complicada do que pode parecer. De forma geral , qualquer aumento de transpar\u00eancia tem um custo, seja em termos monet\u00e1rios (e.g., contrata\u00e7\u00e3o de enlace dedicado ou de host em outra posi\u00e7\u00e3o geogr\u00e1fica), ou em termos de desempenho (e.g., coordenar a entrega de mensagens em sistemas de comunica\u00e7\u00e3o em grupo). Provavelmente os maiores obst\u00e1culos para se alcan\u00e7ar os diversos tipos de transpar\u00eancia s\u00e3o impostos pela parte da infraestrutura que torna o sistema distribu\u00eddo poss\u00edvel, a rede. Para entender o porqu\u00ea, vejamos algumas premissas normalmente assumidas sobre a rede que n\u00e3o s\u00e3o, definitivamente, verdade: A lat\u00eancia \u00e9 zero. A largura de banda \u00e9 infinita. A rede \u00e9 confi\u00e1vel. A rede \u00e9 segura. A rede \u00e9 homog\u00eanea. A rede \u00e9 est\u00e1tica. A rede tem acesso gr\u00e1tis. A rede \u00e9 administrada por voc\u00ea ou algu\u00e9m acess\u00edvel. Escalabilidade Para terminar, deixem-me apenas retomar um termo usado acima, escalabilidade . O termo est\u00e1 muito em voga e \u00e9 usado, normalmente, para descrever a capacidade de um sistema de se adequar a varia\u00e7\u00f5es de carga de trabalho. Embora seja um uso v\u00e1lido, h\u00e1 outros tipos de escalabilidade. Escalabilidade Tamanho: N\u00famero de usu\u00e1rios que suporta. Geogr\u00e1fica: Regi\u00e3o que cobre. Administrativa: N\u00famero de dom\u00ednios administrativos. H\u00e1 v\u00e1rias possibilidades: seja espec\u00edfico e exija especificidade. Tipos H\u00e1 quem diga que j\u00e1 somos todos desenvolvedores de sistemas distribu\u00eddos . Ainda assim, \u00e9 importante entender que h\u00e1 v\u00e1rios tipos de sistemas distribu\u00eddos, com diversas finalidades e diversas as arquiteturas, pois classifica\u00e7\u00f5es nos ajudam a pensar sobre sistemas e a encontrar e reusar solu\u00e7\u00f5es previamente testadas. Computa\u00e7\u00e3o de Alto Desempelho A possibilidade de agregar poder de processamento de muitos computadores em um rede de comunica\u00e7\u00e3o com alt\u00edssima largura de banda nos permite atacar problemas computacionalmente muito intensos Clusters como o da imagem a seguir, do High Performance Computing Center de Stuttgart, s\u00e3o compartilhados por pesquisadores resolvendo problemas \u00e1reas como bio-inform\u00e1tica, engenharia, economia, intelig\u00eancia artificial, etc. Na engenharia, por exemplo, HPC pode ser usada para testar a efici\u00eancia de projetos sem construir prot\u00f3tipos, seja de uma turbina um carro ou uma vaca Os n\u00f3s de um cluster s\u00e3o normalmente divididos em tr\u00eas categorias: administra\u00e7ao, computa\u00e7\u00e3o e armazenamento. N\u00f3s de administra\u00e7\u00e3o implementam um monitoramento distribu\u00eddo dos demais n\u00f3s, servem de ponto de entrada para usu\u00e1rios e prov\u00eaem interface para submiss\u00e3o de tarefas. O Oscar , por exemplo, \u00e9 uma \u00e9 conjunto de softwares para gerenciamento de clusters. Uma das ferramentas inclusas no Oscar \u00e9 o OpenPBS, pelo qual tarefas s\u00e3o atribu\u00eddas aos diversos n\u00f3s do sistema que sejam alocados para tal tarefa. O OpenPBS portanto \u00e9 tamb\u00e9m um sistema distribu\u00eddo. Finalmente, as tarefas submetidas em si s\u00e3o normalmente aplica\u00e7\u00f5es distribu\u00eddas. Cada processo executando em uma m\u00e1quina distrinta \u00e9 normalmente respons\u00e1vel por resolver uma parte do problema. Para facilitar a comunica\u00e7\u00e3o entre as partes do dom\u00ednio, s\u00e3o normalmente utilizadas API como a Message Passing Interface (MPI), que prov\u00ea fun\u00e7\u00f5es para distribui\u00e7\u00e3o e agrega\u00e7\u00e3o de dados entre os v\u00e1rios processos. Este tipo de sistemas distribu\u00eddos s\u00e3o o que chamamos de fortemente acoplados pois a falha em um dos componentes leva normalmente \u00e0 falha de todo o sistema. Do ponto de vista deste curso, estamos mais interessados em sistemas fracamente acoplados. Sistemas de Informa\u00e7\u00e3o Provavelmente mais comuns entre os profissionais da computa\u00e7\u00e3o, os sistemas de informa\u00e7\u00e3o distribu\u00eddos s\u00e3o encontrados em diversas formas. De fato, o termo \"sistema de informa\u00e7\u00e3o\" \u00e9 t\u00e3o abrangente, que dificilmente um sistema distribu\u00eddo n\u00e3o estaria nesta classe. O seguinte \u00e9 um exemplo de uma arquitetura em tr\u00eas camadas, onde a primeira implementa a interface com o usu\u00e1rio, a segunda cont\u00e9m a l\u00f3gica do neg\u00f3cio, e a terceira mantem os dados. Pe\u00e7a fundamental desta abordagem, os bancos de dados na terceira camada s\u00e3o frequentemente transacionais. Isto \u00e9, eles prov\u00eaem as garantias na execu\u00e7\u00e3o de transa\u00e7\u00f5es conhecidas como propriedades ACID. ACID Atomicidade: transa\u00e7\u00f5es s\u00e3o tratadas de forma indivis\u00edvel, isto \u00e9, ou tudo ou nada. Consist\u00eancia: transa\u00e7\u00f5es levam banco de um estado consistente a outro. E.g., x == 2*y Isolamento: transa\u00e7\u00f5es n\u00e3o v\u00eaem dados n\u00e3o comitados umas das outras. Durabilidade: os efeitos de uma transa\u00e7\u00e3o comitada devem persistir no sistema a despeito de falhas. Para relembrar no que implica ACID, considere a seguinte sequ\u00eancia de opera\u00e7\u00f5es, onde X e Y s\u00e3o valores guardados pelo banco de dados, a, b e c s\u00e3o vari\u00e1veis definidas no programa, e SELECT e SET s\u00e3o comandos para ler e modificar o banco de dados. 1 2 3 4 5 1: a = SELECT X 2: c = a * 2 3: b = c + 10 4: SET X=c 5: SET Y=b Suponha duas inst\u00e2ncias desta sequ\u00eancia, T_1 T_1 e T_2 T_2 , concorrentes, em que as opera\u00e7\u00f5es escalonadas da seguinte forma. 1 2 3 4 5 6 7 8 9 10 11 T1 T2 1: a = SELECT X 2: c = a * 2 3: b = c + 10 4: SET X=c 5: a = SELECT X 6: c = a * 2 7: b = c + 10 8: SET X=c 9: SET Y=b 10:SET Y=b Ao final da execu\u00e7\u00e3o, X ter\u00e1 o valor atribu\u00eddo por T_2 T_2 , mas Y Y ter\u00e1 o valor de T_1 T_1 . Este escalonamento violou a consist\u00eancia do banco de dados por qu\u00ea as opera\u00e7\u00f5es n\u00e3o foram executadas isoladamente . Tente imaginar a dificuldade de se implementar um banco de dados distribu\u00eddo. Isto \u00e9, um banco em que v\u00e1rios n\u00f3s mantem os dados, participam de transa\u00e7\u00f5es e, portanto, precisam coordenar-se para manter os dados consistentes. A figura a seguir mostra um cen\u00e1rio com tr\u00eas bancos. Imagine que em um deles est\u00e1 uma rela\u00e7\u00e3o com os dados dos clientes, em outro, os dados do estoque e no terceiro as ordens de compra. Quando um cliente faz um pedido, o cliente deve ser validado no primeiro n\u00f3, o item \u00e9 removido do estoque no segundo n\u00f3, e no terceiro \u00e9 disparada uma cobran\u00e7a para o cliente. Se qualquer destas tr\u00eas rela\u00e7\u00f5es n\u00e3o for corretamente consultada e alterada, os efeitos podem ser catastr\u00f3ficos para o neg\u00f3cio ou para o cliente. Como implementar ACID neste banco de dados? Embora veremos isso um pouco mais para frente neste material, por enquanto, apenas assuma que n\u00e3o \u00e9 exatamente f\u00e1cil ou barato. Esta dificuldade foi a raz\u00e3o do surgimento dos bancos de dados NOSQL (n\u00e9e NoSQL), dos quais uma pequena amostra \u00e9 dada pela seguinte figura. Tambem discutiremos como estes bancos de dados funcionam, quando falarmos sobre sistemas P2P. Integra\u00e7\u00e3o de Aplica\u00e7\u00f5es Frequentemente \u00e9 necess\u00e1rio integrar sistemas de informa\u00e7\u00e3o legados com sistemas mais modernos, ou simplesmente exp\u00f4-los usando uma interface mais moderna. Nestes casos, \u00e9 poss\u00edvel integrar diversos sistemas usando um middleware que os encapsule. O middleware pode, por exemplo, se expor via interface REST para os clientes, mas consultar o sistema legado em um padr\u00e3o antigo. Outro exemplo \u00e9 o sistema na imagem seguinte, que mostra diversos departamentos de uma empresa conversando via troca de mensagens. Observe que nenhum departamento precisa conversar diretamente com os outros, ou mesmo conhec\u00ea-los. Eles apenas publicam a mensagem para quem puder tratar. Da mesma forma, a resposta vem na forma de uma mensagem. Este \u00e9 um exemplo de sistema fracamente acoplado , pois nenhum componente tem que saber da exist\u00eancia do outro ou se torna indispon\u00edvel caso os outros falhem. Siga este link para ler mais sobre este tipo de sistema. Sistemas Pervasivos/Ub\u00edquos Segundo Weiser, 1993 Ubiquitous computing is the method of enhancing computer use by making many computers available throughout the physical environment, but making them effectively invisible to the user. O que \u00e9 importante aqui \u00e9 o foco na tarefa em vez de na ferramenta. Assim, sistemas pervasivos devem ajudar as pessoas a realizar suas tarefas, de forma impl\u00edcita, sem ter que pensar em como a tarefa ser\u00e1 executada. Para que seja realizada, a computa\u00e7\u00e3o pervasiva requer que dispositivos detectem o contexto em que est\u00e3o inseridos, combinem-se de forma ad-hoc e compartilhem informa\u00e7\u00f5es. Exemplos fict\u00edcios e reais Smart Life Esta \u00e9 uma vis\u00e3o futur\u00edstica da Microsoft para a integra\u00e7\u00e3o de tecnologias. Amazon Go Este mercado automatiza o pagamento dos itens escolhidos pelo consumidor, utilizando t\u00e9cnicas de processamento digital de imagens, aprendizado de m\u00e1quina e sensores. Reality Check Para quem viu o filme Minority Report e sonhou com as UI do futuro, aqui vai um reality check . Para quem n\u00e3o viu ainda, corrija esta falha em sua forma\u00e7\u00e3o t\u00e9cnica o mais rapidamente poss\u00edvel. Redes de Sensores e Internet das Coisas Eu vou me arriscar colocando Redes de Sensores e Internet das Coisas como uma subsess\u00e3o de Sistemas Pervasivos. Isto porqu\u00ea, a meu ver, as redes de sensores s\u00e3o parte da infraestrutura para se obter sistemas pervasivos; s\u00e3o os sensores que percebem mudan\u00e7as contexto e \"le\u00eam\" o estado do contexto atual e alimentam outros sistemas que reagem a tal estado. A Internet das Coisas (IoT, do ingl\u00eas Internet of Things ) vai tamb\u00e9m na mesma linha, levando \u00e0 integra\u00e7\u00e3o entre sensores, atuadores, e outros dispositivos que nos servem, em um ambiente de computa\u00e7\u00e3o pervasiva. \"Mas se \u00e9 assim, qual o risco?\", voc\u00ea pergunta. Bem, a Internet das Coisas pode ser vista como algo al\u00e9m dos sistemas pervasivos, pois se estes \u00faltimos s\u00e3o focados nos humanos em um certo contexto, a IoT n\u00e3o necessariamente foca-se nos humanos, mas na realiza\u00e7\u00e3o de alguma tarefa. Por exemplo, um sistema de irriga\u00e7\u00e3o que percebe o n\u00edvel de humidade do ar, analisa previs\u00f5es de chuva e decide em quanto irrigar uma planta\u00e7\u00e3o de laranjas provavelmente n\u00e3o se importar\u00e1 com a presen\u00e7a ou n\u00e3o de um humano na planta\u00e7\u00e3o. Para aprender mais sobre IoT, veja este link que descreve diversos projetos europeus na \u00e1rea. Todo Alguns exemplos de IoT e redes de sensores: Smart grid e lavadora que escolhe hor\u00e1rio Termostatos que percebem movimento Fechaduras que se abrem quando o dono se aproxima Movimenta\u00e7\u00e3o de tropas e de fauna \u00cdndices de polui\u00e7\u00e3o Abalos s\u00edsmicos e predi\u00e7\u00e3o de avalanches link Uma nota sobre privacidade nos sistemas pervasivos \u00c0 medida em que aumentamos o ambiente ao nosso redor ou a n\u00f3s mesmos com dispositivos computacionais, por um lado facilitamos nossa vida pois somos assistidos por tais dispositivos, mas por outro, nos tornamos cada vez mais dependentes nos mesmos, com s\u00e9rios riscos \u00e0 nossa privacidade. Isto ocorre por que para que realizem suas tarefas, os sistemas pervasivos precisam de cada vez mais informa\u00e7\u00f5es sobre n\u00f3s, e h\u00e1 sempre o risco de que estas informa\u00e7\u00f5es sejam usadas de forma que n\u00e3o nos apetece. Todo Exemplos de problemas de privacidade. Roomba mapeando sua casa . Ghost in the shell Snow crash Computa\u00e7\u00e3o Utilit\u00e1ria Um tipo importante de sistema distribu\u00eddo mais recente s\u00e3o as nuvens computacionais, usadas no provimento de computa\u00e7\u00e3o utilit\u00e1ria. Este tipo de sistema, embora possa ser pensando como infraestrutura para outros sistemas distribu\u00eddos, s\u00e3o, na verdade, complexas pe\u00e7as de engenharia, com diversos subsistemas respons\u00e1veis por sincroniza\u00e7\u00e3o de rel\u00f3gios, monitora\u00e7\u00e3o de falhas, coleta de logs, roteamento eficiente tolerante a falhas, movimenta\u00e7\u00e3o de recursos virtualizados para consolida\u00e7\u00e3o de recursos f\u00edsicos, armazenamento redundante de dados, etc. O seguinte v\u00eddeo mostra, em 360 graus, um dos datacenters do Google, para que voc\u00ea tenha ideia da escala em que estes sistemas s\u00e3o constru\u00eddos. Para uma viagem fotogr\u00e1fica, siga este link Arquiteturas De acordo com David Garlan and Mary Shaw, January 1994, CMU-CS-94-166, em An Introduction to Software Architecture ... an architectural style determines the vocabulary of components and connectors that can be used in instances of that style, together with a set of constraints on how they can be combined. These can include topological constraints on architectural descriptions (e.g., no cycles). Other constraints\u2014say, having to do with execution semantics\u2014might also be part of the style definition. Em outras palavras, um estilo ou padr\u00e3o arquitetural \u00e9 o conjunto de princ\u00edpios que prov\u00ea uma infraestrutura abstrata para uma fam\u00edlia de sistemas, e promove o reuso de projeto ao prover solu\u00e7\u00f5es para problemas recorrentes e frequentes . Componentes e Conectores Quando falamos sobre arquiteturas em sistemas distribu\u00eddos, estamos primariamente focados na forma como componentes se conectam, por meio de conectores, para implementar a solu\u00e7\u00e3o para um problema. graph LR (Componente 1) --> [Conector] --> (Componente 2) Dependendo de como s\u00e3o conectados, haver\u00e1 maior ou menor depend\u00eancia entre os componentes. Quando houver forte depend\u00eancia, diremos que os componentes est\u00e3o fortemente acoplados ( tightly coupled ). Caso contr\u00e1rio, diremos que est\u00e3o fracamente acoplados ( loosely coupled ). A raz\u00e3o \u00f3bvia para preferir sistemas fracamente conectados \u00e9 sua capacidade de tolerar disrup\u00e7\u00f5es; se um componente depende pouco de outro, ent\u00e3o n\u00e3o se incomodar\u00e1 com sua aus\u00eancia por causa de uma falha. Certos middleware permitem um acoplamento t\u00e3o fraco entre componentes, que estes n\u00e3o precisam se conhecer ou sequer estar ativos no mesmo momento. Tamb\u00e9m a quest\u00e3o da simplifica\u00e7\u00e3o de API, uma vez que o middleware pode impor um padr\u00e3o a ser seguido por todos os componentes e minimizar a necessidade os componentes conhecerem as interfaces uns dos outros. Cliente/Servidor A forma como os componentes se comunicam, isto \u00e9, os conectores usados, \u00e9 importante no estudo arquitetural. Mas tamb\u00e9m s\u00e3o importantes os pap\u00e9is assumidos pelos componentes na realiza\u00e7\u00e3o de tarefas. Neste sentido, provavelmente a arquitetura de computa\u00e7\u00e3o distribu\u00edda mais famosa \u00e9 a Cliente/Servidor . Na arquitetura Cliente/Servidor, como implicado pelo nome, h\u00e1 um processo que serve a pedidos realizados por outros processos. Isto \u00e9 feito quando o cliente o contacta o servidor e requer ( request ) a realiza\u00e7\u00e3o do servi\u00e7o. O servidor , por sua vez, pode desempenhar tarefas como fazer c\u00e1lculos, armazenar dados, ou repassar uma mensagem e, ao final da realiza\u00e7\u00e3o da tarefa, responder ( response ) ao cliente. Um mesmo servidor pode atender a diversos clientes e, geralmente, a comunica\u00e7\u00e3o entre os mesmos \u00e9 feita diretamente por sockets. Embora seja poss\u00edvel usar sockets de forma ass\u00edncrona, a API mais comum \u00e9 s\u00edncrona, isto \u00e9, quando um processo espera receber uma mensagem de outro, ele fica bloqueado esperando algum dado estar dispon\u00edvel para leitura no referido socket. Assim, geralmente a comunica\u00e7\u00e3o entre cliente e servidor segue o seguinte esquema: Observe que o cliente fica inativo enquanto espera a resposta e que o servidor fica inativo enquanto espera outras requisi\u00e7\u00f5es. Para minimizar os per\u00edodos de inatividade, o cliente pode usar o socket ass\u00edncronamente, o que n\u00e3o \u00e9 exatamente simples, ou usar m\u00faltiplos threads, para que continue operando mesmo enquanto um thread estiver bloqueado esperando a resposta do servidor. No lado do servidor, o minimiza\u00e7\u00e3o da ociosidade \u00e9 feita pelo uso de m\u00faltiplos clientes, concorrentes, e tamb\u00e9m pelo uso de m\u00faltiplos threads. Neste caso, contudo, \u00e9 necess\u00e1rio tomar muito cuidado para garantir que a concorr\u00eancia n\u00e3o causar\u00e1 efeitos indesejados nos dados e execu\u00e7\u00e3o das tarefas. Veja o caso de um banco de dados transacional, por exemplo, como discutido acima; ele precisa garantir ACID entre as transa\u00e7\u00f5es propostas pelos clientes. Embora tenhamos colocado aqui apenas um servidor atendendo aos clientes, em muitas aplica\u00e7\u00f5es modernas, m\u00faltiplos servidores atender\u00e3o ao conjunto de clientes. Pense por exemplo no servi\u00e7o de email do Google, o Gmail. Com os milh\u00f5es de usu\u00e1rios que tem, certamente h\u00e1 mais de um servidor implementando o servi\u00e7o. Provavelmente estes diversos servidores ficam atr\u00e1s do que chamamos de um balanceador de carga, que roteia as requisi\u00e7\u00f5es seguindo diferentes pol\u00edticas, por exemplo, round robin . Par-a-Par (P2P) Diferentemente de sistemas cliente/servidor, em que um n\u00f3 serve o outro, em sistemas par-a-par, os n\u00f3s s\u00e3o parceiros e tem igual responsabilidade (e da\u00ed o nome) na execu\u00e7\u00e3o das tarefas. Diversos sistemas P2P existem, sendo, provavelmente, os mais famosos, os sistemas de compartilhamento de arquivos. Nesta linha, embora diversos tenham existido, hoje o mais famoso \u00e9 o Bittorrent, mesmo que, como veremos adiante, n\u00e3o seja P2P puro. Outro exemplo importante por ter inspirado diversos outros sistemas \u00e9 o Chord. Neste sistema, n\u00f3s organizam-se em um anel l\u00f3gico e cada um se torna respons\u00e1vel por um dos segmentos do anel adjacente a onde se encontra no mesmo. Requisi\u00e7\u00f5es para correspondentes a um segmento s\u00e3o roteados para o n\u00f3 respons\u00e1vel usando uma tabela de rotas conhecida como finger table . Se tra\u00e7armos os caminhos apontados por esta tabela sobre o anel, desenharemos cordas sobre o mesmo, o que explica o nome do sistema. H\u00edbridos Embora cliente/servidor e P2P sejam arquiteturas cl\u00e1ssicas, boa parte dos sistemas que distribu\u00eddos podem ser na verdade consideradas h\u00edbridos. Considere um sistema de email, por exemplo. Embora clientes usem as funcionalidades dos servidores de email para enviar e receber mensagens, os servidores conversam uns com os outros para implementar a tarefa de encaminhar as mensagens. Neste sentido, o sistema \u00e9 um h\u00edbrido P2P e cliente/servidor. Outros exemplos abundam. Bancos de dados, e.g., DynamoDB, CassandraDB , Redis,... Jogos multiplayer (pense no particionamento dos mapas ) Compartilhamento de arquivos: Bittorrent Voltemos ao exemplo do Bittorrent; observe na figura adiante os diversos passos necess\u00e1rios \u00e0 recupera\u00e7\u00e3o do arquivo de interesse neste sistema. Diversos passos seguem a arquitetura cliente/servidor enquanto \"somente\" o passo de compartilhamento de arquivos \u00e9 P2P. Voltando ao exemplo do sistema de informa\u00e7\u00e3o, observe que o cliente acessa um servi\u00e7o, implementado por pares de n\u00f3s. Podemos dizer que tamb\u00e9m este \u00e9 h\u00edbrido. Sistemas multi-camadas Outra forma de hibridismo que podemos citar \u00e9 quando um componente haje tanto como cliente quanto como servidor. Veja o seguinte exemplo, conhecido no meio como arquitetura em 3-camadas (3 tiers ). Neste caso, \u00e9 interessante notar que esta disposi\u00e7\u00e3o dos componentes \u00e9 independente da disposi\u00e7\u00e3o f\u00edsica. De fato, as tr\u00eas camadas podem estar em um mesmo n\u00f3, ou combinadas duas a duas, neste \u00faltimo caso resultando em duas camadas. Por outro lado, cada camada pode ser subdividida em mais componentes, resultando \u00e9 m\u00faltiplos tiers, como neste exemplo de um sistema de busca na Web. Outras arquiteturas Diversas outras arquiteturas podem e foram propostas para o desenvolvimento de Sistemas Distribu\u00eddos. A moda da vez \u00e9 a chamada arquitetura de micro servi\u00e7os, na qual a divis\u00e3o de tarefas entre componentes visa levar aos componentes mais simples para tal tarefa. Assim, os mesmos podem ser replicados, escalonados, desenvolvidos e mantidos independentemnte. Cada tarefa conta ent\u00e3o com diversos componentes, organizados em camadas resolvendo um problema em espec\u00edfico, mas todos contribuindo para a realiza\u00e7\u00e3o de uma tarefa maior comum. N\u00f3s discutiremos micro-servi\u00e7os mais adiante. Por agora, apenas tenha em mente que embora seja vendido por muitos como tal, os micro-servi\u00e7os n\u00e3o s\u00e3o uma panac\u00e9ia . Todo Event sourcing Todo MOM Todo Pub/Sub Para aprender mais Para aprender mais sobre arquiteturas, consulte a seguinte refer\u00eancia: Distributed System Architectures and Architectural Styles . Para aprender um pouco sobre como funcionam as redes de um datacenter, definidas por software, assista ao seguinte v\u00eddeo, que fala sobre a infra-estrutura do Facebook. Muitos se referem a sistemas n\u00e3o-distribu\u00eddos como centralizados mas preferimos reservar este termo para sistemas distribu\u00eddos que usam um processo centralizador. O termo monol\u00edtico tamb\u00e9m \u00e9 muito usado em contraposi\u00e7\u00e3o \u00e0 arquitetura de micro-servi\u00e7os, mas sentimos que este uso \u00e9 em acordo como o oposto a distribu\u00eddo. \u21a9 Cap\u00edtulo 1, Figura 1, Distributed Systems: Principles and Paradigms \u21a9 IEEE Floating Point \u21a9 IBM Floating Point \u21a9 Simplifica\u00e7\u00f5es s\u00e3o poss\u00edveis, mas introduzem outras complexidades. \u21a9 O Google stadia \u00e9 uma plataforma de jogos que vai na contram\u00e3o desta ideia, levando todo o processamento pesado para a nuvem. \u21a9","title":"Introdu\u00e7\u00e3o"},{"location":"teaching/gbc074gsi028/intro/#introducao","text":"Escrever bons sistemas distribu\u00eddos \u00e9 uma tarefa que esbarra em diversos obst\u00e1culos, sendo a defini\u00e7\u00e3o do que \u00e9 um sistema distribu\u00eddo e do que \u00e9 ser \"bom\" neste contexto sendo nossos primeiros obst\u00e1culos.","title":"Introdu\u00e7\u00e3o"},{"location":"teaching/gbc074gsi028/intro/#o-que-sao-sistemas-distribuidos","text":"Para entendermos o que \u00e9 um Sistema Distribu\u00eddo, talvez seja mais f\u00e1cil por um sistema n\u00e3o-distribu\u00eddo ou, como os denominaremos aqui, sistema monol\u00edtico 1 . Pense na maioria das aplica\u00e7\u00f5es que desenvolveu no curso at\u00e9 agora. Mesmo que use diferentes bibliotecas e frameworks , toda a l\u00f3gica de neg\u00f3cio, armazenamento e interface com usu\u00e1rio est\u00e1 contida em um mesmo execut\u00e1vel e, quando executado, em um \u00fanico processo. Quando come\u00e7ou a programar este tipo de aplica\u00e7\u00e3o, o trabalho era basicamente colar blocos que se encaixavam perfeitamente, como Lego , bastando importar a biblioteca correta e invocar suas fun\u00e7\u00f5es. O cen\u00e1rio deve ter mudado um pouco no decorrer do curso e com o in\u00edcio de sua atividade profissional, quando passou a usar muito mais bibliotecas de muitos desenvolvedores diferentes, em equipes com v\u00e1rias pessoas, aumentando consideravelmente a complexidade do desenvolvimento; o resultado, contudo, continua sendo um artefato s\u00f3. Programar sistemas distribu\u00eddos \u00e9 dar outro salto em complexidade, pois frequentemente temos que usar pe\u00e7as que nunca foram pensadas para trabalharem juntas, nos for\u00e7ando a usar um pouco de , e fios, no caso, um tipo especial de fio conhecido como cabo de rede. De fato, a principal caracter\u00edstica de um sistema distribu\u00eddo em rela\u00e7\u00e3o a um n\u00e3o-distribu\u00eddo, \u00e9 a separa\u00e7\u00e3o e disper\u00e7\u00e3o de suas partes em v\u00e1rios componentes independentes (processos, sensores, atuadores, etc), mas que se coordenam para execu\u00e7\u00e3o de alguma tarefa. Assim, uma poss\u00edvel defini\u00e7\u00e3o de Sistema Distribu\u00eddo, que me agrada, \u00e9 a seguinte: Sistema Distribu\u00eddo Cole\u00e7\u00e3o de sistemas computacionais (software ou hardware), independentes mas com alguma forma de comunica\u00e7\u00e3o , que colaboram na execu\u00e7\u00e3o de alguma tarefa . No jarg\u00e3o da \u00e1rea, os componentes indepedentes s\u00e3o denominados n\u00f3s . Frequentemente, cada n\u00f3 do sistema ser\u00e1 na pr\u00e1tica um processo em um computador hospedeiro, um host , mas possivelmente m\u00faltiplos podem ser executados em um mesmo host ; isso n\u00e3o muda o fato de que s\u00e3o independentes e poderiam ser distanciados. Quanto \u00e0 comunica\u00e7\u00e3o, Os n\u00f3s podem compartilhar um espa\u00e7o de endere\u00e7amento comum, seja por que est\u00e3o co-locados no mesmo hospedeiro ou seja porqu\u00ea tem acesso a alguma forma de mem\u00f3ria compartilhada distribu\u00edda, que veremos mais adiante. Eles tamb\u00e9m podem se comunicar por mensagens trocadas via uma rede de comunica\u00e7\u00e3o, como a Internet. Quanto \u00e0 tarefa em comum, veja o seguinte exemplo, em que v\u00e1rios clientes trocam emails por meio de uma m\u00e1quina com a qual se comunicam para entregar mensagens a serem enviadas e receber mensagens a eles destinadas; enquanto aguardam a entrega, mensagens s\u00e3o armazenadas em um Sistema Gerenciador de Banco de Dados (SGBD) em uma outra m\u00e1quina, da qual os usu\u00e1rios n\u00e3o ttem ci\u00eancia. Neste exemplo, cada celular \u00e9 um n\u00f3 do sistema, assim como o processo respons\u00e1vel por receber os emails e encaminh\u00e1-los para o banco, bem como ler do banco e entregar para os destinat\u00e1rios. Neste exemplo, se o banco de dados para de funcionar, o processo na outra m\u00e1quina passa a ser in\u00fatil, uma vez que n\u00e3o pode armazenar novas mensagens e nem recuperar mensagens j\u00e1 armazenadas. Neste contexto, uma defini\u00e7\u00e3o mais c\u00ednica mas definitivamente realista \u00e9 a de Leslie Lamport , que certa vez disse: A distributed system is one in which the failure of a computer you didn't even know existed can render your own computer unusable. Mas se esta \u00e9 a realidade da programa\u00e7\u00e3o distribu\u00edda, por qu\u00ea faz\u00ea-lo?","title":"O qu\u00ea s\u00e3o Sistemas Distribu\u00eddos?"},{"location":"teaching/gbc074gsi028/intro/#por-que-desenvolvemos-sistemas-distribuidos","text":"Aqui diremos que um sistema \u00e9 bom se est\u00e1 sempre funcional, mesmo que partes do sistema deixem de funcionar, com bom desempenho, i.e., respostas r\u00e1pidas s\u00e3o dadas para o usu\u00e1rio, e com baixo custo, ou pelo menos t\u00e3o baixo qunto poss\u00edvel para realizar a tarefa para a qual foi constru\u00eddo. Enquanto ainda subjetiva, nossa defin\u00e7\u00e3o j\u00e1 nos permite estabelecer um pano de fundo para delinear as dificuldades de se implementar tais sistemas. Pensemos em algumas aplica\u00e7\u00f5es distribu\u00eddas com as quais interagimos todos os dias e que por seu sucesso devem ser bons sistemas distribu\u00eddos: Alguns exemplos \u00f3bvios s\u00e3o Amazon.com , Facebook , e GMail . Estes sistemas rodam em grandes data centers com milhares de m\u00e1quinas , estando constantemente sujeitos fontes queimadas, discos corruptos, mem\u00f3rias defeituosas. Apesar disto, dificilmente estes servi\u00e7os s\u00e3o reportados como fora do ar, s\u00e3o altamente respons\u00edveis e, goste ou n\u00e3o do que fazem, s\u00e3o bem sucedidos porqu\u00ea cumprem bem suas tarefas. Enquanto a primeira vista possa se pensar que as t\u00e9cnicas usadas na constru\u00e7\u00e3o destes sistemas devem ser muito especializadas e fora da realidade dos sistemas que n\u00f3s desenvolvemos, a verdade n\u00e3o poderia ser mais longe disto. O fato \u00e9 que computadores individuais tem capacidade limitada de processamento e armazenamento, mas nossa necessidade de poder computacional cresce exponencialmente. Assim, precisamos crescer nosso poder computacional, mas aumentar a capacidade de um dispositivo ( scale up ) mesmo de forma linear tem custo exponencial. O que nos resta ent\u00e3o \u00e9 agregar o poder computacional de diversos computadores \"baratos\" ( scale out ) para satisfazer nossas necessidades. De fato, praticamente qualquer sistema de informa\u00e7\u00e3o de sucesso necessitar\u00e1 aplicar as mesmas t\u00e9cnicas de computa\u00e7\u00e3o distribu\u00edda e superar as mesmas barreiras para conseguir atender a n\u00famero crescente de clientes (computacionais ou humanos), aumentar sua \u00e1rea de cobertura, e melhorar ou manter a qualidade do servi\u00e7o que presta, mesmo que n\u00e3o chegue a escala dos exemplos acima. Este \u00faltimo ponto, sobre qualidade do servi\u00e7o, tem a ver com a capacidade de um sistema se manter no ar a despeito de problemas, isto \u00e9, de ser tolerante a falhas. Toler\u00e2ncia a falhas implica em redund\u00e2ncia, em c\u00f3pias, o que fatidicamente implica em distribui\u00e7\u00e3o e em Sistemas Distribu\u00eddos . O rem\u00e9dio, contudo, \u00e9 bem amargo: com muitos computadores conectados, vem a necessidade de coorden\u00e1-los, de forma a agir de forma coerente, mesmo quando alguns deles falhem, e quanto mais computadores, maior \u00e9 a probabilidade de que pelo menos um deles tenha uma CPU, disco, fonte, ou que quer que seja, falhando. E estejam certos, computadores falham o tempo todo! N\u00f3s precisamos ent\u00e3o entender este ambiente, determinar e especificar v\u00e1rias de suas propriedades e comportamentos. Qual a probabilidade de um n\u00f3 parar de funcionar? Como os hospedeiros, ou melhor, como os processos se comunicam? Via mem\u00f3ria compartilhada ou por troca de mensagens? Se por mensagens, estas podem ser perdidas, atrasadas, corrompidas? Os rel\u00f3gios dos hospedeiros marcam o mesmo valor no mesmo instante, ou melhor, s\u00e3o sincronizados? Quanto tempo leva uma mensagem para sair de um n\u00f3 A e chegar a um n\u00f3 B? H\u00e1 agentes que possam querer perturbar o sistema, por exemplo para ganhar acesso a mais recursos do que seria justo? Quais os padr\u00f5es de acesso ao servi\u00e7os, isto \u00e9, se aumentam \u00e0 noite, diminuem no ver\u00e3o, etc? Assim, definimos modelos computacionais , que nos permitem desenvolver algoritmos adequados aos diversos problemas que enfrentamos. Definido ou identificado o modelo computacional, podemos distribuir nosso sistema, isto \u00e9, dividir a computa\u00e7\u00e3o/armazenamento em diversas m\u00e1quinas, e coordenar suas a\u00e7\u00f5es para que sejam consistentes com a especifica\u00e7\u00e3o, de forma a minimizar o tempo que o servi\u00e7o fica fora do ar, entregando o servi\u00e7o de acordo com expectativas especificadas. Modelos cl\u00e1ssicos englobam tr\u00eas vari\u00e1veis: Comunica\u00e7\u00e3o , Sincronismo e Falhas . Com rela\u00e7\u00e3o \u00e0 comunica\u00e7\u00e3o, como j\u00e1 indicado acima, as possibilidades s\u00e3o por acesso a uma mem\u00f3ria compartilhada ou via troca de mensagens, o modelo mais comum. Quanto ao sincronismo, se considera se h\u00e1 limites de tempo para execu\u00e7\u00e3o de opera\u00e7\u00f5es, para troca de mensagens (caso seja este o modelo de comunica\u00e7\u00e3o), e se os hospedeiros do sistema tem acesso a rel\u00f3gios e, finalmente, qu\u00e3o sincronizados estes s\u00e3o. Quanto a falhas, \u00e9 preciso entender como estas (bugs, por exemplo) afetam a execu\u00e7\u00e3o do sistema, se o levam componentes falhos a parar de funcionar totalmente e de forma identific\u00e1vel por outros ou n\u00e3o, se h\u00e1 falhas \"maliciosas\", se os limites de tempo estabelecidos acima podem ser violados, se mensagens podem ser perdidas ou corrompidas. O objetivo \u00e9 entender como evitar que a falha de algum componente possa levar o sistema a parar como um todo e garantir que clientes em qualquer lugar do mundo tenham a mesma facilidade em acessar o servi\u00e7o. N\u00f3s voltaremos a falar sobre modelos computacionais adiante. Por enquanto, vejamos alguns exemplos de tarefas executadas por sistemas distribu\u00eddos, que voc\u00ea usa hoje. Sistema de e-mail Entregue este email para fulano@knowhere.uni . Envie o item X para este endere\u00e7o, ap\u00f3s cobran\u00e7a de Y dinheiros da conta Z. Em um ambiente de simula\u00e7\u00e3o de batalhas em 3D, simule o disparo de um proj\u00e9til nesta dire\u00e7\u00e3o e sentido, com velocidade v, enquanto movimenta o avatar A para a esquerda. Autorize a transfer\u00eancia de X dinheiros da conta C para a conta C'. Movimente o bra\u00e7o mec\u00e2nico que est\u00e1 segurando um bisturi, 3cm \u00e0 direita, ent\u00e3o abaixe-o 3mm, e movimente-o 4cm para a esquerda Inclua o coment\u00e1rio ``LOL!!!'' na lista de coment\u00e1rios do item XYZ, com marca de tempo T Leia o valor do sensor de temperatura S e, caso seu valor supere V, emita alarme luminoso vermelho intermitente e alarme sonoro Fica claro por estes exemplos que h\u00e1 comunica\u00e7\u00e3o entre diversos componentes, por exemplo o console de videogame e um servi\u00e7o que mantem uma \"sala\" aberta para um jogo. Tamb\u00e9m fica claro pelo mesmo exemplo que a lat\u00eancia desta comunica\u00e7\u00e3o deve ser mantida dentro certos patamares, para n\u00e3o inviabilizar a intera\u00e7\u00e3o entre jogares. Al\u00e9m disso, pode-se dizer que algumas aplica\u00e7\u00f5es \u00e3o cr\u00edticas, como no exemplo de tele-cirurgia, enquanto outras s\u00e3o muito menos imoportantes, como acessar sua rede social de fotos. Voltando \u00e0 defini\u00e7\u00e3o, acima, sistemas distribu\u00eddos implicam em algum tipo de colabora\u00e7\u00e3o entre componentes para permitir que recursos de um sejam usados por outro. Colabora\u00e7\u00e3o cria depend\u00eancia e, nos exemplos acima, \u00e9 claro que problemas em alguns compontes pode fazer com que a tarefa que o sistema executa seja inviabilizada, como no caso do sensor do \u00faltimo exemplo, que se parar de funcionar, impede a medi\u00e7\u00e3o da temperatura e o disparo adequado do alarme. Entre os recursos compartilhados por componentes em um sistema distribu\u00eddo est\u00e3o alguns \u00f3bvios, como capacidade de armazenamento e de processamento , mas tamb\u00e9m a localiza\u00e7\u00e3o de um n\u00f3, que pode ser geograficamente mais pr\u00f3xima e de menor lat\u00eancia at\u00e9 um ponto de interesse, ou at\u00e9 mesmo a disponibilidade de uma conex\u00e3o f\u00edsica com um recurso especial, como uma impressora. Assim, podemos concluir que as principais raz\u00f5es para se desenvolver sistemas distribu\u00eddos s\u00e3o alcan\u00e7ar escalabilidade e toler\u00e2ncia a falhas , ambas resultantes da agrega\u00e7\u00e3o (correta) do poder computacional de m\u00faltiplos componentes.","title":"Por qu\u00ea desenvolvemos sistemas distribu\u00eddos?"},{"location":"teaching/gbc074gsi028/intro/#como-desenvolvemos-sistemas-distribuidos","text":"Refor\u00e7ando, distribuir \u00e9 dividir a computa\u00e7\u00e3o/armazenamento em diversos componentes, possivelmente geograficamente distantes , e coordenar suas a\u00e7\u00f5es para que resolvam a tarefa em quest\u00e3o de forma correta. Com a distribui\u00e7\u00e3o objetiva-se usar recursos dispon\u00edveis nos hosts onde os componentes s\u00e3o executados e usar de redund\u00e2ncia para garantir que o servi\u00e7o sofra degrada\u00e7\u00e3o graciosa em caso de falhas, ou seja, fazer com que o servi\u00e7o continue funcionando, mesmo que com vaz\u00e3o reduzida, lat\u00eancia aumentada, menor capacidade de tratamento de requisi\u00e7\u00f5es concorrentes, ou com funcionalidades desabilitadas. Para colaborar, as diversas partes do sistema distribu\u00eddo devem se comunicar. Isto pode ser feito de diversas formas e em diversos n\u00edveis de abstra\u00e7\u00e3o. Por exemplo, no caso troca de mensagens, estas podem ser desde pacotes de bytes entregues pelo IP/UDP como por troca de mensagens ordenadas, fluxos de dados , ou invoca\u00e7\u00e3o remota de procedimentos . Implementar estas abstra\u00e7\u00f5es em si j\u00e1 \u00e9 uma tarefa complicada, pois \u00e9 preciso levar em considera\u00e7\u00e3o que os componentes de um sistema distribu\u00eddo falham independentemente , executam em hosts com rel\u00f3gios dessincronizados , s\u00e3o desenvolvidos usando-se linguagens diversas , sistemas operacionais distintos , com arquiteturas diferentes e por times independentes . Apesar de tantas vari\u00e1veis, as abstra\u00e7\u00f5es precisam permitir que as aplica\u00e7\u00f5es que as usem possam se coordenar nos m\u00ednimos detalhes. Quero dizer, a complexidade de se implementar estas abstra\u00e7\u00f5es j\u00e1 \u00e9 grande por si s\u00f3 e se formos reinventar a roda a cada novo sistema, n\u00e3o faremos muitos avan\u00e7os. Mas, como voc\u00eas bem sabem, camadas de abstra\u00e7\u00e3o s\u00e3o a chave para se lidar com complexidade. Assim, sistemas distribu\u00eddos s\u00e3o como cebolas, cheias de camadas e que nos fazem chorar quando precisamos manipul\u00e1-las. Mas lembrem-se, tamb\u00e9m que e voc\u00ea n\u00e3o quer que seu sistema seja como ogros, temperamentais e mal-cheirosos. Felizmente, para cada problema que tenha que resolver, h\u00e1 uma boa probabilidade de que algu\u00e9m j\u00e1 o tenha atacado e disponibilizado uma solu\u00e7\u00e3o, de forma comercial ou n\u00e3o. Com sistemas distribu\u00eddos, n\u00e3o \u00e9 diferente, e no caso da comunica\u00e7\u00e3o entre componentes distribu\u00eddos, a solu\u00e7\u00e3o normalmente \u00e9 usar um middleware .","title":"Como desenvolvemos Sistemas Distribu\u00eddos?"},{"location":"teaching/gbc074gsi028/intro/#middleware","text":"De acordo com Tanenbaum & Van Steen , middleware \u00e9 ... the software layer that lies between the operating system and applications on each side of a distributed computing system in a network. Isto \u00e9, o middleware \u00e9 a camada ware que fica no middle , entre, o software e o hardware . Software, no caso, \u00e9 a aplica\u00e7\u00e3o distribu\u00edda sendo desenvolvida e hardware \u00e9 a abstra\u00e7\u00e3o do host em que se executam os componentes, provida pelo sistema operacional. Uso aqui o termo abstra\u00e7\u00e3o porqu\u00ea o sistema operacional pode encapsular hardware real, mas tamb\u00e9m pode encapsular outra abstra\u00e7\u00e3o de hardware , por exemplo, uma m\u00e1quina virtual ou cont\u00eainer. A figura seguinte 2 mostra um exemplo com tr\u00eas aplica\u00e7\u00f5es executando sobre um middleware , que por sua vez \u00e9 executado sobre diferentes sistemas operacionais, em hosts conectados por uma rede de comunica\u00e7\u00e3o. Com este cen\u00e1rio em mente, \u00e9 importante entender o que diz Sacha Krakowiak quando afirma que as principais fun\u00e7\u00f5es do middleware s\u00e3o: esconder a distribui\u00e7\u00e3o e o fato de que um aplica\u00e7\u00e3o \u00e9 geralmente composta por m\u00faltiplas partes, executando em localiza\u00e7\u00f5es geograficamente distintas, esconder a heterogeneidade dos v\u00e1rios componentes de hardware, sistemas operacionais e protocolos de comunica\u00e7\u00e3o prover interfaces uniformes, de alto n\u00edvel e padronizadas para os desenvolvedores de aplica\u00e7\u00e3o e integradores, de forma que aplica\u00e7\u00f5es possam ser facilmente compostas, reusadas, portadas e feitas interoper\u00e1veis. Assim, os middleware facilitam a conex\u00e3o entre componentes e permitem o uso de protocolos mais abstratos que as opera\u00e7\u00f5es de write(byte[]) e read(): byte[] dos protocolos de baixo n\u00edvel, escondendo a complexidade da coordena\u00e7\u00e3o de sistemas independentes. Desenvolver sistemas distribu\u00eddos sem usar um middleware \u00e9 como desenvolver um aplicativo sem usar quaisquer bibliotecas: poss\u00edvel, mas complicado, e estar\u00e1 certamente reinventando a roda. Isto \u00e9, voc\u00ea praticamente tem que refazer o middleware antes de desenvolver o sistema em si. Idealmente, com o middleware o desenvolvedor conseguiria facilmente implementar uma aplica\u00e7\u00e3o em a distribui\u00e7\u00e3o fosse totalmente transparente, levando o sistema, uma cole\u00e7\u00e3o de sistemas computacionais (software ou hardware) independentes, a se apresentar para o usu\u00e1rio como um sistema \u00fanico , monol\u00edtico. Pense no browser e na WWW, por exemplo; o quanto voc\u00ea sabe sobre as p\u00e1ginas estarem particionadas em milh\u00f5es de servidores? Isso \u00e9 o que chamamos de transpar\u00eancia.","title":"Middleware"},{"location":"teaching/gbc074gsi028/intro/#transparencia","text":"Se n\u00e3o h\u00e1 qualquer ind\u00edcio de que a aplica\u00e7\u00e3o \u00e9 distribu\u00edda, ent\u00e3o temos transpar\u00eancia total . Podemos quebrar esta transpar\u00eancia total em v\u00e1rias transpar\u00eancias mais simples: Acesso , Localiza\u00e7\u00e3o , Reloca\u00e7\u00e3o , Migra\u00e7\u00e3o , Replica\u00e7\u00e3o , e Falha . Vejamos cada uma destas separadamente.","title":"Transpar\u00eancia"},{"location":"teaching/gbc074gsi028/intro/#escalabilidade","text":"Para terminar, deixem-me apenas retomar um termo usado acima, escalabilidade . O termo est\u00e1 muito em voga e \u00e9 usado, normalmente, para descrever a capacidade de um sistema de se adequar a varia\u00e7\u00f5es de carga de trabalho. Embora seja um uso v\u00e1lido, h\u00e1 outros tipos de escalabilidade. Escalabilidade Tamanho: N\u00famero de usu\u00e1rios que suporta. Geogr\u00e1fica: Regi\u00e3o que cobre. Administrativa: N\u00famero de dom\u00ednios administrativos. H\u00e1 v\u00e1rias possibilidades: seja espec\u00edfico e exija especificidade.","title":"Escalabilidade"},{"location":"teaching/gbc074gsi028/intro/#tipos","text":"H\u00e1 quem diga que j\u00e1 somos todos desenvolvedores de sistemas distribu\u00eddos . Ainda assim, \u00e9 importante entender que h\u00e1 v\u00e1rios tipos de sistemas distribu\u00eddos, com diversas finalidades e diversas as arquiteturas, pois classifica\u00e7\u00f5es nos ajudam a pensar sobre sistemas e a encontrar e reusar solu\u00e7\u00f5es previamente testadas.","title":"Tipos"},{"location":"teaching/gbc074gsi028/intro/#computacao-de-alto-desempelho","text":"A possibilidade de agregar poder de processamento de muitos computadores em um rede de comunica\u00e7\u00e3o com alt\u00edssima largura de banda nos permite atacar problemas computacionalmente muito intensos Clusters como o da imagem a seguir, do High Performance Computing Center de Stuttgart, s\u00e3o compartilhados por pesquisadores resolvendo problemas \u00e1reas como bio-inform\u00e1tica, engenharia, economia, intelig\u00eancia artificial, etc. Na engenharia, por exemplo, HPC pode ser usada para testar a efici\u00eancia de projetos sem construir prot\u00f3tipos, seja de uma turbina um carro ou uma vaca Os n\u00f3s de um cluster s\u00e3o normalmente divididos em tr\u00eas categorias: administra\u00e7ao, computa\u00e7\u00e3o e armazenamento. N\u00f3s de administra\u00e7\u00e3o implementam um monitoramento distribu\u00eddo dos demais n\u00f3s, servem de ponto de entrada para usu\u00e1rios e prov\u00eaem interface para submiss\u00e3o de tarefas. O Oscar , por exemplo, \u00e9 uma \u00e9 conjunto de softwares para gerenciamento de clusters. Uma das ferramentas inclusas no Oscar \u00e9 o OpenPBS, pelo qual tarefas s\u00e3o atribu\u00eddas aos diversos n\u00f3s do sistema que sejam alocados para tal tarefa. O OpenPBS portanto \u00e9 tamb\u00e9m um sistema distribu\u00eddo. Finalmente, as tarefas submetidas em si s\u00e3o normalmente aplica\u00e7\u00f5es distribu\u00eddas. Cada processo executando em uma m\u00e1quina distrinta \u00e9 normalmente respons\u00e1vel por resolver uma parte do problema. Para facilitar a comunica\u00e7\u00e3o entre as partes do dom\u00ednio, s\u00e3o normalmente utilizadas API como a Message Passing Interface (MPI), que prov\u00ea fun\u00e7\u00f5es para distribui\u00e7\u00e3o e agrega\u00e7\u00e3o de dados entre os v\u00e1rios processos. Este tipo de sistemas distribu\u00eddos s\u00e3o o que chamamos de fortemente acoplados pois a falha em um dos componentes leva normalmente \u00e0 falha de todo o sistema. Do ponto de vista deste curso, estamos mais interessados em sistemas fracamente acoplados.","title":"Computa\u00e7\u00e3o de Alto Desempelho"},{"location":"teaching/gbc074gsi028/intro/#sistemas-de-informacao","text":"Provavelmente mais comuns entre os profissionais da computa\u00e7\u00e3o, os sistemas de informa\u00e7\u00e3o distribu\u00eddos s\u00e3o encontrados em diversas formas. De fato, o termo \"sistema de informa\u00e7\u00e3o\" \u00e9 t\u00e3o abrangente, que dificilmente um sistema distribu\u00eddo n\u00e3o estaria nesta classe. O seguinte \u00e9 um exemplo de uma arquitetura em tr\u00eas camadas, onde a primeira implementa a interface com o usu\u00e1rio, a segunda cont\u00e9m a l\u00f3gica do neg\u00f3cio, e a terceira mantem os dados. Pe\u00e7a fundamental desta abordagem, os bancos de dados na terceira camada s\u00e3o frequentemente transacionais. Isto \u00e9, eles prov\u00eaem as garantias na execu\u00e7\u00e3o de transa\u00e7\u00f5es conhecidas como propriedades ACID. ACID Atomicidade: transa\u00e7\u00f5es s\u00e3o tratadas de forma indivis\u00edvel, isto \u00e9, ou tudo ou nada. Consist\u00eancia: transa\u00e7\u00f5es levam banco de um estado consistente a outro. E.g., x == 2*y Isolamento: transa\u00e7\u00f5es n\u00e3o v\u00eaem dados n\u00e3o comitados umas das outras. Durabilidade: os efeitos de uma transa\u00e7\u00e3o comitada devem persistir no sistema a despeito de falhas. Para relembrar no que implica ACID, considere a seguinte sequ\u00eancia de opera\u00e7\u00f5es, onde X e Y s\u00e3o valores guardados pelo banco de dados, a, b e c s\u00e3o vari\u00e1veis definidas no programa, e SELECT e SET s\u00e3o comandos para ler e modificar o banco de dados. 1 2 3 4 5 1: a = SELECT X 2: c = a * 2 3: b = c + 10 4: SET X=c 5: SET Y=b Suponha duas inst\u00e2ncias desta sequ\u00eancia, T_1 T_1 e T_2 T_2 , concorrentes, em que as opera\u00e7\u00f5es escalonadas da seguinte forma. 1 2 3 4 5 6 7 8 9 10 11 T1 T2 1: a = SELECT X 2: c = a * 2 3: b = c + 10 4: SET X=c 5: a = SELECT X 6: c = a * 2 7: b = c + 10 8: SET X=c 9: SET Y=b 10:SET Y=b Ao final da execu\u00e7\u00e3o, X ter\u00e1 o valor atribu\u00eddo por T_2 T_2 , mas Y Y ter\u00e1 o valor de T_1 T_1 . Este escalonamento violou a consist\u00eancia do banco de dados por qu\u00ea as opera\u00e7\u00f5es n\u00e3o foram executadas isoladamente . Tente imaginar a dificuldade de se implementar um banco de dados distribu\u00eddo. Isto \u00e9, um banco em que v\u00e1rios n\u00f3s mantem os dados, participam de transa\u00e7\u00f5es e, portanto, precisam coordenar-se para manter os dados consistentes. A figura a seguir mostra um cen\u00e1rio com tr\u00eas bancos. Imagine que em um deles est\u00e1 uma rela\u00e7\u00e3o com os dados dos clientes, em outro, os dados do estoque e no terceiro as ordens de compra. Quando um cliente faz um pedido, o cliente deve ser validado no primeiro n\u00f3, o item \u00e9 removido do estoque no segundo n\u00f3, e no terceiro \u00e9 disparada uma cobran\u00e7a para o cliente. Se qualquer destas tr\u00eas rela\u00e7\u00f5es n\u00e3o for corretamente consultada e alterada, os efeitos podem ser catastr\u00f3ficos para o neg\u00f3cio ou para o cliente. Como implementar ACID neste banco de dados? Embora veremos isso um pouco mais para frente neste material, por enquanto, apenas assuma que n\u00e3o \u00e9 exatamente f\u00e1cil ou barato. Esta dificuldade foi a raz\u00e3o do surgimento dos bancos de dados NOSQL (n\u00e9e NoSQL), dos quais uma pequena amostra \u00e9 dada pela seguinte figura. Tambem discutiremos como estes bancos de dados funcionam, quando falarmos sobre sistemas P2P.","title":"Sistemas de Informa\u00e7\u00e3o"},{"location":"teaching/gbc074gsi028/intro/#integracao-de-aplicacoes","text":"Frequentemente \u00e9 necess\u00e1rio integrar sistemas de informa\u00e7\u00e3o legados com sistemas mais modernos, ou simplesmente exp\u00f4-los usando uma interface mais moderna. Nestes casos, \u00e9 poss\u00edvel integrar diversos sistemas usando um middleware que os encapsule. O middleware pode, por exemplo, se expor via interface REST para os clientes, mas consultar o sistema legado em um padr\u00e3o antigo. Outro exemplo \u00e9 o sistema na imagem seguinte, que mostra diversos departamentos de uma empresa conversando via troca de mensagens. Observe que nenhum departamento precisa conversar diretamente com os outros, ou mesmo conhec\u00ea-los. Eles apenas publicam a mensagem para quem puder tratar. Da mesma forma, a resposta vem na forma de uma mensagem. Este \u00e9 um exemplo de sistema fracamente acoplado , pois nenhum componente tem que saber da exist\u00eancia do outro ou se torna indispon\u00edvel caso os outros falhem. Siga este link para ler mais sobre este tipo de sistema.","title":"Integra\u00e7\u00e3o de Aplica\u00e7\u00f5es"},{"location":"teaching/gbc074gsi028/intro/#sistemas-pervasivosubiquos","text":"Segundo Weiser, 1993 Ubiquitous computing is the method of enhancing computer use by making many computers available throughout the physical environment, but making them effectively invisible to the user. O que \u00e9 importante aqui \u00e9 o foco na tarefa em vez de na ferramenta. Assim, sistemas pervasivos devem ajudar as pessoas a realizar suas tarefas, de forma impl\u00edcita, sem ter que pensar em como a tarefa ser\u00e1 executada. Para que seja realizada, a computa\u00e7\u00e3o pervasiva requer que dispositivos detectem o contexto em que est\u00e3o inseridos, combinem-se de forma ad-hoc e compartilhem informa\u00e7\u00f5es. Exemplos fict\u00edcios e reais Smart Life Esta \u00e9 uma vis\u00e3o futur\u00edstica da Microsoft para a integra\u00e7\u00e3o de tecnologias. Amazon Go Este mercado automatiza o pagamento dos itens escolhidos pelo consumidor, utilizando t\u00e9cnicas de processamento digital de imagens, aprendizado de m\u00e1quina e sensores. Reality Check Para quem viu o filme Minority Report e sonhou com as UI do futuro, aqui vai um reality check . Para quem n\u00e3o viu ainda, corrija esta falha em sua forma\u00e7\u00e3o t\u00e9cnica o mais rapidamente poss\u00edvel.","title":"Sistemas Pervasivos/Ub\u00edquos"},{"location":"teaching/gbc074gsi028/intro/#computacao-utilitaria","text":"Um tipo importante de sistema distribu\u00eddo mais recente s\u00e3o as nuvens computacionais, usadas no provimento de computa\u00e7\u00e3o utilit\u00e1ria. Este tipo de sistema, embora possa ser pensando como infraestrutura para outros sistemas distribu\u00eddos, s\u00e3o, na verdade, complexas pe\u00e7as de engenharia, com diversos subsistemas respons\u00e1veis por sincroniza\u00e7\u00e3o de rel\u00f3gios, monitora\u00e7\u00e3o de falhas, coleta de logs, roteamento eficiente tolerante a falhas, movimenta\u00e7\u00e3o de recursos virtualizados para consolida\u00e7\u00e3o de recursos f\u00edsicos, armazenamento redundante de dados, etc. O seguinte v\u00eddeo mostra, em 360 graus, um dos datacenters do Google, para que voc\u00ea tenha ideia da escala em que estes sistemas s\u00e3o constru\u00eddos. Para uma viagem fotogr\u00e1fica, siga este link","title":"Computa\u00e7\u00e3o Utilit\u00e1ria"},{"location":"teaching/gbc074gsi028/intro/#arquiteturas","text":"De acordo com David Garlan and Mary Shaw, January 1994, CMU-CS-94-166, em An Introduction to Software Architecture ... an architectural style determines the vocabulary of components and connectors that can be used in instances of that style, together with a set of constraints on how they can be combined. These can include topological constraints on architectural descriptions (e.g., no cycles). Other constraints\u2014say, having to do with execution semantics\u2014might also be part of the style definition. Em outras palavras, um estilo ou padr\u00e3o arquitetural \u00e9 o conjunto de princ\u00edpios que prov\u00ea uma infraestrutura abstrata para uma fam\u00edlia de sistemas, e promove o reuso de projeto ao prover solu\u00e7\u00f5es para problemas recorrentes e frequentes .","title":"Arquiteturas"},{"location":"teaching/gbc074gsi028/intro/#componentes-e-conectores","text":"Quando falamos sobre arquiteturas em sistemas distribu\u00eddos, estamos primariamente focados na forma como componentes se conectam, por meio de conectores, para implementar a solu\u00e7\u00e3o para um problema. graph LR (Componente 1) --> [Conector] --> (Componente 2) Dependendo de como s\u00e3o conectados, haver\u00e1 maior ou menor depend\u00eancia entre os componentes. Quando houver forte depend\u00eancia, diremos que os componentes est\u00e3o fortemente acoplados ( tightly coupled ). Caso contr\u00e1rio, diremos que est\u00e3o fracamente acoplados ( loosely coupled ). A raz\u00e3o \u00f3bvia para preferir sistemas fracamente conectados \u00e9 sua capacidade de tolerar disrup\u00e7\u00f5es; se um componente depende pouco de outro, ent\u00e3o n\u00e3o se incomodar\u00e1 com sua aus\u00eancia por causa de uma falha. Certos middleware permitem um acoplamento t\u00e3o fraco entre componentes, que estes n\u00e3o precisam se conhecer ou sequer estar ativos no mesmo momento. Tamb\u00e9m a quest\u00e3o da simplifica\u00e7\u00e3o de API, uma vez que o middleware pode impor um padr\u00e3o a ser seguido por todos os componentes e minimizar a necessidade os componentes conhecerem as interfaces uns dos outros.","title":"Componentes e Conectores"},{"location":"teaching/gbc074gsi028/intro/#clienteservidor","text":"A forma como os componentes se comunicam, isto \u00e9, os conectores usados, \u00e9 importante no estudo arquitetural. Mas tamb\u00e9m s\u00e3o importantes os pap\u00e9is assumidos pelos componentes na realiza\u00e7\u00e3o de tarefas. Neste sentido, provavelmente a arquitetura de computa\u00e7\u00e3o distribu\u00edda mais famosa \u00e9 a Cliente/Servidor . Na arquitetura Cliente/Servidor, como implicado pelo nome, h\u00e1 um processo que serve a pedidos realizados por outros processos. Isto \u00e9 feito quando o cliente o contacta o servidor e requer ( request ) a realiza\u00e7\u00e3o do servi\u00e7o. O servidor , por sua vez, pode desempenhar tarefas como fazer c\u00e1lculos, armazenar dados, ou repassar uma mensagem e, ao final da realiza\u00e7\u00e3o da tarefa, responder ( response ) ao cliente. Um mesmo servidor pode atender a diversos clientes e, geralmente, a comunica\u00e7\u00e3o entre os mesmos \u00e9 feita diretamente por sockets. Embora seja poss\u00edvel usar sockets de forma ass\u00edncrona, a API mais comum \u00e9 s\u00edncrona, isto \u00e9, quando um processo espera receber uma mensagem de outro, ele fica bloqueado esperando algum dado estar dispon\u00edvel para leitura no referido socket. Assim, geralmente a comunica\u00e7\u00e3o entre cliente e servidor segue o seguinte esquema: Observe que o cliente fica inativo enquanto espera a resposta e que o servidor fica inativo enquanto espera outras requisi\u00e7\u00f5es. Para minimizar os per\u00edodos de inatividade, o cliente pode usar o socket ass\u00edncronamente, o que n\u00e3o \u00e9 exatamente simples, ou usar m\u00faltiplos threads, para que continue operando mesmo enquanto um thread estiver bloqueado esperando a resposta do servidor. No lado do servidor, o minimiza\u00e7\u00e3o da ociosidade \u00e9 feita pelo uso de m\u00faltiplos clientes, concorrentes, e tamb\u00e9m pelo uso de m\u00faltiplos threads. Neste caso, contudo, \u00e9 necess\u00e1rio tomar muito cuidado para garantir que a concorr\u00eancia n\u00e3o causar\u00e1 efeitos indesejados nos dados e execu\u00e7\u00e3o das tarefas. Veja o caso de um banco de dados transacional, por exemplo, como discutido acima; ele precisa garantir ACID entre as transa\u00e7\u00f5es propostas pelos clientes. Embora tenhamos colocado aqui apenas um servidor atendendo aos clientes, em muitas aplica\u00e7\u00f5es modernas, m\u00faltiplos servidores atender\u00e3o ao conjunto de clientes. Pense por exemplo no servi\u00e7o de email do Google, o Gmail. Com os milh\u00f5es de usu\u00e1rios que tem, certamente h\u00e1 mais de um servidor implementando o servi\u00e7o. Provavelmente estes diversos servidores ficam atr\u00e1s do que chamamos de um balanceador de carga, que roteia as requisi\u00e7\u00f5es seguindo diferentes pol\u00edticas, por exemplo, round robin .","title":"Cliente/Servidor"},{"location":"teaching/gbc074gsi028/intro/#par-a-par-p2p","text":"Diferentemente de sistemas cliente/servidor, em que um n\u00f3 serve o outro, em sistemas par-a-par, os n\u00f3s s\u00e3o parceiros e tem igual responsabilidade (e da\u00ed o nome) na execu\u00e7\u00e3o das tarefas. Diversos sistemas P2P existem, sendo, provavelmente, os mais famosos, os sistemas de compartilhamento de arquivos. Nesta linha, embora diversos tenham existido, hoje o mais famoso \u00e9 o Bittorrent, mesmo que, como veremos adiante, n\u00e3o seja P2P puro. Outro exemplo importante por ter inspirado diversos outros sistemas \u00e9 o Chord. Neste sistema, n\u00f3s organizam-se em um anel l\u00f3gico e cada um se torna respons\u00e1vel por um dos segmentos do anel adjacente a onde se encontra no mesmo. Requisi\u00e7\u00f5es para correspondentes a um segmento s\u00e3o roteados para o n\u00f3 respons\u00e1vel usando uma tabela de rotas conhecida como finger table . Se tra\u00e7armos os caminhos apontados por esta tabela sobre o anel, desenharemos cordas sobre o mesmo, o que explica o nome do sistema.","title":"Par-a-Par (P2P)"},{"location":"teaching/gbc074gsi028/intro/#hibridos","text":"Embora cliente/servidor e P2P sejam arquiteturas cl\u00e1ssicas, boa parte dos sistemas que distribu\u00eddos podem ser na verdade consideradas h\u00edbridos. Considere um sistema de email, por exemplo. Embora clientes usem as funcionalidades dos servidores de email para enviar e receber mensagens, os servidores conversam uns com os outros para implementar a tarefa de encaminhar as mensagens. Neste sentido, o sistema \u00e9 um h\u00edbrido P2P e cliente/servidor. Outros exemplos abundam. Bancos de dados, e.g., DynamoDB, CassandraDB , Redis,... Jogos multiplayer (pense no particionamento dos mapas ) Compartilhamento de arquivos: Bittorrent Voltemos ao exemplo do Bittorrent; observe na figura adiante os diversos passos necess\u00e1rios \u00e0 recupera\u00e7\u00e3o do arquivo de interesse neste sistema. Diversos passos seguem a arquitetura cliente/servidor enquanto \"somente\" o passo de compartilhamento de arquivos \u00e9 P2P. Voltando ao exemplo do sistema de informa\u00e7\u00e3o, observe que o cliente acessa um servi\u00e7o, implementado por pares de n\u00f3s. Podemos dizer que tamb\u00e9m este \u00e9 h\u00edbrido.","title":"H\u00edbridos"},{"location":"teaching/gbc074gsi028/intro/#sistemas-multi-camadas","text":"Outra forma de hibridismo que podemos citar \u00e9 quando um componente haje tanto como cliente quanto como servidor. Veja o seguinte exemplo, conhecido no meio como arquitetura em 3-camadas (3 tiers ). Neste caso, \u00e9 interessante notar que esta disposi\u00e7\u00e3o dos componentes \u00e9 independente da disposi\u00e7\u00e3o f\u00edsica. De fato, as tr\u00eas camadas podem estar em um mesmo n\u00f3, ou combinadas duas a duas, neste \u00faltimo caso resultando em duas camadas. Por outro lado, cada camada pode ser subdividida em mais componentes, resultando \u00e9 m\u00faltiplos tiers, como neste exemplo de um sistema de busca na Web.","title":"Sistemas multi-camadas"},{"location":"teaching/gbc074gsi028/intro/#outras-arquiteturas","text":"Diversas outras arquiteturas podem e foram propostas para o desenvolvimento de Sistemas Distribu\u00eddos. A moda da vez \u00e9 a chamada arquitetura de micro servi\u00e7os, na qual a divis\u00e3o de tarefas entre componentes visa levar aos componentes mais simples para tal tarefa. Assim, os mesmos podem ser replicados, escalonados, desenvolvidos e mantidos independentemnte. Cada tarefa conta ent\u00e3o com diversos componentes, organizados em camadas resolvendo um problema em espec\u00edfico, mas todos contribuindo para a realiza\u00e7\u00e3o de uma tarefa maior comum. N\u00f3s discutiremos micro-servi\u00e7os mais adiante. Por agora, apenas tenha em mente que embora seja vendido por muitos como tal, os micro-servi\u00e7os n\u00e3o s\u00e3o uma panac\u00e9ia . Todo Event sourcing Todo MOM Todo Pub/Sub","title":"Outras arquiteturas"},{"location":"teaching/gbc074gsi028/intro/#para-aprender-mais","text":"Para aprender mais sobre arquiteturas, consulte a seguinte refer\u00eancia: Distributed System Architectures and Architectural Styles . Para aprender um pouco sobre como funcionam as redes de um datacenter, definidas por software, assista ao seguinte v\u00eddeo, que fala sobre a infra-estrutura do Facebook. Muitos se referem a sistemas n\u00e3o-distribu\u00eddos como centralizados mas preferimos reservar este termo para sistemas distribu\u00eddos que usam um processo centralizador. O termo monol\u00edtico tamb\u00e9m \u00e9 muito usado em contraposi\u00e7\u00e3o \u00e0 arquitetura de micro-servi\u00e7os, mas sentimos que este uso \u00e9 em acordo como o oposto a distribu\u00eddo. \u21a9 Cap\u00edtulo 1, Figura 1, Distributed Systems: Principles and Paradigms \u21a9 IEEE Floating Point \u21a9 IBM Floating Point \u21a9 Simplifica\u00e7\u00f5es s\u00e3o poss\u00edveis, mas introduzem outras complexidades. \u21a9 O Google stadia \u00e9 uma plataforma de jogos que vai na contram\u00e3o desta ideia, levando todo o processamento pesado para a nuvem. \u21a9","title":"Para aprender mais"},{"location":"teaching/gbc074gsi028/projeto/projeto/","text":"TODO Propor projeto de sistema NoSQL. * Etapa 1 - Cliente/Servidor * Objetivos * Hash Table acess\u00edvel remotamente por interface CRUD sobre HTML. * Armazenamento em disco com recupera\u00e7\u00e3o de dados no caso de falhas * Desafios * Especifica\u00e7\u00e3o do protocolo para dados gen\u00e9ricos * Armazenamento at\u00f4mico no disco * Multithreading para garantir escalabilidade * Controle de concorr\u00eancia * Est\u00e1gios * Etapa 2 - P2P * Objetivos * DHT com roteamento estilo Chord * Armazenamento em Log de opera\u00e7\u00f5es e em arquivo de snapshots * Comunica\u00e7\u00e3o usando RPC * Desafios * Uso adequado da interface funcional do RPC * Uso do log + snapshots para recupera\u00e7\u00e3o * Roteamento no anel * Bootstrap dos processos * Log Structured Merge Tree * Etapa 3 - Toler\u00e2ncia a Falhas * Objetivos * Cada servidor \u00e9 uma m\u00e1quina de estados replicada * Desafios * Usar adequadamente Difus\u00e3o At\u00f4mica * Entender Commit Distribu\u00eddo","title":"TODO"},{"location":"teaching/gbc074gsi028/projeto/projeto/#todo","text":"Propor projeto de sistema NoSQL. * Etapa 1 - Cliente/Servidor * Objetivos * Hash Table acess\u00edvel remotamente por interface CRUD sobre HTML. * Armazenamento em disco com recupera\u00e7\u00e3o de dados no caso de falhas * Desafios * Especifica\u00e7\u00e3o do protocolo para dados gen\u00e9ricos * Armazenamento at\u00f4mico no disco * Multithreading para garantir escalabilidade * Controle de concorr\u00eancia * Est\u00e1gios * Etapa 2 - P2P * Objetivos * DHT com roteamento estilo Chord * Armazenamento em Log de opera\u00e7\u00f5es e em arquivo de snapshots * Comunica\u00e7\u00e3o usando RPC * Desafios * Uso adequado da interface funcional do RPC * Uso do log + snapshots para recupera\u00e7\u00e3o * Roteamento no anel * Bootstrap dos processos * Log Structured Merge Tree * Etapa 3 - Toler\u00e2ncia a Falhas * Objetivos * Cada servidor \u00e9 uma m\u00e1quina de estados replicada * Desafios * Usar adequadamente Difus\u00e3o At\u00f4mica * Entender Commit Distribu\u00eddo","title":"TODO"},{"location":"teaching/gbc074gsi028/tech/","text":"Tecnologias Como sincronizar duas m\u00e1quinas? Produza um hash dos arquivos Troque hashes Se hashes iguais, pronto. Se hashes diferentes, volte para o slide anterior. Merkle Trees Divida o arquivo em blocos de mesmo tamanho Fa\u00e7a um hash de cada bloco Se mais de um hash gerado, Concatene os hashes em um arquivo Volte para o primeiro item Troque hashes da raiz. Se hashes iguais, pronto. Se hashes diferentes \\pause compare sub\u00e1rvore. Se a \u00fanica mudan\u00e7a no arquivo foi a adi\u00e7\u00e3o de um byte no come\u00e7o do arquivo? Refer\u00eancias Modern Algorithms and Data Structures: Merkle Trees Rabin Fingerprint Rolling Hash Blockchain \\subsection{Introdu\u00e7\u00e3o} \\begin{frame}{Mercado} \\begin{itemize} \\item Clientes, consumidores, fornecedores, vendedores \\item Bens, servi\u00e7os, contratos \\item Mercado p\u00fablico (feira livre, supermercados) e Privado (supply chain) \\end{itemize} \\end{frame} \\begin{frame}{Asset -- Bem} Tudo que tem valor e pode pertencer a algu\u00e9m. \\begin{itemize} \\item Casa, empr\u00e9stimo (tang\u00edvel e intang\u00edvel) \\item Patente \\item A\u00e7\u00e3o \\item Dinheiro -- \u00e9 an\u00f4nimo \\end{itemize} \\end{frame} \\begin{frame}{Asset -- Bem} Tudo que tem valor e pode pertencer a algu\u00e9m. \\begin{itemize} \\item Casa, empr\u00e9stimo (tang\u00edvel e intang\u00edvel) \\item Patente \\item A\u00e7\u00e3o \\item Dinheiro -- \u00e9 an\u00f4nimo \\end{itemize} \\end{frame} \\begin{frame}{Ledger} Livro registro 1 2 3 4 5 6 7 8 \\begin{itemize} \\item 1000 reais pagos ao funcion\u00e1rio F \\item Carro X vendido ao Jo\u00e3o por 50k \\item Cada entidade mant\u00e9m o seu, privadamente. \\item Ineficiente -- retrabalho e lento \\item Caro -- Retrabalho \\item Vulner\u00e1vel -- hack, erros, e modifica\u00e7\u00f5es maliciosas \\end{itemize} \\end{frame} \\begin{frame}{Blockchain} Ledger distribu\u00eddo e centralizado \\begin{itemize} \\item Replicado usando P2P \\item S\u00f3 envolvidos tem acesso ao registro \\item Consenso -- acordo na transa\u00e7\u00e3o \\item Proveni\u00eancia -- todo o hist\u00f3rico de um asset \u00e9 mantido na blockchain. \\item Imutabilidade -- entradas n\u00e3o podem ser alteradas \\item Finalidade -- entradas n\u00e3o podem ser refutadas \\end{itemize} \\end{frame} \\begin{frame}{Blockchain} Ledger distribu\u00eddo e centralizado \\begin{itemize} \\item Replicado usando P2P \\item S\u00f3 envolvidos tem acesso ao registro \\item Consenso -- acordo na transa\u00e7\u00e3o \\item Proveni\u00eancia -- todo o hist\u00f3rico de um asset \u00e9 mantido na blockchain. \\item Imutabilidade -- entradas n\u00e3o podem ser alteradas \\item Finalidade -- entradas n\u00e3o podem ser refutadas \\end{itemize} \\end{frame} \\begin{frame}{Bitcoin} Primeira aplica\u00e7\u00e3o da blockchain \\begin{itemize} \\item Bitcoin \\begin{itemize} \\item Moeda \u00e9 o asset \\item Anonimidade \\item Proof of work \\end{itemize} \\item Neg\u00f3cios \\begin{itemize} \\item Qualquer coisa \u00e9 asset \\item Identifica\u00e7\u00e3o das partes \\item Selective endorsement \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Bitcoin} Primeira aplica\u00e7\u00e3o da blockchain \\begin{itemize} \\item Bitcoin \\begin{itemize} \\item Moeda \u00e9 o asset \\item Anonimidade \\item Proof of work \\end{itemize} \\item Neg\u00f3cios \\begin{itemize} \\item Qualquer coisa \u00e9 asset \\item Identifica\u00e7\u00e3o das partes \\item Selective endorsement \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Smart Contracts} Os termos do neg\u00f3cio s\u00e3o mantidos na blockchain: \"Se na data X a entidade E n\u00e3o tiver transferido D dinheiros para a entidade F, ent\u00e3o transfira o asset A de E para F.\" 1 Verific\u00e1vel, assin\u00e1vel e \\emph{execut\u00e1vel}. \\end{frame} \\frame{} \\begin{frame}{Bitcoin} \\includegraphics[width=\\textwidth]{images/bitcoin_jun_2018} \\end{frame} \\begin{frame}{Bitcoin} \\includegraphics[width=\\textwidth]{images/bitcoin_jun_2018} \\end{frame} \\begin{frame}{Bitcoin} \\includegraphics[width=\\textwidth]{images/bitcoin_dec_2018} \\end{frame} \\section{A Small Piece of Big Data} \\subsection{Introdu\u00e7\u00e3o} \\frame{ \\begin{block}{Big-Data} ``Big data is a term for data sets that are so large or complex that traditional data processing application software is inadequate to deal with them.'' \\end{block} Ciclo convencional: \\begin{itemize} \\item Coleta \\item Armazenamento \\item An\u00e1lise \\item Consulta \\item Compartilhamento \\item Visualiza\u00e7\u00e3o \\item Atualiza\u00e7\u00e3o \\item ... \\end{itemize} \\href{ https://en.wikipedia.org/wiki/Big_data}{Fonte } } \\begin{frame}{\u00c1reas} Grandes massas de dados: \\begin{itemize} \\item Propaganda \\item Astronomia \\item Ci\u00eancia \\item e-governos \\item meteorologia \\item \\emph{genomics} \\item ... \\end{itemize} \\end{frame} \\begin{frame}{\u00c1reas} Grandes massas de dados: \\begin{itemize} \\item Propaganda \\item Astronomia \\item Ci\u00eancia \\item e-governos \\item meteorologia \\item \\emph{genomics} \\item ... \\end{itemize} \\end{frame} \\begin{frame}{Dados} \\begin{itemize} \\item Internet das coisas \\item sensoriamento remoto \\item suas fotos \\item logs de software \\item RFID \\item redes de sensores \\item ... \\end{itemize} \\end{frame} \\begin{frame}{Dados} \\begin{itemize} \\item Internet das coisas \\item sensoriamento remoto \\item suas fotos \\item logs de software \\item RFID \\item redes de sensores \\item ... \\end{itemize} \\end{frame} \\begin{frame}{O qu\u00ea?} Qu\u00e3o grande \u00e9 ``big'' o suficiente? \\pause Depende dos dados, ferramentas, e capacidade de manipul\u00e1-los. \\pause Uma vez dado um passo, o alvo passa a ser o pr\u00f3ximo passo. \\pause Isso quer dizer que vai de alguns TB at\u00e9 Petabytes, dependendo do problema. \\end{frame} \\begin{frame}{O qu\u00ea?} Qu\u00e3o grande \u00e9 ``big'' o suficiente? \\pause Depende dos dados, ferramentas, e capacidade de manipul\u00e1-los. \\pause Uma vez dado um passo, o alvo passa a ser o pr\u00f3ximo passo. \\pause Isso quer dizer que vai de alguns TB at\u00e9 Petabytes, dependendo do problema. \\end{frame} \\begin{frame}{O qu\u00ea?} \\begin{block}{Gartner, 2012} Big data is high volume, high velocity, and/or high variety information assets that require new forms of processing to enable enhanced decision making, insight discovery and process optimization. \\end{block} \\begin{itemize} \\item Volume: incapacidade de armazenar todos os dados; apenas observe e guarde conclus\u00f5es \\item Velocidade: dados passando em ``tempo real'' \\item Variedade: imagens, v\u00eddeos, \u00e1udio, temperatura,... \\pause \\item Machine learning para automa\u00e7\u00e3o de extra\u00e7\u00e3o de informa\u00e7\u00e3o, por exemplo, detec\u00e7\u00e3o de padr\u00f5es, sem se preocupar com o porqu\u00ea dos mesmos. \\end{itemize} \\end{frame} \\begin{frame}{Como lidar?} \\begin{itemize} \\item Bancos de dados colunares \\item Stream DBs \\item ... \\item \\alert{MapReduce} \\end{itemize} \\end{frame} \\begin{frame}{Como lidar?} \\begin{itemize} \\item Bancos de dados colunares \\item Stream DBs \\item ... \\item \\alert{MapReduce} \\end{itemize} \\end{frame} \\subsection{Google FS} \\begin{frame}{Google FS} \\begin{itemize} \\item Google, 2003 \\item File System \\item Dados recuperados da Internet usados em consultas \\item Milh\u00f5es de arquivos de m\u00faltiplos GB \\item Chunks de 64MB (``blocos do disco'') \\item Opera\u00e7\u00f5es comuns s\u00e3o appends ou reads \\item Servidores/discos/mem\u00f3rias est\u00e3o sempre falhando \\item Centenas de clientes concorrentes no mesmo arquivo \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/gfs3} \\end{frame} \\begin{frame}{Google FS} \\begin{itemize} \\item Google, 2003 \\item File System \\item Dados recuperados da Internet usados em consultas \\item Milh\u00f5es de arquivos de m\u00faltiplos GB \\item Chunks de 64MB (``blocos do disco'') \\item Opera\u00e7\u00f5es comuns s\u00e3o appends ou reads \\item Servidores/discos/mem\u00f3rias est\u00e3o sempre falhando \\item Centenas de clientes concorrentes no mesmo arquivo \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/gfs3} \\end{frame} \\begin{frame}{Google FS} \\includegraphics[width=.7\\textwidth]{images/gfs2} \\begin{itemize} \\item Clusters de n\u00f3s ``comuns'' \\item Master node: metadata \\item Chunk servers: data \\item Permite usar um cluster como um \u00fanico HD el\u00e1stico na rede. \\end{itemize} \\begin{itemize} \\item Clusters de n\u00f3s ``comuns'' \\item Master node: metadata \\item Chunk servers: data \\item Permite usar um cluster como um \u00fanico HD el\u00e1stico na rede. \\end{itemize} \\href{ https://www.cs.rutgers.edu/~pxk/417/lectures/l-dfs.html}{Fonte } \\end{frame} \\begin{frame}{Google FS} \\includegraphics[width=.7\\textwidth]{images/gfs5} \\begin{itemize} \\item Apps recebem \\emph{leases} de acesso direto aos dados \\item Atomic commitment garante consist\u00eancia entre r\u00e9plicas \\end{itemize} \\begin{itemize} \\item Apps recebem \\emph{leases} de acesso direto aos dados \\item Atomic commitment garante consist\u00eancia entre r\u00e9plicas \\end{itemize} \\href{ http://google-file-system.wikispaces.asu.edu/}{Fonte } \\end{frame} \\begin{frame}[fragile,allowframebreaks]{Google FS: Consist\u00eancia } \\includegraphics[width=\\textwidth]{images/gfs6} \\framebreak \\begin{enumerate} \\item Application sends the file name and data to the GFS client. \\item GFS Client send the file name and chunk index to master \\item Master sends the identity of the primary and other secondary replicas to the client. \\item Client caches this information. Client contacts master again only when primary is unreachable or it sends a reply saying it does not holds the lease anymore. \\item Considering the network topology the client sends the data to all the replicas.This improves performance. GFS separates data flow from the control flow. Replicas store the data in their LRU buffers till it is used. \\item After all replicas receiving of the data, client sends write request to the primary. Primary decides the mutation order. It applies this order to its local copy. \\item Primary sends the write request to all the secondary replicas. They perform write according to serial order decided by the primary. \\item After completing the operation all secondary acknowledge primary. \\item Primary replies the client about completion of the operation. In case of the errors that is when some of the secondary fail to write client request is supposed to be fail.This leaves modified chunk inconsistent. \\item Client handles this by retrying the failed mutation. \\end{enumerate} \\href{ http://google-file-system.wikispaces.asu.edu/}{Fonte } \\end{frame} \\begin{frame}{Map Reduce} \\begin{itemize} \\item Google, 2004 \\item Processamento distribu\u00eddo \\item Processa arquivos no Google FS \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/gfs4} \\end{frame} \\begin{frame}{Map Reduce} \\begin{itemize} \\item Google, 2004 \\item Processamento distribu\u00eddo \\item Processa arquivos no Google FS \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/gfs4} \\end{frame} \\frame{\\alert{leases?}} \\begin{frame}{Chubby} \\begin{itemize} \\item Google, 2006 \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/chubby1} \\end{frame} \\begin{frame}{Chubby} \\begin{itemize} \\item Google, 2006 \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/chubby1} \\end{frame} \\begin{frame}{Hadoop} \\begin{itemize} \\item HDFS: Hadoop Distributed File System \\item Map Reduce \\item Yahoo! \\item Open source em 2011, 1.0.0 \\item 2012, 2.0.0, \\item 2017, 3.0.0 \\item nov 2018, 2.9.2 \\end{itemize} \\end{frame} \\begin{frame}{Hadoop} \\begin{itemize} \\item HDFS: Hadoop Distributed File System \\item Map Reduce \\item Yahoo! \\item Open source em 2011, 1.0.0 \\item 2012, 2.0.0, \\item 2017, 3.0.0 \\item nov 2018, 2.9.2 \\end{itemize} \\end{frame} \\begin{frame}{Hadoop Ecosystem} \\begin{itemize} \\item Hive: data warehouse \\item Spark: \\item Kafka \\item Yarn \\item Pig: linguagem para especifica\u00e7\u00e3o de data flow. \\item HBase: banco de dados estruturado \\item Sqoop \\item Flume \\item Oozie \\item Avro: serializa\u00e7\u00e3o \\item Mahout: machine learning \\end{itemize} \\end{frame} \\begin{frame}{Hadoop Ecosystem} \\begin{itemize} \\item Hive: data warehouse \\item Spark: \\item Kafka \\item Yarn \\item Pig: linguagem para especifica\u00e7\u00e3o de data flow. \\item HBase: banco de dados estruturado \\item Sqoop \\item Flume \\item Oozie \\item Avro: serializa\u00e7\u00e3o \\item Mahout: machine learning \\end{itemize} \\end{frame} \\begin{frame}{HDFS} \\begin{itemize} \\item Distribu\u00eddo \\item Escal\u00e1vel \\item Cost effective \\item Tolerante a falhas \\item Alta vaz\u00e3o \\end{itemize} \\end{frame} \\begin{frame}{HDFS} \\begin{itemize} \\item Distribu\u00eddo \\item Escal\u00e1vel \\item Cost effective \\item Tolerante a falhas \\item Alta vaz\u00e3o \\end{itemize} \\end{frame} \\begin{frame}{Arquitetura} \\begin{itemize} \\item Rack e rack failure \\item Top of rack switch \\item Core switch \\item Name Node: nomes das pastas e arquivos \\item Data Node: conte\u00fado dos arquivos \\item Cliente \\end{itemize} \\end{frame} \\begin{frame}{Arquitetura} \\begin{itemize} \\item Rack e rack failure \\item Top of rack switch \\item Core switch \\item Name Node: nomes das pastas e arquivos \\item Data Node: conte\u00fado dos arquivos \\item Cliente \\end{itemize} \\end{frame} \\begin{frame}{Arquitetura} \\begin{itemize} \\item Crie arquivo: cliente -> name node \\item Escreva um block (e.g., 128MB): cliente \\item Aloque block: cliente -> name node \\item Salve os dados: cliente -> data node \\item Heartbeat block report: data node -> name node \\item Dados s\u00e3o replicados (RF configurado por arquivo): Data node -> data node \\end{itemize} \\end{frame} \\begin{frame}{Arquitetura} \\begin{itemize} \\item Crie arquivo: cliente -> name node \\item Escreva um block (e.g., 128MB): cliente \\item Aloque block: cliente -> name node \\item Salve os dados: cliente -> data node \\item Heartbeat block report: data node -> name node \\item Dados s\u00e3o replicados (RF configurado por arquivo): Data node -> data node \\end{itemize} \\end{frame} \\begin{frame}{Name node} Dados em memory e edit log. \\begin{itemize} \\item Name node \u00e9 um SPOF? \\item Quorum Journal Manager replica edit log. \\item Standby Name Node \\item Zookeeper usado para decidir quem \u00e9 o l\u00edder \\item Secondary Name Node replica checkpoint da imagem em mem\u00f3ria. \\end{itemize} \\end{frame} \\subsection{MapReduce} \\begin{frame}{MapReduce} \\begin{itemize} \\item Programa\u00e7\u00e3o funcional \\item Map: (map length (() (a) (a b c)) = (0 1 3)) \\item Fold/Reduce: (reduce + (1 2 3)) = 6 \\end{itemize} \\end{frame} \\begin{frame}{MapReduce} \\begin{itemize} \\item N\u00e3o h\u00e1 depend\u00eancia entre os dados \\item Dados divididos em \\emph{shards} \\item Execu\u00e7\u00e3o paralela e distribu\u00edda \\item Trabalhador recebe um shard \\item Mestre agrega valores \\item Milhares de processos \\item Petabytes de dados \\end{itemize} \\end{frame} \\begin{frame}{MapReduce} \\begin{itemize} \\item N\u00e3o h\u00e1 depend\u00eancia entre os dados \\item Dados divididos em \\emph{shards} \\item Execu\u00e7\u00e3o paralela e distribu\u00edda \\item Trabalhador recebe um shard \\item Mestre agrega valores \\item Milhares de processos \\item Petabytes de dados \\end{itemize} \\end{frame} \\begin{frame}{MapReduce} \\begin{itemize} \\item Shards s\u00e3o arquivos do GFS/HDFS/EC2 \\item Fun\u00e7\u00e3o mapeada a cada shard \\item Resultado \u00e9 lista de chaves e valores \\item Agrega\u00e7\u00e3o acontece por chaves \\item Resultado s\u00e3o arquivos no GFS/HDFS/EC2 \\end{itemize} \\end{frame} \\begin{frame}{MapReduce} \\begin{itemize} \\item Shards s\u00e3o arquivos do GFS/HDFS/EC2 \\item Fun\u00e7\u00e3o mapeada a cada shard \\item Resultado \u00e9 lista de chaves e valores \\item Agrega\u00e7\u00e3o acontece por chaves \\item Resultado s\u00e3o arquivos no GFS/HDFS/EC2 \\end{itemize} \\end{frame} \\begin{frame}{MapReduce} \\includegraphics[width=.8\\textwidth]{images/mapreduce1} \\end{frame} \\begin{frame}{MapReduce} \\includegraphics[width=.8\\textwidth]{images/mapreduce1} \\end{frame} \\begin{frame}{MapReduce} \\includegraphics[width=.8\\textwidth]{images/mapreduce2} \\end{frame} \\begin{frame}{MapReduce} \\includegraphics[width=.8\\textwidth]{images/mapreduce2} \\end{frame} \\subsection{Laborat\u00f3rio} \\begin{frame}[fragile]{Exemplo} \\begin{lstlisting}[language=java] import ... public class WordCount { public static class TokenizerMapper extends Mapper { private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key, Text value, Context context) throws IOException, InterruptedException { StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens()) { word.set(itr.nextToken()); context.write(word, one); } } } ... \\end{lstlisting} \\end{frame} \\begin{frame}[fragile]{Exemplo} \\begin{lstlisting}[language=java] ... public static class IntSumReducer extends Reducer { private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable values, Context context) throws IOException, InterruptedException { int sum = 0; for (IntWritable val : values) sum += val.get(); result.set(sum); context.write(key, result); } } public static void main(String[] args) throws Exception { ... } } \\end{lstlisting} \\href{ https://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html#Example:_WordCount_v1.0}{Fonte } \\end{frame} \\frame{\\url{ https://youtu.be/DJPwV2ge9m0?list=PLkz1SCf5iB4dw3jbRo0SYCk2urRESUA3v }} \\section{Estudo de caso: Kafka} \\subsection{Introdu\u00e7\u00e3o} \\begin{frame} \\includegraphics[width=\\textwidth]{images/kafka0} \\end{frame} \\begin{frame} \\includegraphics[width=\\textwidth]{images/kafka0} \\end{frame} \\begin{frame}{Apache Kafka} ``Kafka is a distributed streaming platform.'' \\begin{itemize} \\item LinkedIn \\item OpenSource em 2011 \\item Projeto Apache em ???? \\end{itemize} \\end{frame} \\begin{frame}{O qu\u00ea?} \\includegraphics[width=.6\\textwidth]{images/kafka1} \\end{frame} \\begin{frame}{O qu\u00ea?} \\includegraphics[width=.6\\textwidth]{images/kafka1} \\end{frame} \\begin{frame}{Usos} \\includegraphics[width=\\textwidth]{images/kafka2} \\pause record ~= message \\pause \\begin{block}{Enterprise Messaging System} Producers x Message Broker x Consumers \\end{block} \\end{frame} \\begin{frame}{Componentes} \\includegraphics[width=\\textwidth]{images/kafka3} \\begin{itemize} \\item Produtores: enviam dados/mensagens/records (array de bytes) \\item Consumidores: recebem dados \\item Cluster/Broker: distribu\u00eddo e tolerantes a falhas. \\item Conectores: integra\u00e7\u00e3o simplificada com outras aplica\u00e7\u00f5es \\item Stream processors: spark ou outros frameworks; transformam dados \\end{itemize} \\end{frame} \\begin{frame}{Apache Kafka} \\begin{itemize} \\item Brokers \\item Cluster de brokers \\item Distribu\u00eddo \\item Tolerante a falhas \\item Desacoplamento espacial \\item Desacoplamento temporal \\item T\u00f3picos, n\u00e3o endere\u00e7os \\end{itemize} \\end{frame} \\begin{frame}{Apache Kafka} \\begin{itemize} \\item Brokers \\item Cluster de brokers \\item Distribu\u00eddo \\item Tolerante a falhas \\item Desacoplamento espacial \\item Desacoplamento temporal \\item T\u00f3picos, n\u00e3o endere\u00e7os \\end{itemize} \\end{frame} \\begin{frame}{T\u00f3picos} \\begin{itemize} \\item Nome de uma stream de dados: ordem de servi\u00e7o, exame de sangue, MSFT \\item Quantidade pode ser imensa. \\end{itemize} \\end{frame} \\begin{frame}{T\u00f3picos} \\begin{itemize} \\item Nome de uma stream de dados: ordem de servi\u00e7o, exame de sangue, MSFT \\item Quantidade pode ser imensa. \\end{itemize} \\end{frame} \\begin{frame}{Parti\u00e7\u00e3o} \\begin{itemize} \\item Subdivis\u00f5es de t\u00f3picos \\item N\u00famero de parti\u00e7\u00f5es \u00e9 definido por usu\u00e1rio \\item Cada parti\u00e7\u00e3o est\u00e1 associada a um \u00fanico servidor \\end{itemize} \\end{frame} \\begin{frame}{Parti\u00e7\u00e3o} \\begin{itemize} \\item Subdivis\u00f5es de t\u00f3picos \\item N\u00famero de parti\u00e7\u00f5es \u00e9 definido por usu\u00e1rio \\item Cada parti\u00e7\u00e3o est\u00e1 associada a um \u00fanico servidor \\end{itemize} \\end{frame} \\begin{frame}{Offset} \\begin{itemize} \\item \u00cdndice de uma mensagem em uma parti\u00e7\u00e3o \\item \u00cdndices atribu\u00eddos na ordem de chegada \\item Offsets s\u00e3o locais \u00e0s parti\u00e7\u00f5es \\item Mensagens s\u00e3o unicamente identificadas por (t\u00f3pico, parti\u00e7\u00e3o, \u00edndice) \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/kafka4} \\end{frame} \\begin{frame}{Consumer group} \\begin{itemize} \\item Carga pode ser muito grande para um consumidor \\item Compartilham o processamento de um t\u00f3pico \\item Cada mensagem \u00e9 processada por um membro do grupo \\item A mesma mensagem pode ser processada por m\u00faltiplos grupos \\item N\u00famero de consumidores <span><span class=\"MathJax_Preview\">\\leq</span><script type=\"math/tex\">\\leq parti\u00e7\u00f5es no t\u00f3pico \\item M\u00e1ximo de dois consumidores por parti\u00e7\u00e3o (mantem pos. de cada um) \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/kafka5} \\end{frame} \\subsection{Quickstart} \\begin{frame}{Baixar e Executar} Siga o tutorial em \\url{ http://kafka.apache.org/quickstart }, at\u00e9 o passo 5. \\begin{itemize} \\item Baixe e descompacte \\item Rode o zookeeper (Terminal 1) \\item Rode o Kafka (Terminal 2) \\item Crie um t\u00f3pico (Terminal 3)\\\\ Mais de uma parti\u00e7\u00e3o em um servidor \\item \\alert{Conecte-se ao Zookeeper e d\u00ea uma olhada. O que est\u00e1 vendo?} \\item Liste os t\u00f3picos criados \\item Envie algumas mensagens \\item Inicie um consumidor (Terminal 4) \\end{itemize} \\end{frame} \\subsection{Toler\u00e2ncia a Falhas} \\begin{frame}{O qu\u00ea?} Manter dados/servi\u00e7os dispon\u00edveis a despeito de falhas. \\end{frame} \\begin{frame}{Replica\u00e7\u00e3o} No Kafka, o \\alert{Replication Factor} determina quantas c\u00f3pias de cada t\u00f3pico (todas as parti\u00e7\u00f5es no t\u00f3pico). \\end{frame} \\begin{frame}{Replica\u00e7\u00e3o} No Kafka, o \\alert{Replication Factor} determina quantas c\u00f3pias de cada t\u00f3pico (todas as parti\u00e7\u00f5es no t\u00f3pico). \\end{frame} \\begin{frame}{L\u00edder e Seguidor} \\begin{itemize} \\item Produtor conversa com l\u00edder. L\u00edder grava localmente e envia ack ao produtor. \\item Consumidor conversa com l\u00edder. L\u00edder envia dados ao consumidor. \\item L\u00edder replica dados para seguidores. \\end{itemize} \\end{frame} \\begin{frame}{L\u00edder e Seguidor} \\begin{itemize} \\item Produtor conversa com l\u00edder. L\u00edder grava localmente e envia ack ao produtor. \\item Consumidor conversa com l\u00edder. L\u00edder envia dados ao consumidor. \\item L\u00edder replica dados para seguidores. \\end{itemize} \\end{frame} \\begin{frame}{Replicar} Passo 6 ensina a criar um sistema com m\u00faltiplos brokers. \\begin{itemize} \\item Identificador \\item Porta (mesmo servidor) \\item \\alert{Log directory} \\end{itemize} \\end{frame} \\begin{frame}{Replicar} \\begin{itemize} \\item Crie um novo t\u00f3pico, com RF = 3 e duas parti\u00e7\u00f5es \\item \\lstinline|bin/kafka-topics.sh --list --zookeeper localhost:2181 --describe --topic <topico>| \\item Lista de r\u00e9plicas \\item Lista de r\u00e9plicas sincronizadas: \\emph{list of \\alert{i}n \\alert{s}ync \\alert{r}eplicas} \\end{itemize} \\end{frame} \\begin{frame}{Replicar} \\begin{itemize} \\item Crie um novo t\u00f3pico, com RF = 3 e duas parti\u00e7\u00f5es \\item \\lstinline|bin/kafka-topics.sh --list --zookeeper localhost:2181 --describe --topic <topico>| \\item Lista de r\u00e9plicas \\item Lista de r\u00e9plicas sincronizadas: \\emph{list of \\alert{i}n \\alert{s}ync \\alert{r}eplicas} \\end{itemize} \\end{frame} \\begin{frame}{Zookeeper} \\begin{itemize} \\item Permite que n\u00f3s do cluster se descubram \\item Elege l\u00edder \\end{itemize} \\end{frame} \\begin{frame}{Zookeeper} \\begin{itemize} \\item Permite que n\u00f3s do cluster se descubram \\item Elege l\u00edder \\end{itemize} \\end{frame} \\begin{frame}{Armazenamento} \\begin{itemize} \\item Dado deve ser removido depois de um tempo de ``reten\u00e7\u00e3o'' \\item Pode definir reten\u00e7\u00e3o por tamanho (por parti\u00e7\u00e3o, n\u00e3o t\u00f3pico) \\end{itemize} \\end{frame} \\begin{frame}{Armazenamento} \\begin{itemize} \\item Dado deve ser removido depois de um tempo de ``reten\u00e7\u00e3o'' \\item Pode definir reten\u00e7\u00e3o por tamanho (por parti\u00e7\u00e3o, n\u00e3o t\u00f3pico) \\end{itemize} \\end{frame} \\subsection{Produtor} \\begin{frame}{Produtor} \\begin{itemize} \\item Produtor envia mensagens para os brokers \\item Producer API \\item \\href{https://github.com/LearningJournal/ApacheKafkaTutorials}{Learning Journal} \\end{itemize} \\end{frame} \\begin{frame}{Produtor} \\begin{itemize} \\item Produtor envia mensagens para os brokers \\item Producer API \\item \\href{https://github.com/LearningJournal/ApacheKafkaTutorials}{Learning Journal} \\end{itemize} \\end{frame} \\begin{frame}[fragile]{SimpleProducer.java} \\begin{lstlisting}[language=Java] import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.Producer; import org.apache.kafka.clients.producer.ProducerRecord; import java.util.Properties; public class SimpleProducer { public static void main(String[] args) { String topicName = \"SimpleProducerTopic\"; String key = \"Chave\"; String value = \"Valor\"; Properties props = new Properties(); props.put(\"bootstrap.servers\", \"localhost:9092, localhost:9093\"); props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); Producer producer = new KafkaProducer (props); ProducerRecord record = new ProducerRecord (topicName, key, value); producer.send(record); producer.close(); System.out.println(\"SimpleProducer Completed.\"); } } \\end{lstlisting} \\end{frame} \\begin{frame}{Workflow} \\includegraphics[width=.8\\textwidth]{images/kafka6} \\begin{itemize} \\item Particionador default \\begin{itemize} \\item Partition \\item Hash da ``chave'' \\item Round robin \\end{itemize} \\item Retry autom\u00e1tico \\end{itemize} \\end{frame} \\begin{frame}{Fire and Forget} Envia a mensagem e n\u00e3o se importa com o resultado. \\end{frame} \\begin{frame}{Fire and Forget} Envia a mensagem e n\u00e3o se importa com o resultado. \\end{frame} \\begin{frame}[fragile]{Synchronous Call} Envia a mensagem e espera para saber se foi entregue ou n\u00e3o. \\begin{lstlisting}[language=Java] try{ RecordMetadata metadata = producer.send(record).get(); System.out.println(\"Message is sent to Partition no \" + metadata.partition() + \" and offset \" + metadata.offset()); System.out.println(\"SynchronousProducer Completed with success.\"); }catch (Exception e) { e.printStackTrace(); System.out.println(\"SynchronousProducer failed with an exception\"); }finally{ producer.close(); } \\end{lstlisting} \\begin{itemize} \\item Future \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Callback} Envia a mensagem e \u00e9 invocado depois de receber um ACK \\begin{lstlisting}[language=Java] producer.send(record, new MyProducerCallback()); ... class MyProducerCallback implements Callback{ @Override public void onCompletion(RecordMetadata recordMetadata, Exception e) { if (e != null) System.out.println(\"AsynchronousProducer failed with an exception\"); else System.out.println(\"AsynchronousProducer call Success:\"); } } \\end{lstlisting} \\begin{itemize} \\item max.in.flight.requests.per.connection \\end{itemize} \\end{frame} \\begin{frame}{Default Partitioner} \\includegraphics[width=.8\\textwidth]{images/kafka6} \\begin{itemize} \\item Partition \\item Hash da ``chave'' \\% \\#partition \\item Round robin \\end{itemize} \\begin{itemize} \\item Partition \\item Hash da ``chave'' \\% \\#partition \\item Round robin \\end{itemize} \\href{ https://github.com/LearningJournal/ApacheKafkaTutorials/blob/master/ProducerExamples/SensorPartitioner.java}{Exemplo de Custom Partitioner} \\end{frame} \\subsection{Consumidor} \\begin{frame}{Consumer Groups} \\begin{itemize} \\item M\u00faltiplos consumidores processam dados em paralelo \\item Grupo de consumidores de t\u00f3picos \\item Grupo pertence \u00e0 mesma aplica\u00e7\u00e3o \\includegraphics[width=.6\\textwidth]{images/kafka7} \\item Duplicate reads? Consumidores n\u00e3o compartilham parti\u00e7\u00f5es \\item Group coordinator (broker eleito): lista de consumidores \\item Group l\u00edder: rebalanceamento \\end{itemize} \\end{frame} \\begin{frame}{Consumer Groups} \\begin{itemize} \\item M\u00faltiplos consumidores processam dados em paralelo \\item Grupo de consumidores de t\u00f3picos \\item Grupo pertence \u00e0 mesma aplica\u00e7\u00e3o \\includegraphics[width=.6\\textwidth]{images/kafka7} \\item Duplicate reads? Consumidores n\u00e3o compartilham parti\u00e7\u00f5es \\item Group coordinator (broker eleito): lista de consumidores \\item Group l\u00edder: rebalanceamento \\end{itemize} \\end{frame} \\begin{frame}[fragile, allowframebreaks]{Consumer} \\begin{lstlisting}[language=Java] import org.apache.kafka.clients.consumer.ConsumerRecord; import org.apache.kafka.clients.consumer.ConsumerRecords; import org.apache.kafka.clients.consumer.KafkaConsumer; import java.io.IOException; import java.util.Arrays; import java.util.Properties; public class SimpleConsumer { public static void main(String[] args) throws IOException { String topicName = \"SimpleProducerTopic\"; String groupName = \"SupplierTopicGroup\"; Properties props = new Properties(); props.put(\"bootstrap.servers\", \"localhost:9092,localhost:9093\"); props.put(\"group.id\", groupName); props.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\"); props.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\"); KafkaConsumer consumer = null; try { consumer = new KafkaConsumer (props); consumer.subscribe(Arrays.asList(topicName)); while (true) { ConsumerRecords records = consumer.poll(100); 1 2 for (ConsumerRecord<String, String> record: records) System.out.println(\"Key = \" + record.key() + \" Value = \" + record.value()); } } catch (Exception ex) { ex.printStackTrace(); } finally { consumer.close(); } } } \\end{lstlisting} \\begin{itemize} \\item Se n\u00e3o definir grupo, ser\u00e1 novo grupo, e ler\u00e1 todas as mensagens dispon\u00edveis \\end{itemize} \\end{frame} \\begin{frame}{Poll} \\begin{itemize} \\item poll tamb\u00e9m envia hearbeat \\item executar a cada 3s, no m\u00ednimo \\item Current offset: a cada poll, broker incrementa current offset \\item Commited offset: o consumidor informa quais \u00edndices foram processados \\begin{itemize} \\item Auto Commit \\begin{itemize} \\item enable.auto.commit \\item auto.commit.interval.ms \\item Pode causar reprocessamento de mensagens \\end{itemize} \\item Manual Commit \\begin{itemize} \\item CommitSync \\item CommitAsync \\end{itemize} \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Poll} \\begin{itemize} \\item poll tamb\u00e9m envia hearbeat \\item executar a cada 3s, no m\u00ednimo \\item Current offset: a cada poll, broker incrementa current offset \\item Commited offset: o consumidor informa quais \u00edndices foram processados \\begin{itemize} \\item Auto Commit \\begin{itemize} \\item enable.auto.commit \\item auto.commit.interval.ms \\item Pode causar reprocessamento de mensagens \\end{itemize} \\item Manual Commit \\begin{itemize} \\item CommitSync \\item CommitAsync \\end{itemize} \\end{itemize} \\end{itemize} \\end{frame} \\subsection{Arquitetura} %\\begin{frame}{L\u00edder} %\\end{frame} %mensagens s\u00e3o ack depois de copiadas para todas as r\u00e9plicas %replicas lentas s\u00e3o removidas se lentas ou falhas %at least once, at most once, exactly one (nao suportado) %rolling upgrade %tls security %rest %CRUD \\subsection{Data Streams} \\subsection{Connectors} % \\begin{frame}{Data streams} %\\begin{itemize} % \\item %\\end{itemize} %\\end{frame}","title":"Tecnologias"},{"location":"teaching/gbc074gsi028/tech/#tecnologias","text":"","title":"Tecnologias"},{"location":"teaching/gbc074gsi028/tech/#como-sincronizar-duas-maquinas","text":"Produza um hash dos arquivos Troque hashes Se hashes iguais, pronto. Se hashes diferentes, volte para o slide anterior.","title":"Como sincronizar duas m\u00e1quinas?"},{"location":"teaching/gbc074gsi028/tech/#merkle-trees","text":"Divida o arquivo em blocos de mesmo tamanho Fa\u00e7a um hash de cada bloco Se mais de um hash gerado, Concatene os hashes em um arquivo Volte para o primeiro item Troque hashes da raiz. Se hashes iguais, pronto. Se hashes diferentes \\pause compare sub\u00e1rvore. Se a \u00fanica mudan\u00e7a no arquivo foi a adi\u00e7\u00e3o de um byte no come\u00e7o do arquivo?","title":"Merkle Trees"},{"location":"teaching/gbc074gsi028/tech/#rabin-fingerprint","text":"Rolling Hash","title":"Rabin Fingerprint"},{"location":"teaching/gbc074gsi028/tech/#blockchain","text":"\\subsection{Introdu\u00e7\u00e3o} \\begin{frame}{Mercado} \\begin{itemize} \\item Clientes, consumidores, fornecedores, vendedores \\item Bens, servi\u00e7os, contratos \\item Mercado p\u00fablico (feira livre, supermercados) e Privado (supply chain) \\end{itemize} \\end{frame} \\begin{frame}{Asset -- Bem} Tudo que tem valor e pode pertencer a algu\u00e9m. \\begin{itemize} \\item Casa, empr\u00e9stimo (tang\u00edvel e intang\u00edvel) \\item Patente \\item A\u00e7\u00e3o \\item Dinheiro -- \u00e9 an\u00f4nimo \\end{itemize} \\end{frame} \\begin{frame}{Asset -- Bem} Tudo que tem valor e pode pertencer a algu\u00e9m. \\begin{itemize} \\item Casa, empr\u00e9stimo (tang\u00edvel e intang\u00edvel) \\item Patente \\item A\u00e7\u00e3o \\item Dinheiro -- \u00e9 an\u00f4nimo \\end{itemize} \\end{frame} \\begin{frame}{Ledger} Livro registro 1 2 3 4 5 6 7 8 \\begin{itemize} \\item 1000 reais pagos ao funcion\u00e1rio F \\item Carro X vendido ao Jo\u00e3o por 50k \\item Cada entidade mant\u00e9m o seu, privadamente. \\item Ineficiente -- retrabalho e lento \\item Caro -- Retrabalho \\item Vulner\u00e1vel -- hack, erros, e modifica\u00e7\u00f5es maliciosas \\end{itemize} \\end{frame} \\begin{frame}{Blockchain} Ledger distribu\u00eddo e centralizado \\begin{itemize} \\item Replicado usando P2P \\item S\u00f3 envolvidos tem acesso ao registro \\item Consenso -- acordo na transa\u00e7\u00e3o \\item Proveni\u00eancia -- todo o hist\u00f3rico de um asset \u00e9 mantido na blockchain. \\item Imutabilidade -- entradas n\u00e3o podem ser alteradas \\item Finalidade -- entradas n\u00e3o podem ser refutadas \\end{itemize} \\end{frame} \\begin{frame}{Blockchain} Ledger distribu\u00eddo e centralizado \\begin{itemize} \\item Replicado usando P2P \\item S\u00f3 envolvidos tem acesso ao registro \\item Consenso -- acordo na transa\u00e7\u00e3o \\item Proveni\u00eancia -- todo o hist\u00f3rico de um asset \u00e9 mantido na blockchain. \\item Imutabilidade -- entradas n\u00e3o podem ser alteradas \\item Finalidade -- entradas n\u00e3o podem ser refutadas \\end{itemize} \\end{frame} \\begin{frame}{Bitcoin} Primeira aplica\u00e7\u00e3o da blockchain \\begin{itemize} \\item Bitcoin \\begin{itemize} \\item Moeda \u00e9 o asset \\item Anonimidade \\item Proof of work \\end{itemize} \\item Neg\u00f3cios \\begin{itemize} \\item Qualquer coisa \u00e9 asset \\item Identifica\u00e7\u00e3o das partes \\item Selective endorsement \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Bitcoin} Primeira aplica\u00e7\u00e3o da blockchain \\begin{itemize} \\item Bitcoin \\begin{itemize} \\item Moeda \u00e9 o asset \\item Anonimidade \\item Proof of work \\end{itemize} \\item Neg\u00f3cios \\begin{itemize} \\item Qualquer coisa \u00e9 asset \\item Identifica\u00e7\u00e3o das partes \\item Selective endorsement \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Smart Contracts} Os termos do neg\u00f3cio s\u00e3o mantidos na blockchain: \"Se na data X a entidade E n\u00e3o tiver transferido D dinheiros para a entidade F, ent\u00e3o transfira o asset A de E para F.\" 1 Verific\u00e1vel, assin\u00e1vel e \\emph{execut\u00e1vel}. \\end{frame} \\frame{} \\begin{frame}{Bitcoin} \\includegraphics[width=\\textwidth]{images/bitcoin_jun_2018} \\end{frame} \\begin{frame}{Bitcoin} \\includegraphics[width=\\textwidth]{images/bitcoin_jun_2018} \\end{frame} \\begin{frame}{Bitcoin} \\includegraphics[width=\\textwidth]{images/bitcoin_dec_2018} \\end{frame} \\section{A Small Piece of Big Data} \\subsection{Introdu\u00e7\u00e3o} \\frame{ \\begin{block}{Big-Data} ``Big data is a term for data sets that are so large or complex that traditional data processing application software is inadequate to deal with them.'' \\end{block} Ciclo convencional: \\begin{itemize} \\item Coleta \\item Armazenamento \\item An\u00e1lise \\item Consulta \\item Compartilhamento \\item Visualiza\u00e7\u00e3o \\item Atualiza\u00e7\u00e3o \\item ... \\end{itemize} \\href{ https://en.wikipedia.org/wiki/Big_data}{Fonte } } \\begin{frame}{\u00c1reas} Grandes massas de dados: \\begin{itemize} \\item Propaganda \\item Astronomia \\item Ci\u00eancia \\item e-governos \\item meteorologia \\item \\emph{genomics} \\item ... \\end{itemize} \\end{frame} \\begin{frame}{\u00c1reas} Grandes massas de dados: \\begin{itemize} \\item Propaganda \\item Astronomia \\item Ci\u00eancia \\item e-governos \\item meteorologia \\item \\emph{genomics} \\item ... \\end{itemize} \\end{frame} \\begin{frame}{Dados} \\begin{itemize} \\item Internet das coisas \\item sensoriamento remoto \\item suas fotos \\item logs de software \\item RFID \\item redes de sensores \\item ... \\end{itemize} \\end{frame} \\begin{frame}{Dados} \\begin{itemize} \\item Internet das coisas \\item sensoriamento remoto \\item suas fotos \\item logs de software \\item RFID \\item redes de sensores \\item ... \\end{itemize} \\end{frame} \\begin{frame}{O qu\u00ea?} Qu\u00e3o grande \u00e9 ``big'' o suficiente? \\pause Depende dos dados, ferramentas, e capacidade de manipul\u00e1-los. \\pause Uma vez dado um passo, o alvo passa a ser o pr\u00f3ximo passo. \\pause Isso quer dizer que vai de alguns TB at\u00e9 Petabytes, dependendo do problema. \\end{frame} \\begin{frame}{O qu\u00ea?} Qu\u00e3o grande \u00e9 ``big'' o suficiente? \\pause Depende dos dados, ferramentas, e capacidade de manipul\u00e1-los. \\pause Uma vez dado um passo, o alvo passa a ser o pr\u00f3ximo passo. \\pause Isso quer dizer que vai de alguns TB at\u00e9 Petabytes, dependendo do problema. \\end{frame} \\begin{frame}{O qu\u00ea?} \\begin{block}{Gartner, 2012} Big data is high volume, high velocity, and/or high variety information assets that require new forms of processing to enable enhanced decision making, insight discovery and process optimization. \\end{block} \\begin{itemize} \\item Volume: incapacidade de armazenar todos os dados; apenas observe e guarde conclus\u00f5es \\item Velocidade: dados passando em ``tempo real'' \\item Variedade: imagens, v\u00eddeos, \u00e1udio, temperatura,... \\pause \\item Machine learning para automa\u00e7\u00e3o de extra\u00e7\u00e3o de informa\u00e7\u00e3o, por exemplo, detec\u00e7\u00e3o de padr\u00f5es, sem se preocupar com o porqu\u00ea dos mesmos. \\end{itemize} \\end{frame} \\begin{frame}{Como lidar?} \\begin{itemize} \\item Bancos de dados colunares \\item Stream DBs \\item ... \\item \\alert{MapReduce} \\end{itemize} \\end{frame} \\begin{frame}{Como lidar?} \\begin{itemize} \\item Bancos de dados colunares \\item Stream DBs \\item ... \\item \\alert{MapReduce} \\end{itemize} \\end{frame} \\subsection{Google FS} \\begin{frame}{Google FS} \\begin{itemize} \\item Google, 2003 \\item File System \\item Dados recuperados da Internet usados em consultas \\item Milh\u00f5es de arquivos de m\u00faltiplos GB \\item Chunks de 64MB (``blocos do disco'') \\item Opera\u00e7\u00f5es comuns s\u00e3o appends ou reads \\item Servidores/discos/mem\u00f3rias est\u00e3o sempre falhando \\item Centenas de clientes concorrentes no mesmo arquivo \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/gfs3} \\end{frame} \\begin{frame}{Google FS} \\begin{itemize} \\item Google, 2003 \\item File System \\item Dados recuperados da Internet usados em consultas \\item Milh\u00f5es de arquivos de m\u00faltiplos GB \\item Chunks de 64MB (``blocos do disco'') \\item Opera\u00e7\u00f5es comuns s\u00e3o appends ou reads \\item Servidores/discos/mem\u00f3rias est\u00e3o sempre falhando \\item Centenas de clientes concorrentes no mesmo arquivo \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/gfs3} \\end{frame} \\begin{frame}{Google FS} \\includegraphics[width=.7\\textwidth]{images/gfs2} \\begin{itemize} \\item Clusters de n\u00f3s ``comuns'' \\item Master node: metadata \\item Chunk servers: data \\item Permite usar um cluster como um \u00fanico HD el\u00e1stico na rede. \\end{itemize} \\begin{itemize} \\item Clusters de n\u00f3s ``comuns'' \\item Master node: metadata \\item Chunk servers: data \\item Permite usar um cluster como um \u00fanico HD el\u00e1stico na rede. \\end{itemize} \\href{ https://www.cs.rutgers.edu/~pxk/417/lectures/l-dfs.html}{Fonte } \\end{frame} \\begin{frame}{Google FS} \\includegraphics[width=.7\\textwidth]{images/gfs5} \\begin{itemize} \\item Apps recebem \\emph{leases} de acesso direto aos dados \\item Atomic commitment garante consist\u00eancia entre r\u00e9plicas \\end{itemize} \\begin{itemize} \\item Apps recebem \\emph{leases} de acesso direto aos dados \\item Atomic commitment garante consist\u00eancia entre r\u00e9plicas \\end{itemize} \\href{ http://google-file-system.wikispaces.asu.edu/}{Fonte } \\end{frame} \\begin{frame}[fragile,allowframebreaks]{Google FS: Consist\u00eancia } \\includegraphics[width=\\textwidth]{images/gfs6} \\framebreak \\begin{enumerate} \\item Application sends the file name and data to the GFS client. \\item GFS Client send the file name and chunk index to master \\item Master sends the identity of the primary and other secondary replicas to the client. \\item Client caches this information. Client contacts master again only when primary is unreachable or it sends a reply saying it does not holds the lease anymore. \\item Considering the network topology the client sends the data to all the replicas.This improves performance. GFS separates data flow from the control flow. Replicas store the data in their LRU buffers till it is used. \\item After all replicas receiving of the data, client sends write request to the primary. Primary decides the mutation order. It applies this order to its local copy. \\item Primary sends the write request to all the secondary replicas. They perform write according to serial order decided by the primary. \\item After completing the operation all secondary acknowledge primary. \\item Primary replies the client about completion of the operation. In case of the errors that is when some of the secondary fail to write client request is supposed to be fail.This leaves modified chunk inconsistent. \\item Client handles this by retrying the failed mutation. \\end{enumerate} \\href{ http://google-file-system.wikispaces.asu.edu/}{Fonte } \\end{frame} \\begin{frame}{Map Reduce} \\begin{itemize} \\item Google, 2004 \\item Processamento distribu\u00eddo \\item Processa arquivos no Google FS \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/gfs4} \\end{frame} \\begin{frame}{Map Reduce} \\begin{itemize} \\item Google, 2004 \\item Processamento distribu\u00eddo \\item Processa arquivos no Google FS \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/gfs4} \\end{frame} \\frame{\\alert{leases?}} \\begin{frame}{Chubby} \\begin{itemize} \\item Google, 2006 \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/chubby1} \\end{frame} \\begin{frame}{Chubby} \\begin{itemize} \\item Google, 2006 \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/chubby1} \\end{frame} \\begin{frame}{Hadoop} \\begin{itemize} \\item HDFS: Hadoop Distributed File System \\item Map Reduce \\item Yahoo! \\item Open source em 2011, 1.0.0 \\item 2012, 2.0.0, \\item 2017, 3.0.0 \\item nov 2018, 2.9.2 \\end{itemize} \\end{frame} \\begin{frame}{Hadoop} \\begin{itemize} \\item HDFS: Hadoop Distributed File System \\item Map Reduce \\item Yahoo! \\item Open source em 2011, 1.0.0 \\item 2012, 2.0.0, \\item 2017, 3.0.0 \\item nov 2018, 2.9.2 \\end{itemize} \\end{frame} \\begin{frame}{Hadoop Ecosystem} \\begin{itemize} \\item Hive: data warehouse \\item Spark: \\item Kafka \\item Yarn \\item Pig: linguagem para especifica\u00e7\u00e3o de data flow. \\item HBase: banco de dados estruturado \\item Sqoop \\item Flume \\item Oozie \\item Avro: serializa\u00e7\u00e3o \\item Mahout: machine learning \\end{itemize} \\end{frame} \\begin{frame}{Hadoop Ecosystem} \\begin{itemize} \\item Hive: data warehouse \\item Spark: \\item Kafka \\item Yarn \\item Pig: linguagem para especifica\u00e7\u00e3o de data flow. \\item HBase: banco de dados estruturado \\item Sqoop \\item Flume \\item Oozie \\item Avro: serializa\u00e7\u00e3o \\item Mahout: machine learning \\end{itemize} \\end{frame} \\begin{frame}{HDFS} \\begin{itemize} \\item Distribu\u00eddo \\item Escal\u00e1vel \\item Cost effective \\item Tolerante a falhas \\item Alta vaz\u00e3o \\end{itemize} \\end{frame} \\begin{frame}{HDFS} \\begin{itemize} \\item Distribu\u00eddo \\item Escal\u00e1vel \\item Cost effective \\item Tolerante a falhas \\item Alta vaz\u00e3o \\end{itemize} \\end{frame} \\begin{frame}{Arquitetura} \\begin{itemize} \\item Rack e rack failure \\item Top of rack switch \\item Core switch \\item Name Node: nomes das pastas e arquivos \\item Data Node: conte\u00fado dos arquivos \\item Cliente \\end{itemize} \\end{frame} \\begin{frame}{Arquitetura} \\begin{itemize} \\item Rack e rack failure \\item Top of rack switch \\item Core switch \\item Name Node: nomes das pastas e arquivos \\item Data Node: conte\u00fado dos arquivos \\item Cliente \\end{itemize} \\end{frame} \\begin{frame}{Arquitetura} \\begin{itemize} \\item Crie arquivo: cliente -> name node \\item Escreva um block (e.g., 128MB): cliente \\item Aloque block: cliente -> name node \\item Salve os dados: cliente -> data node \\item Heartbeat block report: data node -> name node \\item Dados s\u00e3o replicados (RF configurado por arquivo): Data node -> data node \\end{itemize} \\end{frame} \\begin{frame}{Arquitetura} \\begin{itemize} \\item Crie arquivo: cliente -> name node \\item Escreva um block (e.g., 128MB): cliente \\item Aloque block: cliente -> name node \\item Salve os dados: cliente -> data node \\item Heartbeat block report: data node -> name node \\item Dados s\u00e3o replicados (RF configurado por arquivo): Data node -> data node \\end{itemize} \\end{frame} \\begin{frame}{Name node} Dados em memory e edit log. \\begin{itemize} \\item Name node \u00e9 um SPOF? \\item Quorum Journal Manager replica edit log. \\item Standby Name Node \\item Zookeeper usado para decidir quem \u00e9 o l\u00edder \\item Secondary Name Node replica checkpoint da imagem em mem\u00f3ria. \\end{itemize} \\end{frame} \\subsection{MapReduce} \\begin{frame}{MapReduce} \\begin{itemize} \\item Programa\u00e7\u00e3o funcional \\item Map: (map length (() (a) (a b c)) = (0 1 3)) \\item Fold/Reduce: (reduce + (1 2 3)) = 6 \\end{itemize} \\end{frame} \\begin{frame}{MapReduce} \\begin{itemize} \\item N\u00e3o h\u00e1 depend\u00eancia entre os dados \\item Dados divididos em \\emph{shards} \\item Execu\u00e7\u00e3o paralela e distribu\u00edda \\item Trabalhador recebe um shard \\item Mestre agrega valores \\item Milhares de processos \\item Petabytes de dados \\end{itemize} \\end{frame} \\begin{frame}{MapReduce} \\begin{itemize} \\item N\u00e3o h\u00e1 depend\u00eancia entre os dados \\item Dados divididos em \\emph{shards} \\item Execu\u00e7\u00e3o paralela e distribu\u00edda \\item Trabalhador recebe um shard \\item Mestre agrega valores \\item Milhares de processos \\item Petabytes de dados \\end{itemize} \\end{frame} \\begin{frame}{MapReduce} \\begin{itemize} \\item Shards s\u00e3o arquivos do GFS/HDFS/EC2 \\item Fun\u00e7\u00e3o mapeada a cada shard \\item Resultado \u00e9 lista de chaves e valores \\item Agrega\u00e7\u00e3o acontece por chaves \\item Resultado s\u00e3o arquivos no GFS/HDFS/EC2 \\end{itemize} \\end{frame} \\begin{frame}{MapReduce} \\begin{itemize} \\item Shards s\u00e3o arquivos do GFS/HDFS/EC2 \\item Fun\u00e7\u00e3o mapeada a cada shard \\item Resultado \u00e9 lista de chaves e valores \\item Agrega\u00e7\u00e3o acontece por chaves \\item Resultado s\u00e3o arquivos no GFS/HDFS/EC2 \\end{itemize} \\end{frame} \\begin{frame}{MapReduce} \\includegraphics[width=.8\\textwidth]{images/mapreduce1} \\end{frame} \\begin{frame}{MapReduce} \\includegraphics[width=.8\\textwidth]{images/mapreduce1} \\end{frame} \\begin{frame}{MapReduce} \\includegraphics[width=.8\\textwidth]{images/mapreduce2} \\end{frame} \\begin{frame}{MapReduce} \\includegraphics[width=.8\\textwidth]{images/mapreduce2} \\end{frame} \\subsection{Laborat\u00f3rio} \\begin{frame}[fragile]{Exemplo} \\begin{lstlisting}[language=java] import ... public class WordCount { public static class TokenizerMapper extends Mapper { private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key, Text value, Context context) throws IOException, InterruptedException { StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens()) { word.set(itr.nextToken()); context.write(word, one); } } } ... \\end{lstlisting} \\end{frame} \\begin{frame}[fragile]{Exemplo} \\begin{lstlisting}[language=java] ... public static class IntSumReducer extends Reducer { private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable values, Context context) throws IOException, InterruptedException { int sum = 0; for (IntWritable val : values) sum += val.get(); result.set(sum); context.write(key, result); } } public static void main(String[] args) throws Exception { ... } } \\end{lstlisting} \\href{ https://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html#Example:_WordCount_v1.0}{Fonte } \\end{frame} \\frame{\\url{ https://youtu.be/DJPwV2ge9m0?list=PLkz1SCf5iB4dw3jbRo0SYCk2urRESUA3v }} \\section{Estudo de caso: Kafka} \\subsection{Introdu\u00e7\u00e3o} \\begin{frame} \\includegraphics[width=\\textwidth]{images/kafka0} \\end{frame} \\begin{frame} \\includegraphics[width=\\textwidth]{images/kafka0} \\end{frame} \\begin{frame}{Apache Kafka} ``Kafka is a distributed streaming platform.'' \\begin{itemize} \\item LinkedIn \\item OpenSource em 2011 \\item Projeto Apache em ???? \\end{itemize} \\end{frame} \\begin{frame}{O qu\u00ea?} \\includegraphics[width=.6\\textwidth]{images/kafka1} \\end{frame} \\begin{frame}{O qu\u00ea?} \\includegraphics[width=.6\\textwidth]{images/kafka1} \\end{frame} \\begin{frame}{Usos} \\includegraphics[width=\\textwidth]{images/kafka2} \\pause record ~= message \\pause \\begin{block}{Enterprise Messaging System} Producers x Message Broker x Consumers \\end{block} \\end{frame} \\begin{frame}{Componentes} \\includegraphics[width=\\textwidth]{images/kafka3} \\begin{itemize} \\item Produtores: enviam dados/mensagens/records (array de bytes) \\item Consumidores: recebem dados \\item Cluster/Broker: distribu\u00eddo e tolerantes a falhas. \\item Conectores: integra\u00e7\u00e3o simplificada com outras aplica\u00e7\u00f5es \\item Stream processors: spark ou outros frameworks; transformam dados \\end{itemize} \\end{frame} \\begin{frame}{Apache Kafka} \\begin{itemize} \\item Brokers \\item Cluster de brokers \\item Distribu\u00eddo \\item Tolerante a falhas \\item Desacoplamento espacial \\item Desacoplamento temporal \\item T\u00f3picos, n\u00e3o endere\u00e7os \\end{itemize} \\end{frame} \\begin{frame}{Apache Kafka} \\begin{itemize} \\item Brokers \\item Cluster de brokers \\item Distribu\u00eddo \\item Tolerante a falhas \\item Desacoplamento espacial \\item Desacoplamento temporal \\item T\u00f3picos, n\u00e3o endere\u00e7os \\end{itemize} \\end{frame} \\begin{frame}{T\u00f3picos} \\begin{itemize} \\item Nome de uma stream de dados: ordem de servi\u00e7o, exame de sangue, MSFT \\item Quantidade pode ser imensa. \\end{itemize} \\end{frame} \\begin{frame}{T\u00f3picos} \\begin{itemize} \\item Nome de uma stream de dados: ordem de servi\u00e7o, exame de sangue, MSFT \\item Quantidade pode ser imensa. \\end{itemize} \\end{frame} \\begin{frame}{Parti\u00e7\u00e3o} \\begin{itemize} \\item Subdivis\u00f5es de t\u00f3picos \\item N\u00famero de parti\u00e7\u00f5es \u00e9 definido por usu\u00e1rio \\item Cada parti\u00e7\u00e3o est\u00e1 associada a um \u00fanico servidor \\end{itemize} \\end{frame} \\begin{frame}{Parti\u00e7\u00e3o} \\begin{itemize} \\item Subdivis\u00f5es de t\u00f3picos \\item N\u00famero de parti\u00e7\u00f5es \u00e9 definido por usu\u00e1rio \\item Cada parti\u00e7\u00e3o est\u00e1 associada a um \u00fanico servidor \\end{itemize} \\end{frame} \\begin{frame}{Offset} \\begin{itemize} \\item \u00cdndice de uma mensagem em uma parti\u00e7\u00e3o \\item \u00cdndices atribu\u00eddos na ordem de chegada \\item Offsets s\u00e3o locais \u00e0s parti\u00e7\u00f5es \\item Mensagens s\u00e3o unicamente identificadas por (t\u00f3pico, parti\u00e7\u00e3o, \u00edndice) \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/kafka4} \\end{frame} \\begin{frame}{Consumer group} \\begin{itemize} \\item Carga pode ser muito grande para um consumidor \\item Compartilham o processamento de um t\u00f3pico \\item Cada mensagem \u00e9 processada por um membro do grupo \\item A mesma mensagem pode ser processada por m\u00faltiplos grupos \\item N\u00famero de consumidores <span><span class=\"MathJax_Preview\">\\leq</span><script type=\"math/tex\">\\leq parti\u00e7\u00f5es no t\u00f3pico \\item M\u00e1ximo de dois consumidores por parti\u00e7\u00e3o (mantem pos. de cada um) \\end{itemize} \\includegraphics[width=.6\\textwidth]{images/kafka5} \\end{frame} \\subsection{Quickstart} \\begin{frame}{Baixar e Executar} Siga o tutorial em \\url{ http://kafka.apache.org/quickstart }, at\u00e9 o passo 5. \\begin{itemize} \\item Baixe e descompacte \\item Rode o zookeeper (Terminal 1) \\item Rode o Kafka (Terminal 2) \\item Crie um t\u00f3pico (Terminal 3)\\\\ Mais de uma parti\u00e7\u00e3o em um servidor \\item \\alert{Conecte-se ao Zookeeper e d\u00ea uma olhada. O que est\u00e1 vendo?} \\item Liste os t\u00f3picos criados \\item Envie algumas mensagens \\item Inicie um consumidor (Terminal 4) \\end{itemize} \\end{frame} \\subsection{Toler\u00e2ncia a Falhas} \\begin{frame}{O qu\u00ea?} Manter dados/servi\u00e7os dispon\u00edveis a despeito de falhas. \\end{frame} \\begin{frame}{Replica\u00e7\u00e3o} No Kafka, o \\alert{Replication Factor} determina quantas c\u00f3pias de cada t\u00f3pico (todas as parti\u00e7\u00f5es no t\u00f3pico). \\end{frame} \\begin{frame}{Replica\u00e7\u00e3o} No Kafka, o \\alert{Replication Factor} determina quantas c\u00f3pias de cada t\u00f3pico (todas as parti\u00e7\u00f5es no t\u00f3pico). \\end{frame} \\begin{frame}{L\u00edder e Seguidor} \\begin{itemize} \\item Produtor conversa com l\u00edder. L\u00edder grava localmente e envia ack ao produtor. \\item Consumidor conversa com l\u00edder. L\u00edder envia dados ao consumidor. \\item L\u00edder replica dados para seguidores. \\end{itemize} \\end{frame} \\begin{frame}{L\u00edder e Seguidor} \\begin{itemize} \\item Produtor conversa com l\u00edder. L\u00edder grava localmente e envia ack ao produtor. \\item Consumidor conversa com l\u00edder. L\u00edder envia dados ao consumidor. \\item L\u00edder replica dados para seguidores. \\end{itemize} \\end{frame} \\begin{frame}{Replicar} Passo 6 ensina a criar um sistema com m\u00faltiplos brokers. \\begin{itemize} \\item Identificador \\item Porta (mesmo servidor) \\item \\alert{Log directory} \\end{itemize} \\end{frame} \\begin{frame}{Replicar} \\begin{itemize} \\item Crie um novo t\u00f3pico, com RF = 3 e duas parti\u00e7\u00f5es \\item \\lstinline|bin/kafka-topics.sh --list --zookeeper localhost:2181 --describe --topic <topico>| \\item Lista de r\u00e9plicas \\item Lista de r\u00e9plicas sincronizadas: \\emph{list of \\alert{i}n \\alert{s}ync \\alert{r}eplicas} \\end{itemize} \\end{frame} \\begin{frame}{Replicar} \\begin{itemize} \\item Crie um novo t\u00f3pico, com RF = 3 e duas parti\u00e7\u00f5es \\item \\lstinline|bin/kafka-topics.sh --list --zookeeper localhost:2181 --describe --topic <topico>| \\item Lista de r\u00e9plicas \\item Lista de r\u00e9plicas sincronizadas: \\emph{list of \\alert{i}n \\alert{s}ync \\alert{r}eplicas} \\end{itemize} \\end{frame} \\begin{frame}{Zookeeper} \\begin{itemize} \\item Permite que n\u00f3s do cluster se descubram \\item Elege l\u00edder \\end{itemize} \\end{frame} \\begin{frame}{Zookeeper} \\begin{itemize} \\item Permite que n\u00f3s do cluster se descubram \\item Elege l\u00edder \\end{itemize} \\end{frame} \\begin{frame}{Armazenamento} \\begin{itemize} \\item Dado deve ser removido depois de um tempo de ``reten\u00e7\u00e3o'' \\item Pode definir reten\u00e7\u00e3o por tamanho (por parti\u00e7\u00e3o, n\u00e3o t\u00f3pico) \\end{itemize} \\end{frame} \\begin{frame}{Armazenamento} \\begin{itemize} \\item Dado deve ser removido depois de um tempo de ``reten\u00e7\u00e3o'' \\item Pode definir reten\u00e7\u00e3o por tamanho (por parti\u00e7\u00e3o, n\u00e3o t\u00f3pico) \\end{itemize} \\end{frame} \\subsection{Produtor} \\begin{frame}{Produtor} \\begin{itemize} \\item Produtor envia mensagens para os brokers \\item Producer API \\item \\href{https://github.com/LearningJournal/ApacheKafkaTutorials}{Learning Journal} \\end{itemize} \\end{frame} \\begin{frame}{Produtor} \\begin{itemize} \\item Produtor envia mensagens para os brokers \\item Producer API \\item \\href{https://github.com/LearningJournal/ApacheKafkaTutorials}{Learning Journal} \\end{itemize} \\end{frame} \\begin{frame}[fragile]{SimpleProducer.java} \\begin{lstlisting}[language=Java] import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.Producer; import org.apache.kafka.clients.producer.ProducerRecord; import java.util.Properties; public class SimpleProducer { public static void main(String[] args) { String topicName = \"SimpleProducerTopic\"; String key = \"Chave\"; String value = \"Valor\"; Properties props = new Properties(); props.put(\"bootstrap.servers\", \"localhost:9092, localhost:9093\"); props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); Producer producer = new KafkaProducer (props); ProducerRecord record = new ProducerRecord (topicName, key, value); producer.send(record); producer.close(); System.out.println(\"SimpleProducer Completed.\"); } } \\end{lstlisting} \\end{frame} \\begin{frame}{Workflow} \\includegraphics[width=.8\\textwidth]{images/kafka6} \\begin{itemize} \\item Particionador default \\begin{itemize} \\item Partition \\item Hash da ``chave'' \\item Round robin \\end{itemize} \\item Retry autom\u00e1tico \\end{itemize} \\end{frame} \\begin{frame}{Fire and Forget} Envia a mensagem e n\u00e3o se importa com o resultado. \\end{frame} \\begin{frame}{Fire and Forget} Envia a mensagem e n\u00e3o se importa com o resultado. \\end{frame} \\begin{frame}[fragile]{Synchronous Call} Envia a mensagem e espera para saber se foi entregue ou n\u00e3o. \\begin{lstlisting}[language=Java] try{ RecordMetadata metadata = producer.send(record).get(); System.out.println(\"Message is sent to Partition no \" + metadata.partition() + \" and offset \" + metadata.offset()); System.out.println(\"SynchronousProducer Completed with success.\"); }catch (Exception e) { e.printStackTrace(); System.out.println(\"SynchronousProducer failed with an exception\"); }finally{ producer.close(); } \\end{lstlisting} \\begin{itemize} \\item Future \\end{itemize} \\end{frame} \\begin{frame}[fragile]{Callback} Envia a mensagem e \u00e9 invocado depois de receber um ACK \\begin{lstlisting}[language=Java] producer.send(record, new MyProducerCallback()); ... class MyProducerCallback implements Callback{ @Override public void onCompletion(RecordMetadata recordMetadata, Exception e) { if (e != null) System.out.println(\"AsynchronousProducer failed with an exception\"); else System.out.println(\"AsynchronousProducer call Success:\"); } } \\end{lstlisting} \\begin{itemize} \\item max.in.flight.requests.per.connection \\end{itemize} \\end{frame} \\begin{frame}{Default Partitioner} \\includegraphics[width=.8\\textwidth]{images/kafka6} \\begin{itemize} \\item Partition \\item Hash da ``chave'' \\% \\#partition \\item Round robin \\end{itemize} \\begin{itemize} \\item Partition \\item Hash da ``chave'' \\% \\#partition \\item Round robin \\end{itemize} \\href{ https://github.com/LearningJournal/ApacheKafkaTutorials/blob/master/ProducerExamples/SensorPartitioner.java}{Exemplo de Custom Partitioner} \\end{frame} \\subsection{Consumidor} \\begin{frame}{Consumer Groups} \\begin{itemize} \\item M\u00faltiplos consumidores processam dados em paralelo \\item Grupo de consumidores de t\u00f3picos \\item Grupo pertence \u00e0 mesma aplica\u00e7\u00e3o \\includegraphics[width=.6\\textwidth]{images/kafka7} \\item Duplicate reads? Consumidores n\u00e3o compartilham parti\u00e7\u00f5es \\item Group coordinator (broker eleito): lista de consumidores \\item Group l\u00edder: rebalanceamento \\end{itemize} \\end{frame} \\begin{frame}{Consumer Groups} \\begin{itemize} \\item M\u00faltiplos consumidores processam dados em paralelo \\item Grupo de consumidores de t\u00f3picos \\item Grupo pertence \u00e0 mesma aplica\u00e7\u00e3o \\includegraphics[width=.6\\textwidth]{images/kafka7} \\item Duplicate reads? Consumidores n\u00e3o compartilham parti\u00e7\u00f5es \\item Group coordinator (broker eleito): lista de consumidores \\item Group l\u00edder: rebalanceamento \\end{itemize} \\end{frame} \\begin{frame}[fragile, allowframebreaks]{Consumer} \\begin{lstlisting}[language=Java] import org.apache.kafka.clients.consumer.ConsumerRecord; import org.apache.kafka.clients.consumer.ConsumerRecords; import org.apache.kafka.clients.consumer.KafkaConsumer; import java.io.IOException; import java.util.Arrays; import java.util.Properties; public class SimpleConsumer { public static void main(String[] args) throws IOException { String topicName = \"SimpleProducerTopic\"; String groupName = \"SupplierTopicGroup\"; Properties props = new Properties(); props.put(\"bootstrap.servers\", \"localhost:9092,localhost:9093\"); props.put(\"group.id\", groupName); props.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\"); props.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\"); KafkaConsumer consumer = null; try { consumer = new KafkaConsumer (props); consumer.subscribe(Arrays.asList(topicName)); while (true) { ConsumerRecords records = consumer.poll(100); 1 2 for (ConsumerRecord<String, String> record: records) System.out.println(\"Key = \" + record.key() + \" Value = \" + record.value()); } } catch (Exception ex) { ex.printStackTrace(); } finally { consumer.close(); } } } \\end{lstlisting} \\begin{itemize} \\item Se n\u00e3o definir grupo, ser\u00e1 novo grupo, e ler\u00e1 todas as mensagens dispon\u00edveis \\end{itemize} \\end{frame} \\begin{frame}{Poll} \\begin{itemize} \\item poll tamb\u00e9m envia hearbeat \\item executar a cada 3s, no m\u00ednimo \\item Current offset: a cada poll, broker incrementa current offset \\item Commited offset: o consumidor informa quais \u00edndices foram processados \\begin{itemize} \\item Auto Commit \\begin{itemize} \\item enable.auto.commit \\item auto.commit.interval.ms \\item Pode causar reprocessamento de mensagens \\end{itemize} \\item Manual Commit \\begin{itemize} \\item CommitSync \\item CommitAsync \\end{itemize} \\end{itemize} \\end{itemize} \\end{frame} \\begin{frame}{Poll} \\begin{itemize} \\item poll tamb\u00e9m envia hearbeat \\item executar a cada 3s, no m\u00ednimo \\item Current offset: a cada poll, broker incrementa current offset \\item Commited offset: o consumidor informa quais \u00edndices foram processados \\begin{itemize} \\item Auto Commit \\begin{itemize} \\item enable.auto.commit \\item auto.commit.interval.ms \\item Pode causar reprocessamento de mensagens \\end{itemize} \\item Manual Commit \\begin{itemize} \\item CommitSync \\item CommitAsync \\end{itemize} \\end{itemize} \\end{itemize} \\end{frame} \\subsection{Arquitetura} %\\begin{frame}{L\u00edder} %\\end{frame} %mensagens s\u00e3o ack depois de copiadas para todas as r\u00e9plicas %replicas lentas s\u00e3o removidas se lentas ou falhas %at least once, at most once, exactly one (nao suportado) %rolling upgrade %tls security %rest %CRUD \\subsection{Data Streams} \\subsection{Connectors} % \\begin{frame}{Data streams} %\\begin{itemize} % \\item %\\end{itemize} %\\end{frame}","title":"Blockchain"},{"location":"teaching/gbc074gsi028/time/","text":"Tempo Neste cap\u00edtulo discutiremos como o tempo \u00e9 importante no desenvolvimento de sistemas distribu\u00eddos. Comecemos por analisar o funcionamento de uma aplica\u00e7\u00e3o distribu\u00edda muito comum, o armazenamento de arquivos na nuvem, sincronizado com o sistema de arquivos local. Alguns exemplos do munto real s\u00e3o DropBox, Box, Google Drive and OneDrive; chamemos este servi\u00e7o genericamente de cloud-drive . Se um mesmo arquivo no cloud-drive \u00e9 modificado em duas m\u00e1quinas diferentes, enquanto as mesmas est\u00e3o desconectadas, o qu\u00ea acontece quando elas se reconectam \u00e0 Internet? Mais especificamente, quando as duas m\u00e1quins se conectam e enviam suas vers\u00f5es do arquivo modificado para o servidor, sendo que ambas foram geradas a partir de um ancestral comum, qual vers\u00e3o deve ser armazenada e qual deve ser descartada? Uma possibilidade simples \u00e9 sempre aceitar o cada nova vers\u00e3o como uma modifica\u00e7\u00e3o do arquivo. Assim, efetivamente, quando a primeira vers\u00e3o for entregue, ser\u00e1 aceita e viver\u00e1 momentaneamente at\u00e9 que a outra vers\u00e3o seja recebida e a sobrescreva. Mas imagine que esteja usando o cloud-drive para registrar a anterioridade de ideias (quem pensou nisso primeiro?), registrando-as em arquivos salvos no cloud-drive. Neste caso, o sistema poderia dar anterioridade \u00e0 entrada errada, que chegou por \u00faltimo. Se invertermos a abordagem, o cloud-drive poderia manter vers\u00f5es antigas de um documento em detrimento de vers\u00f5es mais atualizadas, o que obviamente seria um problema para outros usos. Mas mesmo que manter a vers\u00e3o mais recente ou mais antiga fosse adequada, o problema \u00e9 mais fundamental que isso. Afinal, a ordem de chegada dos arquivos ao servidor n\u00e3o reflete necessariamente a ordem em que os arquivos foram criados. Assim, podemos pensar em outras alternativas de aproveitamento e descarte de arquivos baseadas na cria\u00e7\u00e3o do arquivo, e n\u00e3o em sua recep\u00e7\u00e3o. Contudo, o hor\u00e1rio de cria\u00e7\u00e3o de um arquivo \u00e9 relativo a onde foi criado e n\u00e3o ao grupo de processos que comp\u00f5e o sistema, o que pode levar uma modifica\u00e7\u00e3o que tenha acontecido mais tarde, do ponto de vista de um observador externo, a ter um hor\u00e1rio de cria\u00e7\u00e3o oficial anterior. Uma terceira abordagem \u00e9 gerar uma terceira vers\u00e3o, com a \"soma\" das duas conflitantes. Para gerar esta terceira vers\u00e3o, faz mais sentido quebrar os arquivos em opera\u00e7\u00f5es de modifica\u00e7\u00e3o , e executar as opera\u00e7\u00f5es de forma a chegar ao resultado final. O problema permanece, pois as opera\u00e7\u00f5es agora devem ser ordenadas. Em qualquer destas linhas de atua\u00e7\u00e3o, voc\u00ea tem em m\u00e3os um conflito para resolver, e automatizar a resolu\u00e7\u00e3o do mesmo \u00e9 muito complicado. \u00c9 por isso que o Dropbox, por exemplo, deixa os dois arquivos para que o usu\u00e1rio analize e decida o que fazer, que servidores git permitem a submiss\u00e3o de apenas um conjunto de opera\u00e7\u00f5es por vez para um mesmo reposit\u00f3rio/branch, e o Perforce trabalha com locks de arquivos. Dada esta problem\u00e1tica, podemos simplificar a quest\u00e3o em nossas m\u00e3os. Pergunta Se duas opera\u00e7\u00f5es originadas em clientes s\u00e3o enviadas ao servidor, qual deve ser executada primeiro? Alguns sistemas tentam resolver automaticamente os conflitos; o CassandraDB, por exemplo, usa last write wins ou latest version wins , onde last \u00e9 definido em termos do rel\u00f3gio do cliente. Acontece que a maior parte dos nossos sistemas n\u00e3o d\u00e1 garantias de tempo na entrega de mensagens ou processamento de instru\u00e7\u00f5es. Assim, temos novo problema: Pergunta Como determinar qual foi enviada primeiro, em um sistema ass\u00edncrono? Assim, precisamos encontrar uma fonte de tempo confi\u00e1vel e distribu\u00edda , e o desafio come\u00e7a com o entendimento de rel\u00f3gios f\u00edsicos. Rel\u00f3gios F\u00edsicos Quando falamos em rel\u00f3gios, provavelmente falamos sobre rel\u00f3gios a base de quartzo. Para uma introdu\u00e7\u00e3o r\u00e1pida, assista o seguinte v\u00eddeo. Em suma, um rel\u00f3gio de quartzo consiste em um diapaz\u00e3o de quartzo cortado a laser que, devido ao efeito Piezoel\u00e9trico 2 e sua forma particular, vibra a 32768 = 2^{15} 32768 = 2^{15} Hz 3 , e em um contador que conta cada vibra\u00e7\u00e3o, medindo a passagem do tempo. Estes rel\u00f3gios erram na medi\u00e7\u00e3o do tempo em no m\u00e1ximo \u00bds por dia , desde que operem dentro da faixa de 5 a 35C, mas isso tamb\u00e9m muda com a idade do cristal, a corrente el\u00e9trica passando por ele e tamb\u00e9m devido a imperfei\u00e7\u00f5es no cristal 1 . Computadores em geral usam rel\u00f3gios de quartzo, por serem baratos, como base de um rel\u00f3gio mantido em software. Isto \u00e9, do ponto de vista de um computador comum, o tempo \u00e9 medido com base em um rel\u00f3gio quartzo, cujos incrementos s\u00e3o capturados em um contador; o contador gera interrup\u00e7\u00f5es em intervalos programados (e.g., Linux >2.6 usa 250Hz por padr\u00e3o; m\u00e1ximo 1000Hz) e as interrup\u00e7\u00f5es causam ajustes em um rel\u00f3gio em software , um contador indireto C C . Precis\u00e3o Dado a frequ\u00eancia padr\u00e3o de 250Hz, medi\u00e7\u00f5es de tempo menores que 4ms s\u00e3o altamente imprecisas. Como medir o tempo gasto em uma fun\u00e7\u00e3o do seu c\u00f3digo? Este rel\u00f3gio em software, C C , que usa um rel\u00f3gio de quartzo, impreciso, pode marcar a passagem do tempo com erro para mais ou para menos. Embora o erro exato do rel\u00f3gio seja desconhecido, o mesmo \u00e9 limitado probabilisticamente. A taxa de erro \u00e9 denominada drift , \u00e9 representada por \\rho \\rho . Assumindo um rel\u00f3gio perfeito, t t , temos que 1 - \\rho \\leq \\frac{dC}{dt} \\leq 1 + \\rho 1 - \\rho \\leq \\frac{dC}{dt} \\leq 1 + \\rho . Assim, um \\rho \\rho de 0.1 implica em um erro de mais ou menos 10%; a figura a seguir mostra a faixa em que C C pode operar e que o erro em rela\u00e7\u00e3o a t t vai aumentando com a passagem do tempo. Embora adequado para humanos, o erro dos rel\u00f3gios de quartzo \u00e9 inaceit\u00e1vel em algumas opera\u00e7\u00f5es computacionais. Felizmente, os erros do destes rel\u00f3gios podem ser minimizados ao ponto de termos um erros menores que 1s em milh\u00f5es de anos, nos dispositivos conhecidos como rel\u00f3gios at\u00f4micos . Embora muito bom, o rel\u00f3gio at\u00f4mico tamb\u00e9m n\u00e3o \u00e9 perfeito e, devido a v\u00e1rias raz\u00f5es, pode levar tamb\u00e9m a erros. Mas o qu\u00ea mais se pode fazer no sentido de melhorar a precis\u00e3o dos rel\u00f3gios? A resposta est\u00e1 no UTC. Tempo Universal Coordenado O UTC, de uma mistura dos nomes em Ingl\u00eas e Franc\u00eas do Tempo Universal Coordenado, um padr\u00e3o global para coordena\u00e7\u00e3o da medi\u00e7\u00e3o da passagem do tempo. Segundo o UTC, o sol est\u00e1 a pino \u00e0s 12:00 na latitude 0, ou a no m\u00e1ximo 1s deste instante; ao redor da latitude 0 grau estabelece-se uma faixa em que todos os pontos tem o mesmo hor\u00e1rio, e outras 23 faixas como esta com deslocamentos consecutivos de +-1 hora. Estas faixas, conhecidas coloquialmente como fusos, sofrem ajustes por fatores pol\u00edticos; a China, por exemplo, apesar de seu tamanho, est\u00e1 toda dentro de um mesmo hor\u00e1rio, \"correto\" para Beijing. Mas como o UTC \u00e9 definido? Com base no TAI, Tempo At\u00f4mico Internacional, calculado como a m\u00e9dia dos valores de rel\u00f3gios at\u00f4micos espalhados pelo globo. O TAI mede perfeitamente a passagem do tempo, mas como a rota\u00e7\u00e3o da terra \u00e9 irregular, medir perfeitamente n\u00e3o \u00e9 o adequado. Assim, o UTC leva em considera\u00e7\u00e3o o fato do dia n\u00e3o ter exatamente 24 horas e, de fato, n\u00e3o ter dura\u00e7\u00e3o constante. Por exemplo, ap\u00f3s um grande terremoto o centro de massa da terra pode ser alterado e a rota\u00e7\u00e3o ter sua velocidade aumentada ou diminu\u00edda. UTC Nearly all UTC days contain exactly 86,400 SI seconds with exactly 60 seconds in each minute. However, because the mean solar day is slightly longer than 86,400 SI seconds, occasionally the last minute of a UTC day is adjusted to have 61 seconds. The extra second is called a leap second. It accounts for the grand total of the extra length (about 2 milliseconds each) of all the mean solar days since the previous leap second. The last minute of a UTC day is permitted to contain 59 seconds to cover the remote possibility of the Earth rotating faster, but that has not yet been necessary. Sincroniza\u00e7\u00e3o de Rel\u00f3gios Dado o UTC, temos ent\u00e3o uma refer\u00eancia de tempo adequada para uso em sistemas computacionais, colocamos nova pergunta: Se o rel\u00f3gio se dist\u00e2ncia da medida correta da passagem do tempo, \u00e9 poss\u00edvel corrigir este distanciamento, sincronizando-o com uma fonte correta, da qual UTC \u00e9 nossa melhor aproxima\u00e7\u00e3o, para que todos percebam a mesma passagem do tempo? Embora a resposta seja negativa, no sentido de que n\u00e3o \u00e9 poss\u00edvel alcan\u00e7ar sincroniza\u00e7\u00e3o perfeita, nada nos impede de fazer um melhor esfor\u00e7o e, neste sentido, tamb\u00e9m temos que nos perguntar qual a frequ\u00eancia de sincroniza\u00e7\u00e3o? Frequ\u00eancia de Sincroniza\u00e7\u00e3o Como garantir que dois rel\u00f3gios com erro m\u00e1ximo igual a \\rho \\rho n\u00e3o diferir\u00e3o em mais que \\delta \\delta unidades de tempo? Resposta Sincronize pelo menos a cada \\frac{\\delta}{2\\rho} \\frac{\\delta}{2\\rho} segundos. E se tivermos muitos rel\u00f3gios a serem sincronizados, o problema \u00e9 mais dif\u00edcil? Frequ\u00eancia de Sincroniza\u00e7\u00e3o Como garantir que dois rel\u00f3gios quaisquer, em um sistema com n n rel\u00f3gios, todos com erro m\u00e1ximo igual a \\rho \\rho , n\u00e3o diferir\u00e3o em mais que \\delta \\delta unidades de tempo? Resposta Se todos sincronizarem com a mesma fonte, a cada \\frac{\\delta}{2\\rho} \\frac{\\delta}{2\\rho} segundos, seja o n\u00f3 n1 aquele com maior erro em rela\u00e7\u00e3o \u00e0 fonte e n2 aquele com maior erro em rela\u00e7\u00e3o a n1. Como ambos tem um erro m\u00e1ximo de \\delta \\delta em rela\u00e7\u00e3o \u00e0 fonte, o erro m\u00e1ximo entre os dois n\u00f3s \u00e9 2\\delta 2\\delta . Como este erro \u00e9 o dobro do desejado, basta dobrar a frequ\u00eancia de sincroniza\u00e7\u00e3o para cortar o erro pela metade. Vejamos um exemplo: \\rho = 0,1 \\rho = 0,1 \\delta \\delta = 1s Ap\u00f3s 10s, um n\u00f3 com estas caracter\u00edsticas se dessincronizaria em, no m\u00e1ximo, 1s em rela\u00e7\u00e3o ao UTC. Como cada n\u00f3 poderia estar errando em \"dire\u00e7\u00f5es\" diferentes, ap\u00f3s 5s, um n\u00f3 poderia se adiantar em 0,5s enquanto o outro se atrasa pela mesma quantidade de tempo, somando 1s de diferen\u00e7a. Logo, eles tem que se sincronizar a cada 5s, i.e, \\frac{\\delta}{2\\rho} = \\frac{1s}{2 \\times 0,1} = \\frac{1s}{0,2} = 5s \\frac{\\delta}{2\\rho} = \\frac{1s}{2 \\times 0,1} = \\frac{1s}{0,2} = 5s Como \u00faltima parada antes de come\u00e7armos a falar sobre a sincroniza\u00e7\u00e3o em si, devemos estabelecer alguns cuidados a serem tomados no processo. Nunca voltar no tempo - isso poderia levar a um dado ter data de edi\u00e7\u00e3o anterior a data de cria\u00e7\u00e3o. Ajustes graduais - acelere ou desacelere o rel\u00f3gio (em software) Diminua/Aumente frequ\u00eancia de interrup\u00e7\u00e3o para atrasar/adiantar rel\u00f3gio Diminua/Aumente incremento com cada interrup\u00e7\u00e3o Ajustes peri\u00f3dicos para fazer curvas convergirem. Corre\u00e7\u00e3o ap\u00f3s dormir ser\u00e1 mais dr\u00e1stica Agora que voc\u00ea j\u00e1 tem uma fonte confi\u00e1vel de tempo, o UTC, e sabe com que frequ\u00eancia sincronizar os rel\u00f3gios, s\u00f3 nos falta fazer a sincroniza\u00e7\u00e3o. Contudo, falta ainda definir o protocolo pelo qual a sincroniza\u00e7\u00e3o \u00e9 feita e exatamente com quem, uma vez que simpleste UTC \u00e9 muito gen\u00e9rico. Comecemos com vetor \"pr\u00f3ximo\" do UTC, os rel\u00f3gios at\u00f4micos em sat\u00e9lites GPS. Global Positioning System Receptores GPS, com seus rel\u00f3gios sincronizados com os dos sat\u00e9lites, que difundem regularmente sua posi\u00e7\u00e3o e o instante em que a difus\u00e3o \u00e9 feita, determinam sua posi\u00e7\u00e3o relativa aos sat\u00e9lites, em uma t\u00e9cnica conhecida como trilatera\u00e7\u00e3o, que consiste em determinar a dist\u00e2ncia do receptor em termos dos eixos x x , y y e z z em rela\u00e7\u00e3o a cada um dos sat\u00e9lites. Em outras palavras, baseado na informa\u00e7\u00e3o de um sat\u00e9lite, o receptor determina sua dist\u00e2ncia ao mesmo e, portanto, determina que est\u00e1 em uma esfera no entorno do sat\u00e9lite. Combinando a informa\u00e7\u00e3o de 2 sat\u00e9lites, a posi\u00e7\u00e3o do receptor \u00e9 limitada a uma circunfer\u00eancia, isto \u00e9, a interse\u00e7\u00e3o de duas esferas. Com um terceiro sat\u00e9lite, a posi\u00e7\u00e3o \u00e9 reduzida a dois pontos, a interse\u00e7\u00e3o de uma esfera e uma circunfer\u00eancia, sendo um no espa\u00e7o e que pode ser facilmente descartado. Contudo, para que funcione, rel\u00f3gios dos sat\u00e9lites e receptores precisam estar sincronizados para que o c\u00e1lculo da dist\u00e2ncia possa ser feito, mas sincronizar os rel\u00f3gios \u00e9 exatamente o problema que estamos tentando resolver. Para contornar esta restri\u00e7\u00e3o, usa-se um quarto sat\u00e9lite, para determinar a dist\u00e2ncia no \"eixo temporal\". Assim, temos uma receita simples para sincroniza\u00e7\u00e3o de rel\u00f3gios com UTC: Coloque um receptor GPS em cada n\u00f3 do seu sistema Tenha erro de 0,1ns a 1ms do UTC Apesar da queda dos pre\u00e7os dos receptores, colocar um GPS em cada dispositivo pode ser custoso demais. Em vez disso, podemos usar um recurso amplamente dispon\u00edvel, redes de computadores, e sincronizar com outra m\u00e1quina, que fez o investimento necess\u00e1rio para manter o erro baixo. Para estes computadores \"de segundo escal\u00e3o\", a receita ent\u00e3o \u00e9: Pergunte que horas s\u00e3o. Use a resposta para ajustar o rel\u00f3gio local. Considere o erro introduzido pela lat\u00eancia vari\u00e1vel da rede. Esta receita b\u00e1sica pode ser ajustada de diversas formas. Algoritmo de Cristian Assumindo que o rel\u00f3gio da m\u00e1quina se sincronizando, M_1 M_1 , \u00e9 bom o suficiente para medir a passagem de tempo em per\u00edodos curtos, mesmo que tenha uma drift rate consider\u00e1vel em per\u00edodos mais longos, execute o seguinte protocolo para se sincronizar com M_2 M_2 . M_1 M_1 pergunta \"que horas s\u00e3o?\" - t_0 t_0 M_2 M_2 recebe pergunta - t_1 t_1 M_2 M_2 anota o valor do rel\u00f3gio - t_s t_s M_2 M_2 envia resposta - t_2 t_2 M_1 M_1 recebe resposta - t_3 t_3 Assuma t_1 = t_s = t_2 t_1 = t_s = t_2 Assuma \\frac{t_3-t_0}{2} \\frac{t_3-t_0}{2} como o tempo de transmiss\u00e3o da resposta (m\u00e9dia da ida e da volta) M_1 M_1 ajusta rel\u00f3gio para t_c = t_s + \\frac{t_3-t_0}{2} t_c = t_s + \\frac{t_3-t_0}{2} Mas e a aproxima\u00e7\u00e3o \\frac{t_3-t_0}{2} \\frac{t_3-t_0}{2} , \u00e9 boa? Podemos estimar o erro que ela introduz na sincroniza\u00e7\u00e3o, caso as mensagens tenham tempos de ida e volta assim\u00e9tricos. Apesar das diferen\u00e7as no tempo de ida e volta, existe um tempo m\u00ednimo para o tr\u00e1fego em cada um dos sentidos, T_{min} T_{min} . A figura a seguir demonstra o erro desta t\u00e9cnica Fonte Observe que h\u00e1 dois casos extremos de erro na estimativa. No primeiro caso, dado um tempo de ida + volta igual a T_1 - T_0 T_1 - T_0 , na figura, a mensagem de ida trafega no tempo m\u00ednimo e a volta lentamente. Neste caso, a estimativa \\frac{t_3-t_0}{2} \\frac{t_3-t_0}{2} \u00e9 menor que o tempo de volta real. No segundo caso, a mensagem de ida trafega lentamente e a de volta no tempo m\u00ednimo, levando \\frac{t_3-t_0}{2} \\frac{t_3-t_0}{2} a ser maior que tempo de transmiss\u00e3o real da mensagem. O erro, contudo, est\u00e1 limitado \u00e0 faixa amarela no desenho, que tem dura\u00e7\u00e3o $T_1 - T_0 - 2T_{min} $. O erro ent\u00e3o varia de mais ou menos metade deste valor. Algoritmo de Berkeley Enquanto o algoritmo de Cristian permite sincronizar um n\u00f3 com uma fonte, outro algoritmo, de Berkeley, permite sincronizar m\u00faltiplos n\u00f3s uns com os outros. Este algoritmo assume o que n\u00e3o h\u00e1 uma \"fonte da verdade\" do tempo, mas sim a necessidade de que todos os processos converjam para um mesmo valor do rel\u00f3gio. \u00c9 como nos filmes de espi\u00e3o em que os rel\u00f3gios s\u00e3o sincronizados; pouco importa se a bomba explodir\u00e1 10:57 ou 10:59, desde que todos concordem quando isso vai acontecer. Isso \u00e9 o que chamamos de sincroniza\u00e7\u00e3o interna em vez de externa, como provido pelo algoritmo de Cristian. O algoritmo de Berkeley requer que todo n\u00f3 execute um processo de sincroniza\u00e7\u00e3o, um \"daemon\", e separa seus pap\u00e9is em dois tipos, prim\u00e1rio e secund\u00e1rio . O papel do prim\u00e1rio pode ser rotacionado entre os v\u00e1rios processos, sem perdas para sua execu\u00e7\u00e3o. O algoritmo ent\u00e3o \u00e9 executacomo se segue: Prim\u00e1rio pergunta \"que horas s\u00e3o\" para cada secund\u00e1rio (mensages 1,2,3 e 4) Secund\u00e1rio responde com valor atual do rel\u00f3gio (mensagens 5,6,7 e 8) Prim\u00e1rio ajusta as respostas de acordo com o algoritmo de Cristian, para minimizar erros. Prim\u00e1rio computa m\u00e9dia dos valores recebidos, ignorando outliers (como o da mensagem 8). Prim\u00e1rio envia ajustes para secund\u00e1rios (mensagens 8,9,10 e 11) Secund\u00e1rio executa ajuste sugerido pelo prim\u00e1rio. sequenceDiagram autonumber note over Prim\u00e1rio: 10:00 note over Secund\u00e1rio1: 10:06 note over Secund\u00e1rio2: 10:15 note over Secund\u00e1rio3: 23:18 par Pergunta Prim\u00e1rio->>Prim\u00e1rio: Que horas s\u00e3o? and Prim\u00e1rio->>Secund\u00e1rio1: Que horas s\u00e3o? and Prim\u00e1rio->>Secund\u00e1rio2: Que horas s\u00e3o? and Prim\u00e1rio->>Secund\u00e1rio3: Que horas s\u00e3o? end par Resposta Prim\u00e1rio->>Prim\u00e1rio: 10:00 and Secund\u00e1rio1->>Prim\u00e1rio: 10:06 and Secund\u00e1rio2->>Prim\u00e1rio: 10:15 and rect rgb(255, 0, 0) Secund\u00e1rio3->>Prim\u00e1rio: 23:18 end end par Ajuste Prim\u00e1rio->>Prim\u00e1rio: 10:07 and Prim\u00e1rio->>Secund\u00e1rio1: 10:07 and Prim\u00e1rio->>Secund\u00e1rio2: 10:07 and Prim\u00e1rio->>Secund\u00e1rio3: 10:07 end Embora interessantes, estes algoritmos n\u00e3o s\u00e3o normalmente usados, pelo menos n\u00e3o em sua forma \"pura\", em sistemas computacionais. Em vez deles, usamos o Network Time Protocol (NTP). Network Time Protocol 1991/1992: RFC 1305 2010: RFC 5905-5908 -- IPv6, 10s ms de acur\u00e1cia Uso na Internet Sincroniza\u00e7\u00e3o com UTC Estat\u00edstica permite minimizar erros Tolerante a falhas: caminhos redundantes; servidores redundantes Escal\u00e1vel: modelo hier\u00e1rquico Seguro: usa autentica\u00e7\u00e3o Os diversos componentes do NTP s\u00e3o organizados em camadas, ou estrata, de forma que a informa\u00e7\u00e3o do tempo flui da camada 0 (stratum 0) at\u00e9 a camada 15 (stratum 15). Os componentes n\u00e3o est\u00e3o presos a camadas, que podem ser alteradas a medida que falhas acontecem e s\u00e3o dedicadas, e novos caminhos s\u00e3o encontrados usando-se um algoritmo de \u00e1rvore geradora m\u00ednima. Network Time Protocol Fonte: Benjamin D. Esham, (bdesham) - Based upon Ntp.png by Kim Meyrick Stratum 0: rel\u00f3gios at\u00f4micos/receptores GPS Stratum 1: ms to stratum 0 Stratum 2: contata m\u00faltiplos stratum 1 e pares Strata 3...15 Stratum 16: dessincronizado Bellman-Ford: \u00e1rvore geradora m\u00ednima para stratum 1 O s\u00edtio do Comit\u00ea Gestor da Internet, CGI, tem uma entrada muito boa sobre o NTP, NTP.br . De forma resumida, o NTP trabalha em diferentes modos, que permitem aos n\u00f3s receberem informa\u00e7\u00f5es de fontes de tempo das camadas superiores ou de pares, filtrar estas informa\u00e7\u00f5es para escolher as mais confi\u00e1veis, e ajustar o rel\u00f3gio local de acordo com a filtragem. Modos de trabalho do NTP Modo multicast: propaga tempo em rede local RPC: algoritmo de Cristian Sim\u00e9trico: parecido com Berkeley Na pr\u00e1tica, boa parte dos dispositivos usa uma vers\u00e3o simplificada do NTP, adequada aos n\u00f3s nas folhas da hierarquia. O SNTP \u00e9 essencialmente o algoritmo de Cristian. Simple NTP Vers\u00e3o simplificada do NTP Recomendado para folhas da \u00e1rvore \\delta = (t_4-t_1)-(t_2-t_3) \\delta = (t_4-t_1)-(t_2-t_3) t = \\frac{(t_2-t_1)+(t3-t_4)}{2} t = \\frac{(t_2-t_1)+(t3-t_4)}{2} t_c = t_4+t t_c = t_4+t Veja um exemplo do ajuste de um rel\u00f3gio usando SNTP. Exemplo do SNTP t_1 = 1100, t_2 = 800, t_3=850, t_4=1200 t_1 = 1100, t_2 = 800, t_3=850, t_4=1200 t = ((800-1100)+(850-1200))/2 = (-300 -350)/ = -325 t = ((800-1100)+(850-1200))/2 = (-300 -350)/ = -325 t_c = 1200-325 = 875 t_c = 1200-325 = 875 Mais recentemente foi proposta um novo protocolo de sincroniza\u00e7\u00e3o de rel\u00f3gios com melhor qualidade de serv\u00e7o, Precision Time Protocol, PTP. PTP - Precision Time Protocol IEEE 1588 LAN sub \\mu s \\mu s (versus ordem de ms ms no NTP) Escolha mestre Administrador Classe do rel\u00f3gio Acur\u00e1cia do rel\u00f3gio Vari\u00e2ncia do rel\u00f3gio Identificador Como algoritmo de Cristian, mas quem ajusta n\u00e3o \u00e9 quem inicia. Assumindo que tenhamos sincronizado os rel\u00f3gios de um sistema computacional, o que podemos fazer agora? H\u00e1 uma s\u00e9rie de problemas interessantes que podem ser resolvidos. Usos de rel\u00f3gios sincronizados autentica\u00e7\u00e3o termina\u00e7\u00e3o de transa\u00e7\u00f5es aloca\u00e7\u00e3o de ``leases''. outros exemplos, Liskov, B. Distrib Comput (1993) 6: 211. doi:10.1007/BF02242709 Um exemplo interessante \u00e9 a ordena\u00e7\u00e3o de eventos em um banco de dados. Para entender este problema, considere o seguinte cen\u00e1rio com um Sistema Banc\u00e1rio Se os comandos chegam primeiro para a replica mais pr\u00f3xima e s\u00e3o executados na ordem em que chegam, temos inconsist\u00eancias entre as r\u00e9plicas (p.e., assuma que update 1 \u00e9 \"atualize para 10\" e 2 \u00e9 \"atualize para 20\") Assim, precisamos ordenar os comandos! Nos foquemos em apenas uma r\u00e9plica. Assuma que rel\u00f3gios est\u00e3o perfeitamente sincronizados, que o tempo de propaga\u00e7\u00e3o m\u00e1ximo de uma mensagem \u00e9 \\tau \\tau , e que toda mensagem/update carrega o timestamp de quando foi enviada consigo. Considere o seguinte proposta: R\u00e9plicas processam mensagens na ordem que foram enviadas, o que pode ser identificado pelos seus timestamps. Em outras palavras, ao receber uma mensagem com timestamp t t , uma r\u00e9plica espera at\u00e9 ter certeza de que Ordena\u00e7\u00e3o de Requisi\u00e7\u00f5es Rel\u00f3gios perfeitamente sincronizados \\tau \\tau . Cliente 1 envia mensagem Update1 no instante t t . Ao receber Update1 com timestamp t t , a r\u00e9plica deve esperar para executar o update? O \u00faltimo instante em que qualquer mensagem com timestamp t' < t t' < t pode ser recebido pela r\u00e9plica \u00e9 t+\\tau t+\\tau , pois qualquer mensagem recebida em t''> t+\\tau' t''> t+\\tau' , precisa ter sido enviada ap\u00f3s t t , e portanto ter\u00e1 timestamp > t > t . Implementar este protocolo \u00e9 muito simples: Toda mensagem recebida \u00e9 colocada em uma fila ordenada por timestamp . Quando o rel\u00f3gio marcar um tempo maior que t + \\tau t + \\tau , onde t t \u00e9 o timestamp da mensagem na cabe\u00e7a da fila, execute tal mensagem e a retire da fila. Entretanto, este protocolo n\u00e3o leva em considera\u00e7\u00e3o a dessincroniza\u00e7\u00e3o inerente dos rel\u00f3gios em um sistema distribu\u00eddo. Como faz\u00ea-lo, supondo uma diverg\u00eancia m\u00e1xima de \\Delta \\Delta entre quaisquer dois rel\u00f3gios, algo que pode ser arranjado, como visto antes, sincronizando-se os rel\u00f3gios a cada \\frac{\\Delta}{2*\\rho} \\frac{\\Delta}{2*\\rho} . Se \\Delta \\Delta \u00e9 a diferen\u00e7a m\u00e1xima entre rel\u00f3gios, ent\u00e3o ap\u00f3s o uma mensagem ser enviada com timestamp t t , at\u00e9 \\Delta \\Delta depois, outro processo, atrasado em rela\u00e7\u00e3o ao primeiro, poder\u00e1 enviar uma mensagem com timestamp t' < t t' < t . Tal mensagem pode demorar at\u00e9 \\tau \\tau para ser entregue \u00e0 r\u00e9plica, ou seja, no instante t + \\tau + \\Delta t + \\tau + \\Delta , do ponto de vista do primeiro cliente. Se a r\u00e9plica estiver sincronizada com cliente, ent\u00e3o se esperar at\u00e9 t + \\tau + \\Delta t + \\tau + \\Delta para executar o comando, o far\u00e1 de forma segura. Se estiver atrasada em rela\u00e7\u00e3o ao primeiro cliente, ent\u00e3o acabar\u00e1 por esperar al\u00e9m do necess\u00e1rio, mas sem violar a corretude do sistema. Finalmente, se a r\u00e9plica estiver adiantada em rela\u00e7\u00e3o ao primeiro cliente, ent\u00e3o seu rel\u00f3gio alcan\u00e7ar\u00e1 t + \\tau + \\Delta t + \\tau + \\Delta antes do rel\u00f3gio do primeiro cliente, mas isso n\u00e3o \u00e9 um problema. Isto porqu\u00ea, o \u00faltimo instante em que o cliente 2 poder\u00e1 enviar uma mensagem com timestamp t' < t t' < t \u00e9 o instante em que o rel\u00f3gio da r\u00e9plica marcar t + \\Delta t + \\Delta , e portanto dever\u00e1 tamb\u00e9m ser recebido at\u00e9 que o mesmo rel\u00f3gio marque t + \\tau + \\Delta t + \\tau + \\Delta . Ordena\u00e7\u00e3o de Requisi\u00e7\u00f5es Rel\u00f3gios dessincronizados \\tau \\tau . \\Delta \\Delta O \u00faltimo instante em que qualquer mensagem com timestamp t' < t t' < t pode ser recebido pela r\u00e9plica \u00e9 t+\\tau + \\Delta t+\\tau + \\Delta , pois qualquer mensagem recebida em t''> t+\\tau + \\Delta' t''> t+\\tau + \\Delta' , precisa ter sido enviada ap\u00f3s t+\\Delta t+\\Delta , e portanto ter\u00e1 timestamp > t > t . O mesmo racioc\u00ednio pode ser usado para definir um protocolo de acesso recursos para os quais leases s\u00e3o distribu\u00eddos, onde um lease \u00e9 uma permiss\u00e3o de acesso durante uma janela de tempo, emitida por um coordenador (possivelmente eleito usando os algoritmos vistos anteriormente), e \\Delta \\Delta \u00e9 o m\u00e1ximo de dessincronismo entre os rel\u00f3gios. O seguinte protocolo resolve este problema: Lease \\Delta \\Delta - dessincroniza\u00e7\u00e3o m\u00e1xima. Ao receber um lease para a janela de tempo t_1 t_1 a t_2 t_2 espera at\u00e9 t_1 + \\Delta t_1 + \\Delta usa o recurso at\u00e9 t_2 t_2 . Se rel\u00f3gio estiver adiantado em rela\u00e7\u00e3o ao cliente anterior, vai achar que \u00e9 t_1+\\Delta t_1+\\Delta enquanto o anterior acha que \u00e9 t_1 t_1 ; exclus\u00e3o m\u00fatua garantida. Se rel\u00f3gio estiver atrasado em rela\u00e7\u00e3o ao cliente anterior, vai achar que \u00e9 t_1 - \\Delta t_1 - \\Delta , e continua esperando, enquanto ele acha que j\u00e1 \u00e9 t_1 t_1 e para de usar; exclus\u00e3o m\u00fatua garantida. Recurso fica ocioso por \\Delta \\Delta , em m\u00e9dia, a cada lease. Devido ao alto custo de se manter o recurso n\u00e3o utilizado, \\Delta \\Delta deve ser feito t\u00e3o pequeno quanto poss\u00edvel. Leia Google True Time e Spanner para como o Google consegue manter a diferen\u00e7a em sub milisegundos, usando rel\u00f3gios at\u00f4micos dentro de seus datacenters e um API para gera\u00e7\u00e3o de timestamps. Tempo L\u00f3gico Rel\u00f3gios l\u00f3gicos Nas solu\u00e7\u00f5es anteriores, um n\u00f3 precisa esperar por muito tempo antes de usar um recurso. E se ele aprendesse antes que os outros n\u00f3s n\u00e3o far\u00e3o requisi\u00e7\u00f5es? Que n\u00e3o haver\u00e3o sobreposi\u00e7\u00f5es de requisi\u00e7\u00f5es? E se houvesse um rel\u00f3gio que avan\u00e7asse n\u00e3o com o tempo, mas com eventos interessantes do sistema? Esta \u00e9 a ideia dos rel\u00f3gios l\u00f3gicos . Rel\u00f3gios L\u00f3gicos Envio e recep\u00e7\u00e3o (e possivelmente outros eventos) fazem o rel\u00f3gio ``ticar''. Processos podem usar este rel\u00f3gio para concordar na ordem dos eventos, mesmo que n\u00e3o no instante do evento. N\u00e3o h\u00e1 fonte da verdade em termos de tempo. Cada processo mant\u00e9m seu pr\u00f3prio rel\u00f3gio que pode ser relacionado com rel\u00f3gios de outros processos. Para chegarmos aos rel\u00f3gios l\u00f3gicos, precisamos primeiro entender a rela\u00e7\u00e3o Happened-Before , proposta por Leslie Lamport em Time, Clocks and the Ordering of Events in a Distributed System. July 5, 1978 , que lhe rendeu um Pr\u00eamio Turing em 2014 . Neste artigo, se estabelece o vocabul\u00e1rio para falar sobre ordem de eventos em um sistema computacional, em especial um distribu\u00eddo. Happened-Before a \\rightarrow b a \\rightarrow b : evento a a aconteceu antes do evento b b Considerando um \u00fanico processo (thread): Se a a foi executado antes de b b no processo, ent\u00e3o a \\rightarrow b a \\rightarrow b . Considerando dois processos: Se a a \u00e9 o envio de uma mensagem e b b sua recep\u00e7\u00e3o, ent\u00e3o a \\rightarrow b a \\rightarrow b . Transitividade faz sentido: Se a \\rightarrow b a \\rightarrow b e b \\rightarrow c b \\rightarrow c , ent\u00e3o a \\rightarrow c a \\rightarrow c Esta rela\u00e7\u00e3o captura a causalidade entre eventos. Isto \u00e9, se a \\rightarrow b a \\rightarrow b ent\u00e3o a a potencialmente causou b b ( a a precede b b em uma ordem causal). Note que se a \\rightarrow b a \\rightarrow b \u00e9 falso e b \\rightarrow a b \\rightarrow a \u00e9 falso, ent\u00e3o a a e b b s\u00e3o concorrentes . Se capturarmos a causalidade de eventos, podemos usar esta informa\u00e7\u00e3o para ordenar o se processamento, de forma a fazer sentido. Considere o seguinte exemplo: TODO: Exemplo e emails com pergunta e respostas. Para que computadores possam usar a causalidade, precisamos capturar a rela\u00e7\u00e3o de acontecer antes em um sistema. Lamport prop\u00f4s uma tal forma, que denominou rel\u00f3gio l\u00f3gico, mas que hoje \u00e9 conhecido universalmente como Rel\u00f3gios de Lamport. Estes rel\u00f3gios permitem associar um timestamp a eventos de forma a se garantir a seguinte propriedade: * seja e e um evento * seja C(e) C(e) o valor do rel\u00f3gio l\u00f3gico quando associado a e e * se a \\rightarrow b a \\rightarrow b ent\u00e3o C(a) < C(b) C(a) < C(b) Mas como definir a fun\u00e7\u00e3o C C ? Experimentemos a seguinte defini\u00e7\u00e3o: * Seja c_p c_p um contador em p p com valor inicialmente igual a 0. * C(e) = c++ C(e) = c++ no momento em que e e ocorreu. * Usamos como $ < $ a rela\u00e7\u00e3o normal de inteiros. Assim, cada processo conta os eventos executados localmente. Veja um exemplo desta defini\u00e7\u00e3o em a\u00e7\u00e3o. !(LC - Primeira tentativa)(imagess/lc_cont.png) \u00c9 verdade neste cen\u00e1rio que se a \\rightarrow b a \\rightarrow b ent\u00e3o C(a) < C(b) C(a) < C(b) ? Observe com aten\u00e7\u00e3o os eventos f f e k k . Para estes, a regra n\u00e3o \u00e9 respeitada. Para que seja, precisamos garantir que, na recep\u00e7\u00e3o de uma mensagem, os contadores sejam atualizados para que sejam maiores tanto que os rel\u00f3gios dos eventos locais quanto dos eventos que antecederam o envio da mensagem sendo recebida. Com este ajuste, temos os Rel\u00f3gios de Lamport. Lamport Clock Seja c_p c_p um contador em p p com valor inicialmente igual a 0. Se o evento e e \u00e9 uma opera\u00e7\u00e3o local, C(e) = ++c C(e) = ++c no momento em que e e ocorreu. Se o evento e e \u00e9 o envio de uma mensagem, ent\u00e3o C(e) C(e) \u00e9 enviado com a mensagem como seu timestamp. Se o evento e e \u00e9 a recep\u00e7\u00e3o de uma mensagem com timestamp ts ts , ent\u00e3o C(e) = max(c,ts)+1 C(e) = max(c,ts)+1 . !(LC - Primeira tentativa)(imagess/lc_lamport.png) Neste caso, temos que para quaisquer eventos a,b a,b , se a \\rightarrow b a \\rightarrow b ent\u00e3o C(a) < C(b) C(a) < C(b) . TODO: Exemplo em que n\u00e3o \u00e9 bom o suficiente. Se a \\rightarrow b a \\rightarrow b ent\u00e3o C(a) < C(b) C(a) < C(b) . Contudo, a volta n\u00e3o \u00e9 verdade, isto \u00e9, se C(a) < C(b) C(a) < C(b) ent\u00e3o a \\rightarrow b a \\rightarrow b . Esta propriedade \u00e9 interessante na ordena\u00e7\u00e3o de eventos, pois evita que eventos concorrentes sejam ordenados. Entram os rel\u00f3gios vetoriais. Rel\u00f3gio vetorial Sejam n n processos. No processo p p * Seja c_p[i], 1 \\leq i \\leq n c_p[i], 1 \\leq i \\leq n um contador, inicialmente igual a 0. * Se o evento e e \u00e9 uma opera\u00e7\u00e3o local, c_p[p]++ c_p[p]++ e C(e) = c_p C(e) = c_p no momento em que e e ocorreu. * Se o evento e e \u00e9 o envio de uma mensagem, ent\u00e3o C(e) C(e) \u00e9 enviado com a mensagem como seu timestamp. * Se o evento e e \u00e9 a recep\u00e7\u00e3o de uma mensagem com timestamp ts ts de q q , ent\u00e3o * c_p[i] = max(c_p[i], ts[i]), i \\neq p c_p[i] = max(c_p[i], ts[i]), i \\neq p * c_p[p]++ c_p[p]++ * C(e) = c_p C(e) = c_p !(Rel\u00f3gio Vetorial)[images/lc_vc.png] Como dito, este rel\u00f3gio l\u00f3gico tem a seguinte propriedade: se a \\rightarrow b \\RightLeftArrow C(a) < C(b) a \\rightarrow b \\RightLeftArrow C(a) < C(b) . Mas como \u00e9 defido $ < $ para vetores? * V = V' \\iff V[i] = V'[i], 1 \\leq i \\leq n V = V' \\iff V[i] = V'[i], 1 \\leq i \\leq n * V \\leq V' \\iff V[i] \\leq V'[i], 1 \\leq i \\leq n V \\leq V' \\iff V[i] \\leq V'[i], 1 \\leq i \\leq n Sejam dois eventos e e e e' e' * Se e \\rightarrow e' \\iff V(e) < V(e') e \\rightarrow e' \\iff V(e) < V(e') * Se V(e) \\not\\leq V(e') V(e) \\not\\leq V(e') e V(e') \\not\\leq V(e) V(e') \\not\\leq V(e) , s\u00e3o concorrentes. Mas o que quer dizer c_p[q] = k c_p[q] = k ? Quer dizer que p p sabe que q q enviou k k mensagens. E da\u00ed? O que pode ser feito com isso? Com estes mecanismos \u00e9 poss\u00edvel implementar * Multicast Totalmente Ordenado: * Multicast: mensagens s\u00e3o enviadas de 1 para n (comunica\u00e7\u00e3o em grupo) * Totalmente Ordenado: todos os processos entregam as mensagens na mesma ordem * Multicast Causalmente Ordenado: * Causalmente Ordenado: uma mensagem s\u00f3 \u00e9 entregue se todas as que causalmente a precedem j\u00e1 foram entregues. Novamente voc\u00ea pergunta, e da\u00ed? Bem, com estas abstra\u00e7\u00f5es, podemos resolver problemas interessantes como o seguinte. Considere um programa qualquer, que se comporte de forma determin\u00edstica (isto \u00e9, dada uma mesma entrada, gera sempre uma mesma sa\u00edda). Como todo programa, este \u00e9 uma m\u00e1quina de estados, com a peculiaridade de ser determin\u00edstica. Logo, se tivermos v\u00e1rias c\u00f3pias deste programa, executando em locais distintos, mas garantirmos que cada c\u00f3pia ver\u00e1 exatamente a mesma entrada de dados, ent\u00e3o garantiremos que todas as c\u00f3pias transitar\u00e3o pelos mesmos estados e chegar\u00e3o ao mesmo estado final. Acontece que multicast totalmente ordenado pode garantir exatamente isso, que todas as c\u00f3pias receber\u00e3o a mesma entrada. !(State Machine Replication)[images/06-11.png] Esta t\u00e9cnica \u00e9 conhecida como Replica\u00e7\u00e3o de Ma\u00e1quinas de Estados (em ingl\u00eas, ( State Machine Replication )[ https://en.wikipedia.org/wiki/State_machine_replication ]), ou pelo menos o seu princ\u00edpio. Mas como podemos implementar estas primitivas de multicast usando rel\u00f3gios l\u00f3gicos? Considere o seguinte algoritmo. Multicast totalmente ordenado Fila com prioridade em cada processo. Mensagens s\u00e3o enviadas a todos os processos e colocadas em uma fila local. Mensagens recebidas s\u00e3o colocadas na fila local e ack \u00e9 enviado de volta. p p s\u00f3 entrega uma mensagem m m recebida de q q , com timestamp ts ts quando m m est\u00e1 na cabe\u00e7a da fila de p p Para cada processo q q , h\u00e1 uma mensagem m' m' de q q , ts' ts' , na fila de p p tal ts < ts' ts < ts' Canais confi\u00e1veis e FIFO. Multicast causalmente ordenado Mensagens s\u00e3o enviadas a todos os processos. p p incrementa c_p[p] c_p[p] somente no envio de mensagens. p p s\u00f3 entrega uma mensagem recebida de q q , com timestamp ts ts quando ts[q] = c_p[q]+1 ts[q] = c_p[q]+1 ts[k] \\leq c_p[k], k \\neq q ts[k] \\leq c_p[k], k \\neq q \\includegraphics[width=.5\\textwidth]{images/06-13} Considere c_{P_2}[0,2,2] c_{P_2}[0,2,2] e ts=[1,3,0] ts=[1,3,0] , de P_0 P_0 . O que P_2 P_2 est\u00e1 esperando? Como age ao receber mensagem com ts ts ? Exclusao M\u00fatua Revisitada Retorno \u00e0 exclus\u00e3o m\u00fatua TODO: (Algoritmos de Exclu\u00e3o m\u00fatua baeados em LC)[ http://www.cs.cmu.edu/~dga/15-440/F10/lectures/Distributed-Mutual-Exclusion-slides.pdf ] TODO: Algoritmo de Lamport, Ricart e agrawalla TODO: Algoritmo de (Maekawa)[ https://www.coursera.org/learn/cloud-computing-2/lecture/GMHYN/2-4-maekawas-algorithm-and-wrap-up ] Rel\u00f3gios H\u00edbridos TODO: (Google TrueTime)[ https://cloud.google.com/spanner/docs/true-time-external-consistency ) Hibrid Logical Clocks !(Hibrid Logical Clock)[images/lc_hybrid] Onde se l\u00ea 3,13, leia-se 3,10,3. (Fonte)( http://muratbuffalo.blogspot.com.br/2014/07/hybrid-logical-clocks.html ) Interceptadores !(Transparente para a aplica\u00e7\u00e3o)[images/06-10] Explain that stuff. \u21a9 Distor\u00e7\u00e3o mec\u00e2nica gera corrente el\u00e9trica e submiss\u00e3o a uma corrente el\u00e9trica gera uma distor\u00e7\u00e3o mec\u00e2nica. \u21a9 32768 \u00e9 a primeira pot\u00eancia de 2 maior que 20000, a maior frequ\u00eancia sonora aud\u00edvel aos seres humanos. \u21a9","title":"Tempo"},{"location":"teaching/gbc074gsi028/time/#tempo","text":"Neste cap\u00edtulo discutiremos como o tempo \u00e9 importante no desenvolvimento de sistemas distribu\u00eddos. Comecemos por analisar o funcionamento de uma aplica\u00e7\u00e3o distribu\u00edda muito comum, o armazenamento de arquivos na nuvem, sincronizado com o sistema de arquivos local. Alguns exemplos do munto real s\u00e3o DropBox, Box, Google Drive and OneDrive; chamemos este servi\u00e7o genericamente de cloud-drive . Se um mesmo arquivo no cloud-drive \u00e9 modificado em duas m\u00e1quinas diferentes, enquanto as mesmas est\u00e3o desconectadas, o qu\u00ea acontece quando elas se reconectam \u00e0 Internet? Mais especificamente, quando as duas m\u00e1quins se conectam e enviam suas vers\u00f5es do arquivo modificado para o servidor, sendo que ambas foram geradas a partir de um ancestral comum, qual vers\u00e3o deve ser armazenada e qual deve ser descartada? Uma possibilidade simples \u00e9 sempre aceitar o cada nova vers\u00e3o como uma modifica\u00e7\u00e3o do arquivo. Assim, efetivamente, quando a primeira vers\u00e3o for entregue, ser\u00e1 aceita e viver\u00e1 momentaneamente at\u00e9 que a outra vers\u00e3o seja recebida e a sobrescreva. Mas imagine que esteja usando o cloud-drive para registrar a anterioridade de ideias (quem pensou nisso primeiro?), registrando-as em arquivos salvos no cloud-drive. Neste caso, o sistema poderia dar anterioridade \u00e0 entrada errada, que chegou por \u00faltimo. Se invertermos a abordagem, o cloud-drive poderia manter vers\u00f5es antigas de um documento em detrimento de vers\u00f5es mais atualizadas, o que obviamente seria um problema para outros usos. Mas mesmo que manter a vers\u00e3o mais recente ou mais antiga fosse adequada, o problema \u00e9 mais fundamental que isso. Afinal, a ordem de chegada dos arquivos ao servidor n\u00e3o reflete necessariamente a ordem em que os arquivos foram criados. Assim, podemos pensar em outras alternativas de aproveitamento e descarte de arquivos baseadas na cria\u00e7\u00e3o do arquivo, e n\u00e3o em sua recep\u00e7\u00e3o. Contudo, o hor\u00e1rio de cria\u00e7\u00e3o de um arquivo \u00e9 relativo a onde foi criado e n\u00e3o ao grupo de processos que comp\u00f5e o sistema, o que pode levar uma modifica\u00e7\u00e3o que tenha acontecido mais tarde, do ponto de vista de um observador externo, a ter um hor\u00e1rio de cria\u00e7\u00e3o oficial anterior. Uma terceira abordagem \u00e9 gerar uma terceira vers\u00e3o, com a \"soma\" das duas conflitantes. Para gerar esta terceira vers\u00e3o, faz mais sentido quebrar os arquivos em opera\u00e7\u00f5es de modifica\u00e7\u00e3o , e executar as opera\u00e7\u00f5es de forma a chegar ao resultado final. O problema permanece, pois as opera\u00e7\u00f5es agora devem ser ordenadas. Em qualquer destas linhas de atua\u00e7\u00e3o, voc\u00ea tem em m\u00e3os um conflito para resolver, e automatizar a resolu\u00e7\u00e3o do mesmo \u00e9 muito complicado. \u00c9 por isso que o Dropbox, por exemplo, deixa os dois arquivos para que o usu\u00e1rio analize e decida o que fazer, que servidores git permitem a submiss\u00e3o de apenas um conjunto de opera\u00e7\u00f5es por vez para um mesmo reposit\u00f3rio/branch, e o Perforce trabalha com locks de arquivos. Dada esta problem\u00e1tica, podemos simplificar a quest\u00e3o em nossas m\u00e3os. Pergunta Se duas opera\u00e7\u00f5es originadas em clientes s\u00e3o enviadas ao servidor, qual deve ser executada primeiro? Alguns sistemas tentam resolver automaticamente os conflitos; o CassandraDB, por exemplo, usa last write wins ou latest version wins , onde last \u00e9 definido em termos do rel\u00f3gio do cliente. Acontece que a maior parte dos nossos sistemas n\u00e3o d\u00e1 garantias de tempo na entrega de mensagens ou processamento de instru\u00e7\u00f5es. Assim, temos novo problema: Pergunta Como determinar qual foi enviada primeiro, em um sistema ass\u00edncrono? Assim, precisamos encontrar uma fonte de tempo confi\u00e1vel e distribu\u00edda , e o desafio come\u00e7a com o entendimento de rel\u00f3gios f\u00edsicos.","title":"Tempo"},{"location":"teaching/gbc074gsi028/time/#relogios-fisicos","text":"Quando falamos em rel\u00f3gios, provavelmente falamos sobre rel\u00f3gios a base de quartzo. Para uma introdu\u00e7\u00e3o r\u00e1pida, assista o seguinte v\u00eddeo. Em suma, um rel\u00f3gio de quartzo consiste em um diapaz\u00e3o de quartzo cortado a laser que, devido ao efeito Piezoel\u00e9trico 2 e sua forma particular, vibra a 32768 = 2^{15} 32768 = 2^{15} Hz 3 , e em um contador que conta cada vibra\u00e7\u00e3o, medindo a passagem do tempo. Estes rel\u00f3gios erram na medi\u00e7\u00e3o do tempo em no m\u00e1ximo \u00bds por dia , desde que operem dentro da faixa de 5 a 35C, mas isso tamb\u00e9m muda com a idade do cristal, a corrente el\u00e9trica passando por ele e tamb\u00e9m devido a imperfei\u00e7\u00f5es no cristal 1 . Computadores em geral usam rel\u00f3gios de quartzo, por serem baratos, como base de um rel\u00f3gio mantido em software. Isto \u00e9, do ponto de vista de um computador comum, o tempo \u00e9 medido com base em um rel\u00f3gio quartzo, cujos incrementos s\u00e3o capturados em um contador; o contador gera interrup\u00e7\u00f5es em intervalos programados (e.g., Linux >2.6 usa 250Hz por padr\u00e3o; m\u00e1ximo 1000Hz) e as interrup\u00e7\u00f5es causam ajustes em um rel\u00f3gio em software , um contador indireto C C . Precis\u00e3o Dado a frequ\u00eancia padr\u00e3o de 250Hz, medi\u00e7\u00f5es de tempo menores que 4ms s\u00e3o altamente imprecisas. Como medir o tempo gasto em uma fun\u00e7\u00e3o do seu c\u00f3digo? Este rel\u00f3gio em software, C C , que usa um rel\u00f3gio de quartzo, impreciso, pode marcar a passagem do tempo com erro para mais ou para menos. Embora o erro exato do rel\u00f3gio seja desconhecido, o mesmo \u00e9 limitado probabilisticamente. A taxa de erro \u00e9 denominada drift , \u00e9 representada por \\rho \\rho . Assumindo um rel\u00f3gio perfeito, t t , temos que 1 - \\rho \\leq \\frac{dC}{dt} \\leq 1 + \\rho 1 - \\rho \\leq \\frac{dC}{dt} \\leq 1 + \\rho . Assim, um \\rho \\rho de 0.1 implica em um erro de mais ou menos 10%; a figura a seguir mostra a faixa em que C C pode operar e que o erro em rela\u00e7\u00e3o a t t vai aumentando com a passagem do tempo. Embora adequado para humanos, o erro dos rel\u00f3gios de quartzo \u00e9 inaceit\u00e1vel em algumas opera\u00e7\u00f5es computacionais. Felizmente, os erros do destes rel\u00f3gios podem ser minimizados ao ponto de termos um erros menores que 1s em milh\u00f5es de anos, nos dispositivos conhecidos como rel\u00f3gios at\u00f4micos . Embora muito bom, o rel\u00f3gio at\u00f4mico tamb\u00e9m n\u00e3o \u00e9 perfeito e, devido a v\u00e1rias raz\u00f5es, pode levar tamb\u00e9m a erros. Mas o qu\u00ea mais se pode fazer no sentido de melhorar a precis\u00e3o dos rel\u00f3gios? A resposta est\u00e1 no UTC.","title":"Rel\u00f3gios F\u00edsicos"},{"location":"teaching/gbc074gsi028/time/#tempo-universal-coordenado","text":"O UTC, de uma mistura dos nomes em Ingl\u00eas e Franc\u00eas do Tempo Universal Coordenado, um padr\u00e3o global para coordena\u00e7\u00e3o da medi\u00e7\u00e3o da passagem do tempo. Segundo o UTC, o sol est\u00e1 a pino \u00e0s 12:00 na latitude 0, ou a no m\u00e1ximo 1s deste instante; ao redor da latitude 0 grau estabelece-se uma faixa em que todos os pontos tem o mesmo hor\u00e1rio, e outras 23 faixas como esta com deslocamentos consecutivos de +-1 hora. Estas faixas, conhecidas coloquialmente como fusos, sofrem ajustes por fatores pol\u00edticos; a China, por exemplo, apesar de seu tamanho, est\u00e1 toda dentro de um mesmo hor\u00e1rio, \"correto\" para Beijing. Mas como o UTC \u00e9 definido? Com base no TAI, Tempo At\u00f4mico Internacional, calculado como a m\u00e9dia dos valores de rel\u00f3gios at\u00f4micos espalhados pelo globo. O TAI mede perfeitamente a passagem do tempo, mas como a rota\u00e7\u00e3o da terra \u00e9 irregular, medir perfeitamente n\u00e3o \u00e9 o adequado. Assim, o UTC leva em considera\u00e7\u00e3o o fato do dia n\u00e3o ter exatamente 24 horas e, de fato, n\u00e3o ter dura\u00e7\u00e3o constante. Por exemplo, ap\u00f3s um grande terremoto o centro de massa da terra pode ser alterado e a rota\u00e7\u00e3o ter sua velocidade aumentada ou diminu\u00edda. UTC Nearly all UTC days contain exactly 86,400 SI seconds with exactly 60 seconds in each minute. However, because the mean solar day is slightly longer than 86,400 SI seconds, occasionally the last minute of a UTC day is adjusted to have 61 seconds. The extra second is called a leap second. It accounts for the grand total of the extra length (about 2 milliseconds each) of all the mean solar days since the previous leap second. The last minute of a UTC day is permitted to contain 59 seconds to cover the remote possibility of the Earth rotating faster, but that has not yet been necessary.","title":"Tempo Universal Coordenado"},{"location":"teaching/gbc074gsi028/time/#sincronizacao-de-relogios","text":"Dado o UTC, temos ent\u00e3o uma refer\u00eancia de tempo adequada para uso em sistemas computacionais, colocamos nova pergunta: Se o rel\u00f3gio se dist\u00e2ncia da medida correta da passagem do tempo, \u00e9 poss\u00edvel corrigir este distanciamento, sincronizando-o com uma fonte correta, da qual UTC \u00e9 nossa melhor aproxima\u00e7\u00e3o, para que todos percebam a mesma passagem do tempo? Embora a resposta seja negativa, no sentido de que n\u00e3o \u00e9 poss\u00edvel alcan\u00e7ar sincroniza\u00e7\u00e3o perfeita, nada nos impede de fazer um melhor esfor\u00e7o e, neste sentido, tamb\u00e9m temos que nos perguntar qual a frequ\u00eancia de sincroniza\u00e7\u00e3o? Frequ\u00eancia de Sincroniza\u00e7\u00e3o Como garantir que dois rel\u00f3gios com erro m\u00e1ximo igual a \\rho \\rho n\u00e3o diferir\u00e3o em mais que \\delta \\delta unidades de tempo? Resposta Sincronize pelo menos a cada \\frac{\\delta}{2\\rho} \\frac{\\delta}{2\\rho} segundos. E se tivermos muitos rel\u00f3gios a serem sincronizados, o problema \u00e9 mais dif\u00edcil? Frequ\u00eancia de Sincroniza\u00e7\u00e3o Como garantir que dois rel\u00f3gios quaisquer, em um sistema com n n rel\u00f3gios, todos com erro m\u00e1ximo igual a \\rho \\rho , n\u00e3o diferir\u00e3o em mais que \\delta \\delta unidades de tempo? Resposta Se todos sincronizarem com a mesma fonte, a cada \\frac{\\delta}{2\\rho} \\frac{\\delta}{2\\rho} segundos, seja o n\u00f3 n1 aquele com maior erro em rela\u00e7\u00e3o \u00e0 fonte e n2 aquele com maior erro em rela\u00e7\u00e3o a n1. Como ambos tem um erro m\u00e1ximo de \\delta \\delta em rela\u00e7\u00e3o \u00e0 fonte, o erro m\u00e1ximo entre os dois n\u00f3s \u00e9 2\\delta 2\\delta . Como este erro \u00e9 o dobro do desejado, basta dobrar a frequ\u00eancia de sincroniza\u00e7\u00e3o para cortar o erro pela metade. Vejamos um exemplo: \\rho = 0,1 \\rho = 0,1 \\delta \\delta = 1s Ap\u00f3s 10s, um n\u00f3 com estas caracter\u00edsticas se dessincronizaria em, no m\u00e1ximo, 1s em rela\u00e7\u00e3o ao UTC. Como cada n\u00f3 poderia estar errando em \"dire\u00e7\u00f5es\" diferentes, ap\u00f3s 5s, um n\u00f3 poderia se adiantar em 0,5s enquanto o outro se atrasa pela mesma quantidade de tempo, somando 1s de diferen\u00e7a. Logo, eles tem que se sincronizar a cada 5s, i.e, \\frac{\\delta}{2\\rho} = \\frac{1s}{2 \\times 0,1} = \\frac{1s}{0,2} = 5s \\frac{\\delta}{2\\rho} = \\frac{1s}{2 \\times 0,1} = \\frac{1s}{0,2} = 5s Como \u00faltima parada antes de come\u00e7armos a falar sobre a sincroniza\u00e7\u00e3o em si, devemos estabelecer alguns cuidados a serem tomados no processo. Nunca voltar no tempo - isso poderia levar a um dado ter data de edi\u00e7\u00e3o anterior a data de cria\u00e7\u00e3o. Ajustes graduais - acelere ou desacelere o rel\u00f3gio (em software) Diminua/Aumente frequ\u00eancia de interrup\u00e7\u00e3o para atrasar/adiantar rel\u00f3gio Diminua/Aumente incremento com cada interrup\u00e7\u00e3o Ajustes peri\u00f3dicos para fazer curvas convergirem. Corre\u00e7\u00e3o ap\u00f3s dormir ser\u00e1 mais dr\u00e1stica Agora que voc\u00ea j\u00e1 tem uma fonte confi\u00e1vel de tempo, o UTC, e sabe com que frequ\u00eancia sincronizar os rel\u00f3gios, s\u00f3 nos falta fazer a sincroniza\u00e7\u00e3o. Contudo, falta ainda definir o protocolo pelo qual a sincroniza\u00e7\u00e3o \u00e9 feita e exatamente com quem, uma vez que simpleste UTC \u00e9 muito gen\u00e9rico. Comecemos com vetor \"pr\u00f3ximo\" do UTC, os rel\u00f3gios at\u00f4micos em sat\u00e9lites GPS.","title":"Sincroniza\u00e7\u00e3o de Rel\u00f3gios"},{"location":"teaching/gbc074gsi028/time/#usos-de-relogios-sincronizados","text":"autentica\u00e7\u00e3o termina\u00e7\u00e3o de transa\u00e7\u00f5es aloca\u00e7\u00e3o de ``leases''. outros exemplos, Liskov, B. Distrib Comput (1993) 6: 211. doi:10.1007/BF02242709 Um exemplo interessante \u00e9 a ordena\u00e7\u00e3o de eventos em um banco de dados. Para entender este problema, considere o seguinte cen\u00e1rio com um Sistema Banc\u00e1rio Se os comandos chegam primeiro para a replica mais pr\u00f3xima e s\u00e3o executados na ordem em que chegam, temos inconsist\u00eancias entre as r\u00e9plicas (p.e., assuma que update 1 \u00e9 \"atualize para 10\" e 2 \u00e9 \"atualize para 20\") Assim, precisamos ordenar os comandos! Nos foquemos em apenas uma r\u00e9plica. Assuma que rel\u00f3gios est\u00e3o perfeitamente sincronizados, que o tempo de propaga\u00e7\u00e3o m\u00e1ximo de uma mensagem \u00e9 \\tau \\tau , e que toda mensagem/update carrega o timestamp de quando foi enviada consigo. Considere o seguinte proposta: R\u00e9plicas processam mensagens na ordem que foram enviadas, o que pode ser identificado pelos seus timestamps. Em outras palavras, ao receber uma mensagem com timestamp t t , uma r\u00e9plica espera at\u00e9 ter certeza de que","title":"Usos de rel\u00f3gios sincronizados"},{"location":"teaching/gbc074gsi028/time/#tempo-logico","text":"","title":"Tempo L\u00f3gico"},{"location":"teaching/gbc074gsi028/time/#relogios-logicos","text":"Nas solu\u00e7\u00f5es anteriores, um n\u00f3 precisa esperar por muito tempo antes de usar um recurso. E se ele aprendesse antes que os outros n\u00f3s n\u00e3o far\u00e3o requisi\u00e7\u00f5es? Que n\u00e3o haver\u00e3o sobreposi\u00e7\u00f5es de requisi\u00e7\u00f5es? E se houvesse um rel\u00f3gio que avan\u00e7asse n\u00e3o com o tempo, mas com eventos interessantes do sistema? Esta \u00e9 a ideia dos rel\u00f3gios l\u00f3gicos .","title":"Rel\u00f3gios l\u00f3gicos"},{"location":"teaching/gbc074gsi028/time/#lamport-clock","text":"Seja c_p c_p um contador em p p com valor inicialmente igual a 0. Se o evento e e \u00e9 uma opera\u00e7\u00e3o local, C(e) = ++c C(e) = ++c no momento em que e e ocorreu. Se o evento e e \u00e9 o envio de uma mensagem, ent\u00e3o C(e) C(e) \u00e9 enviado com a mensagem como seu timestamp. Se o evento e e \u00e9 a recep\u00e7\u00e3o de uma mensagem com timestamp ts ts , ent\u00e3o C(e) = max(c,ts)+1 C(e) = max(c,ts)+1 . !(LC - Primeira tentativa)(imagess/lc_lamport.png) Neste caso, temos que para quaisquer eventos a,b a,b , se a \\rightarrow b a \\rightarrow b ent\u00e3o C(a) < C(b) C(a) < C(b) . TODO: Exemplo em que n\u00e3o \u00e9 bom o suficiente. Se a \\rightarrow b a \\rightarrow b ent\u00e3o C(a) < C(b) C(a) < C(b) . Contudo, a volta n\u00e3o \u00e9 verdade, isto \u00e9, se C(a) < C(b) C(a) < C(b) ent\u00e3o a \\rightarrow b a \\rightarrow b . Esta propriedade \u00e9 interessante na ordena\u00e7\u00e3o de eventos, pois evita que eventos concorrentes sejam ordenados. Entram os rel\u00f3gios vetoriais.","title":"Lamport Clock"},{"location":"teaching/gbc074gsi028/time/#relogio-vetorial","text":"Sejam n n processos. No processo p p * Seja c_p[i], 1 \\leq i \\leq n c_p[i], 1 \\leq i \\leq n um contador, inicialmente igual a 0. * Se o evento e e \u00e9 uma opera\u00e7\u00e3o local, c_p[p]++ c_p[p]++ e C(e) = c_p C(e) = c_p no momento em que e e ocorreu. * Se o evento e e \u00e9 o envio de uma mensagem, ent\u00e3o C(e) C(e) \u00e9 enviado com a mensagem como seu timestamp. * Se o evento e e \u00e9 a recep\u00e7\u00e3o de uma mensagem com timestamp ts ts de q q , ent\u00e3o * c_p[i] = max(c_p[i], ts[i]), i \\neq p c_p[i] = max(c_p[i], ts[i]), i \\neq p * c_p[p]++ c_p[p]++ * C(e) = c_p C(e) = c_p !(Rel\u00f3gio Vetorial)[images/lc_vc.png] Como dito, este rel\u00f3gio l\u00f3gico tem a seguinte propriedade: se a \\rightarrow b \\RightLeftArrow C(a) < C(b) a \\rightarrow b \\RightLeftArrow C(a) < C(b) . Mas como \u00e9 defido $ < $ para vetores? * V = V' \\iff V[i] = V'[i], 1 \\leq i \\leq n V = V' \\iff V[i] = V'[i], 1 \\leq i \\leq n * V \\leq V' \\iff V[i] \\leq V'[i], 1 \\leq i \\leq n V \\leq V' \\iff V[i] \\leq V'[i], 1 \\leq i \\leq n Sejam dois eventos e e e e' e' * Se e \\rightarrow e' \\iff V(e) < V(e') e \\rightarrow e' \\iff V(e) < V(e') * Se V(e) \\not\\leq V(e') V(e) \\not\\leq V(e') e V(e') \\not\\leq V(e) V(e') \\not\\leq V(e) , s\u00e3o concorrentes. Mas o que quer dizer c_p[q] = k c_p[q] = k ? Quer dizer que p p sabe que q q enviou k k mensagens. E da\u00ed? O que pode ser feito com isso? Com estes mecanismos \u00e9 poss\u00edvel implementar * Multicast Totalmente Ordenado: * Multicast: mensagens s\u00e3o enviadas de 1 para n (comunica\u00e7\u00e3o em grupo) * Totalmente Ordenado: todos os processos entregam as mensagens na mesma ordem * Multicast Causalmente Ordenado: * Causalmente Ordenado: uma mensagem s\u00f3 \u00e9 entregue se todas as que causalmente a precedem j\u00e1 foram entregues. Novamente voc\u00ea pergunta, e da\u00ed? Bem, com estas abstra\u00e7\u00f5es, podemos resolver problemas interessantes como o seguinte. Considere um programa qualquer, que se comporte de forma determin\u00edstica (isto \u00e9, dada uma mesma entrada, gera sempre uma mesma sa\u00edda). Como todo programa, este \u00e9 uma m\u00e1quina de estados, com a peculiaridade de ser determin\u00edstica. Logo, se tivermos v\u00e1rias c\u00f3pias deste programa, executando em locais distintos, mas garantirmos que cada c\u00f3pia ver\u00e1 exatamente a mesma entrada de dados, ent\u00e3o garantiremos que todas as c\u00f3pias transitar\u00e3o pelos mesmos estados e chegar\u00e3o ao mesmo estado final. Acontece que multicast totalmente ordenado pode garantir exatamente isso, que todas as c\u00f3pias receber\u00e3o a mesma entrada. !(State Machine Replication)[images/06-11.png] Esta t\u00e9cnica \u00e9 conhecida como Replica\u00e7\u00e3o de Ma\u00e1quinas de Estados (em ingl\u00eas, ( State Machine Replication )[ https://en.wikipedia.org/wiki/State_machine_replication ]), ou pelo menos o seu princ\u00edpio. Mas como podemos implementar estas primitivas de multicast usando rel\u00f3gios l\u00f3gicos? Considere o seguinte algoritmo.","title":"Rel\u00f3gio vetorial"},{"location":"teaching/gbc074gsi028/time/#exclusao-mutua-revisitada","text":"Retorno \u00e0 exclus\u00e3o m\u00fatua TODO: (Algoritmos de Exclu\u00e3o m\u00fatua baeados em LC)[ http://www.cs.cmu.edu/~dga/15-440/F10/lectures/Distributed-Mutual-Exclusion-slides.pdf ] TODO: Algoritmo de Lamport, Ricart e agrawalla TODO: Algoritmo de (Maekawa)[ https://www.coursera.org/learn/cloud-computing-2/lecture/GMHYN/2-4-maekawas-algorithm-and-wrap-up ]","title":"Exclusao M\u00fatua Revisitada"},{"location":"teaching/gbc074gsi028/time/#relogios-hibridos","text":"TODO: (Google TrueTime)[ https://cloud.google.com/spanner/docs/true-time-external-consistency )","title":"Rel\u00f3gios H\u00edbridos"},{"location":"teaching/gbc074gsi028/time/#hibrid-logical-clocks","text":"!(Hibrid Logical Clock)[images/lc_hybrid] Onde se l\u00ea 3,13, leia-se 3,10,3. (Fonte)( http://muratbuffalo.blogspot.com.br/2014/07/hybrid-logical-clocks.html )","title":"Hibrid Logical Clocks"},{"location":"teaching/gbc074gsi028/time/#interceptadores","text":"!(Transparente para a aplica\u00e7\u00e3o)[images/06-10] Explain that stuff. \u21a9 Distor\u00e7\u00e3o mec\u00e2nica gera corrente el\u00e9trica e submiss\u00e3o a uma corrente el\u00e9trica gera uma distor\u00e7\u00e3o mec\u00e2nica. \u21a9 32768 \u00e9 a primeira pot\u00eancia de 2 maior que 20000, a maior frequ\u00eancia sonora aud\u00edvel aos seres humanos. \u21a9","title":"Interceptadores"},{"location":"teaching/gsi009/","text":"Profiss\u00e3o em Sistemas de Informa\u00e7\u00e3o O objetivo desta disciplina \u00e9 preparar os discentes para atuarem com consci\u00eancia, \u00e9tica e responsabilidade na sociedade em geral e em seus ambientes de trabalho, de forma emp\u00e1tica e respeitosa ao pr\u00f3ximo, independentemente de qualquer fator, e de forma a minimizar impactos negativos e maximizar os positivos da tecnologia da informa\u00e7\u00e3o na sociedade e no ambiente. Se est\u00e1 interessado na disciplina, na forma de AARE, matricule-se e continue lendo. Caso contr\u00e1rio, volte no pr\u00f3ximo semestre quando, possivelmente, teremos atividades presenciais. Lembre-se, GSI009 \u00e9 uma disciplina obrigat\u00f3ria do curr\u00edculo. Se est\u00e1 lendo isto, ent\u00e3o assumo que se matriculou; \u00f3timo! Sua primeira fonte de informa\u00e7\u00e3o sobre esta disciplina \u00e9 este s\u00edtio, que conter\u00e1 notas de aula, atividades e apontadores para outros documentos e instru\u00e7\u00f5es de acesso. Al\u00e9m disso, usaremos a ferramenta Teams \u2122 da Microsoft para nossos encontros s\u00edncronos, atendimento a alunos e para comunica\u00e7\u00e3o em geral. Ap\u00f3s criar sua conta usando o email da UFU , cadastre-se na disciplina aqui . O controle de frequ\u00eancia nas atividades s\u00edncronas ser\u00e1 feito pelo relat\u00f3rio de presen\u00e7a apresentado pelo Teams, que diz exatamente quando entrou e quando saiu da reuni\u00e3o. Nas atividades ass\u00edncronas, o controle ser\u00e1 feito pela submiss\u00e3o de respostas \u00e0s atividades propostas, como question\u00e1rios. Semana 1 - 12/08/2020 Programa A disciplina abordar\u00e1 os t\u00f3picos definidos na ficha da disciplia, dispon\u00edvel no s\u00edtio do curso. O plano da disciplina, aula-a-aula est\u00e1 dispon\u00edvel aqui e na aba Arquivos no Teams. Avalia\u00e7\u00e3o Voc\u00eas ser\u00e3o avaliados de acordo com os crit\u00e9rios tamb\u00e9m dispon\u00edveis no plano. Para cada atividade do tipo X X , a nota N(X) N(X) da atividade ser\u00e1 calculada pela f\u00f3rmula N(X) = \\frac{N(X_1) + N(X_2) + ... + N(X_m)}{m} N(X) = \\frac{N(X_1) + N(X_2) + ... + N(X_m)}{m} onde N(X_i) N(X_i) \u00e9 a i i -\u00e9sima atividade do tipo X X , de um total de m m . Atividades Ass\u00edncronas Assista e leia a pelo menos os item marcados com o \u00edcone e ent\u00e3o responda aos question\u00e1rios da semana no Teams. Voc\u00ea deve cumprir as atividade at\u00e9 o fim do dia anterior ao da pr\u00f3xima atividade s\u00edncrona . Na \u00faltima semana, a atividade deve ser cumprida at\u00e9 a sexta-feira da mesma semana. Semin\u00e1rios Os alunos dever\u00e3o apresentar semin\u00e1rios, desenvolvidos em grupo, para seus colegas. O objetivo dos semin\u00e1ris \u00e9 estimular discuss\u00e3o sobre o t\u00f3pico em tela. Para isso, planeje seu semin\u00e1rio para que tenha dura\u00e7\u00e3o de 75 minutos , incluindo discuss\u00e3o; este \u00e9 um crit\u00e9rio de avalia\u00e7\u00e3o . Os semin\u00e1rios tem t\u00f3picos T\u00e9cnicos e N\u00e3o t\u00e9cnicos ; por serem mais dif\u00edceis de se preparar, os n\u00e3o t\u00e9cnicos acontecer\u00e3o por \u00faltimo. A escolha do t\u00f3pico ser\u00e1, em princ\u00edpio, livre, desde que cada t\u00f3pico tenha um quinto dos alunos da turma. Caso isso n\u00e3o aconte\u00e7a, a os grupos ser\u00e3o impostos. Sua apresenta\u00e7\u00e3o ser\u00e1 avaliada nos seguintes pontos: Conte\u00fado: Contextualiza\u00e7\u00e3o Import\u00e2ncia para o profissional da \u00e1rea Legisla\u00e7\u00e3o pertinente Referencial te\u00f3rico Algo mais: discuss\u00e3o, v\u00eddeo, din\u00e2mica, pessoas importantes... Postar os slides 2 dias antes da apresenta\u00e7\u00e3o via Teams Qualidade dos slides Al\u00e9m da apresenta\u00e7\u00e3o, voc\u00ea dever\u00e1 preparar um question\u00e1rio com quest\u00f5es pertinentes ao tema e que sejam abordados durante a apresenta\u00e7\u00e3o. Estes ser\u00e3o avaliados pelos crit\u00e9rios a seguir: Qualidade do quiz Perguntas pertinentes a quem se interessar pela \u00e1rea Perguntas em portugu\u00eas correto Entregar Quiz 2 dias antes da apresenta\u00e7\u00e3o Enviar formul\u00e1rio no Teams, somente para o professor Enviar gabarito em mensagem separada, somente para o professor. Question\u00e1rio deve ter 5 perguntas de m\u00faltiplas alternativas Cada pergunta deve ter 5 respostas Tema 1: Computa\u00e7\u00e3o Verde Todos ouvimos j\u00e1 ouvimos falar das altera\u00e7\u00f5es clim\u00e1ticas sendo causadas pela humanidade e independentemente de voc\u00ea aceitar o consenso (maioria de opini\u00f5es) dos especialistas sobre o fato ou ser um negacionista, o fato \u00e9 que a economia mundial aceita a ideia e tem tentado criar mecanismos para diminuir o nosso efeito no globo. Todos n\u00f3s j\u00e1 ouvimos falar tamb\u00e9m sobre como a culpa \u00e9 dos viajantes, dos ruminantes, e dos refrigerantes. Mas saiba que a computa\u00e7\u00e3o tem uma grande parcela da culpa. Algumas estimativas colocam em 14% as emiss\u00f5es devidas aos Data Centers at\u00e9 2040. Por isso, o t\u00f3pico da computa\u00e7\u00e3o ou TI verde est\u00e1 em voga. Sua miss\u00e3o, caso voc\u00ea decida aceit\u00e1-la, \u00e9 expandir na contextualiza\u00e7\u00e3o acima, discutir a computa\u00e7\u00e3o verde em seus aspectos econ\u00f4micos, legais e morais, com foco na atua\u00e7\u00e3o sua e de seus colegas na sociedade e no mercado de trabalho. Certifique-se de discutir, sem se limitar a, os seguintes pontos: Consumo energ\u00e9tico de datacenters Energia renov\u00e1vel Certifica\u00e7\u00f5es Carbon footprint Estrat\u00e9gias para implementa\u00e7\u00e3o Cidades inteligentes Legisla\u00e7\u00e3o Lixo eletr\u00f4nico Tema 2: Propriedade intelectual Para come\u00e7ar, pense nas seguintes quest\u00f5es: Question Se voc\u00ea compra um carro, pode modific\u00e1-lo? Rebaix\u00e1-lo? Mudar a cor? Se compra uma casa, pode modific\u00e1-la? Pode adicionar um quarto? Uma piscina? Se compra um computador, pode modific\u00e1-lo? Colocar mais mem\u00f3ria? Mudar o sistema operacional? Todas estas quest\u00f5es est\u00e3o ligadas ao tema da Propriedade Intelectual, um tema muito controverso. Se voc\u00ea compra, \u00e9 o dono, certo? Se \u00e9 o dono, deveria poder modificar, certo? Mas muitos dos produtos que compra n\u00e3o podem ser modificados, abertos, estudados, replicados. Como comprador, talvez voc\u00ea se sinta indignado. \u00c9 f\u00e1cil entender que n\u00e3o se pode copiar uma Ferrari, pois anos e anos foram dedicados ao seu desenvolvimento e n\u00e3o seria justo algu\u00e9m que n\u00e3o a Ferrari lucrar com isso . Mas ao mesmo tempo, copiar e assistir a um filme, \u00e9 algo in\u00f3cuo, certo? Ningu\u00e9m sofre perdas se voc\u00ea assistir a uma s\u00e9rie pirata, pois se voc\u00ea n\u00e3o o fizesse, a empresa que produziu o filme n\u00e3o ganharia nada de qualquer forma, certo? Errado. Mesmo que insignificante, piratear filmes \u00e9 crime . Mas vamos trazer o problema para mais pr\u00f3ximo de casa. E se falarmos de software? Dificilmente algum \"computeiro\" poderia se gabar de nunca ter instalado um software pirata, um sistema operacional. Tamb\u00e9m \u00e9 uma a\u00e7\u00e3o sem v\u00edtimas, certo? Mas como produtor de software, algo que \u00e9 muito facilmente replicado, talvez voc\u00ea sinta que qualquer um que use seu produto deveria pagar por ele. Ou talvez voc\u00ea sinta que todo software deva ser modific\u00e1vel, estud\u00e1vel e copi\u00e1vel? Neste semin\u00e1rio, seu objetivo \u00e9 discutir estas quest\u00f5es, inclusive mas n\u00e3o limitado aos seguintes pontos: Software Livre x Open Source O qu\u00ea s\u00e3o? Qual a filosofia por tr\u00e1s? Como ganhar dinheiro? Quem \u00e9 Richard Stallman? Propriedade intelectual Propriedade industrial Direitor autorais no Brasil Copyright e copyleft Patentes boas ou m\u00e1s? Registro de software Certificado de anterioridade Como fa\u00edsca para seu trabalho, considere os seguintes materiais. Richard Sennett: \u201cO gratuito significa sempre uma forma de domina\u00e7\u00e3o\u201d Tema 3: Privacidade e hacking Ningu\u00e9m sai \u00e0s ruas grudando nas paredes e posts as fotos de suas viagens, festas em que foi, ou refei\u00e7\u00f5es que fez. Contudo, muitos n\u00e3o se incomodam em faz\u00ea-lo na Internet, local com at\u00e9 mais visibilidade que os postes da sua cidade. Ao escancarar os detalhes da sua vida na Internet, voc\u00ea est\u00e1 abrindo m\u00e3o da sua \"privacidade digital\". Privacidade Digital A privacidade digital \u00e9 a habilidade de uma pessoa em controlar a exposi\u00e7\u00e3o e a disponibilidade de informa\u00e7\u00f5es seja dela, de um conhecido ou at\u00e9 mesmo de um desconhecido, na internet, atrav\u00e9s dos sites de compartilhamento e redes sociais. A atual arquitetura da internet permite o desenvolvimento de novas tecnologias de controle de informa\u00e7\u00f5es, alterando a forma de como cada pessoa v\u00ea a privacidade. Por mais que ache normal abrir m\u00e3o do controle dos seus dados, do ponto de vista de desenvolvedor de sistemas de informa\u00e7\u00e3o, \u00e9 importante saber que a legisla\u00e7\u00e3o brasileira protege o direito \u00e0 privacidade digital de todos os cidad\u00e3os. A Lei Geral da Prote\u00e7\u00e3o dos Dados dita que nenhuma empresa deveria manter mais informa\u00e7\u00f5es sobre seus usu\u00e1rios do que \u00e9 necess\u00e1rio para prover o servi\u00e7o em quest\u00e3o, e que os dados mantidos devem ser protegidos por mecanismos de seguran\u00e7a que garantam sua inviolabilidade. E esteja certo, h\u00e1 sempre aqueles que tentar\u00e3o obter estes dados para usar das mais diferentes formas, por meio de hacking, engenharia social, e roubo de dados, e n\u00e3o somente dados relativos a pessoas, mas tamb\u00e9m dados de processos industriais, movimenta\u00e7\u00f5es banc\u00e1rias e por a\u00ed vai. Neste semin\u00e1rio, voc\u00ea dever\u00e1 abordar as quest\u00f5es privacidade digital, entrar em detalhes sobre o que exige a lei e quais as puni\u00e7\u00f5es caso seja violada. Voc\u00ea tamb\u00e9m dever\u00e1 discutir conceitos e t\u00e9cnicas relacionadas \u00e0 viola\u00e7\u00e3o de dados. Em suma, voc\u00ea dever\u00e1 discutir, sem se limitar a, os seguintes t\u00f3picos: Hacking Defini\u00e7\u00e3o? Bom ou mau? Variantes? T\u00e9cnicas Black/White/Gray hat Hacking \u00e9tico Exemplos? O que diz a legisla\u00e7\u00e3o brasileira O que \u00e9 privacidade de dados O que s\u00e3o dados pessoais? Como garant\u00ed-la O que diz a legisla\u00e7\u00e3o brasileira. O direito ao esquecimento Como material inicial, veja The 'Internet of Things' Is Sending Us Back to the Middle Ages Lei Geral da Prote\u00e7\u00e3o dos Dados Mesa Redonda Sobre LGPD Webmin\u00e1rio: Tudo sobre a LGPD Tema 4: Ass\u00e9dio Quando no meio profissional, voc\u00ea certamente e infelizmente ter\u00e1 \"oportunidades\" de presenciar ou vivenciar ass\u00e9dio, ou seja, comportamento indevido, geralmente repetitivo, que visa diminuir, ofender, obter vantagens da pessoa assediada. Voc\u00eas precisam ent\u00e3o saber como identificar, se defender, defender seus pares, e porqu\u00ea n\u00e3o praticar ass\u00e9dio. Neste semin\u00e1rio, voc\u00ea dever\u00e1 ent\u00e3o abordar os seguintes t\u00f3picos, sem se limitar a: Ass\u00e9dio Ass\u00e9dio sexual Ass\u00e9dio moral Efeitos nos assediados Alvos Legisla\u00e7\u00e3o Ciberbullying. Para facilitar seu trabalho, sugiro os seguintes materias abaixo como ponto de partida. Cartilha Cartilha Cartilha That's harassment Ass\u00e9dio sexual no Vale do Sil\u00edcio Tema 5: Rela\u00e7\u00f5es raciais e de g\u00eanero no trabalho. O Brasil \u00e9 um pa\u00eds marcado pela desigualdade, em v\u00e1rios aspectos da sociedade, e esta desigualdade reflete e alimenta a discrimina\u00e7\u00e3o das pessoas. H\u00e1 a discrimina\u00e7\u00e3o por profiss\u00e3o, que coloca profissionais de uma \u00e1rea como meros cidad\u00e3os, abaixo dos que s\u00e3o \"engenheiro civil formado\" e outros \"dot\u00f4s\". H\u00e1 a discrimina\u00e7\u00e3o pela diferen\u00e7a de g\u00eanero. H\u00e1 a discrimina\u00e7\u00e3o por cor da pele . H\u00e1 a discrimina\u00e7\u00e3o por origem geogr\u00e1fica( https://noticias.uol.com.br/cotidiano/ultimas-noticias/2016/02/24/negros-e-nordestinos-sao-principais-vitimas-de-discriminacao-em-sp.htm ) H\u00e1 tamb\u00e9m por orienta\u00e7\u00e3o sexual. Op\u00e7\u00e3o religiosa Enfim, o Brasil \u00e9 rico nestes problemas, e todos eles refletem no mercado de trabalho. Neste semin\u00e1rio, voc\u00ea dever\u00e1 abordar esta tem\u00e1tica, tocando nos seguintes t\u00f3picos, sem se limitar aos mesmos: Conceito de ra\u00e7a e Ra\u00e7a entre humanos Cis, trans, homo, hetero, g\u00eanero? Diferen\u00e7as intelectuais entre \u201cra\u00e7as\u201d e g\u00eaneros Mulheres importantes na computa\u00e7\u00e3o O que diz a legisla\u00e7\u00e3o brasileira? Para iniciar seu trabalho, sugiro os links acima e a seguinte lista. Sexismo no vale do sil\u00edcio Quotas no ensino superior Segrega\u00e7\u00e3o ocupacional e hiato salarial entre os g\u00eaneros Atividade Ass\u00edncrona: Computa\u00e7\u00e3o e Sociedade Os v\u00e1rios ramos da computa\u00e7\u00e3o, estando presentes cada vez mais na vida das pessoas, certamente podem afetar positiva e negativamente estas vidas. Assim, \u00e9 importante pensar sobre como nossas atua\u00e7\u00f5es como \"computeiros\" impactam a sociedade ao nosso redor, a despeito da sociedade entender o que fazemos ou n\u00e3o Para dar alguns exemplos simples e bem pr\u00f3ximos, pensemos na quantidade de dados pessoais que as redes sociais acumulam. Voc\u00ea, ao criar sua conta do Facebook ou Instagram, leu os termos de servi\u00e7o? Sabe quais dados podem ser gravados e com quem podem ser compartilhados? A frase seguinte descreve bem a situa\u00e7\u00e3o: Se voc\u00ea n\u00e3o est\u00e1 pagando pelo produto, ent\u00e3o o produto \u00e9 voc\u00ea! Em praticamente todos os servi\u00e7os de redes sociais, todas as sua intera\u00e7\u00f5es s\u00e3o gravadas e usadas para montar seu perfil, que ser\u00e1 colocado em grupos usados para direcionar an\u00fancios e campanhas. Por mais que voc\u00ea possa se achar especial, saiba que somos muito, muito previs\u00edveis e que podemos ser facilmente manipulados. Para ver um grande exemplo disso, pense nas campanhas pol\u00edticas de 2016 nos estados unidos e 2018 no Brasil. Milhares de mensagens direcionadas os eleitores indecisos serviram para virar a balan\u00e7a para um lado ou para outro, como \u00e9 muito bem documentado em \"Big Hack\", dispon\u00edvel no Netflix. Mas para al\u00e9m dos perfis das redes sociais, a tecnologia poder\u00e1 afetar nossa vida de outras formas tamb\u00e9m muito importantes. Ela permite a gera\u00e7\u00e3o e processamento de imagens m\u00e9dicas de forma a melhorar diagn\u00f3sticos, permite cirurgias a longa dist\u00e2ncia, o entretenimento no conforto da sua casa, o relacionamento com outrem, o aumento da efici\u00eancia dos neg\u00f3cios, a otimiza\u00e7\u00e3o de transportes, etcetera . Infelizmente, parece que toda tecnologia com potencial para uso ben\u00e9fico \u00e0 sociedade, tamb\u00e9m pode ser usada em seu detrimento. Por exemplo, as IA (Intelig\u00eancias Artificiais) sendo treinadas por dados classificados por humanos, perseverar\u00e3o divis\u00f5es sociais, desigualdades e discrimina\u00e7\u00f5es. Steven Levy discute esta ideia muito bem no artigo We Asked for Flying Cars. We Got Axl Rose's Twitter Spat . Na fic\u00e7\u00e3o, vemos v\u00e1rios exemplos destas reviravoltas. Em espec\u00edfico, o epis\u00f3dio Black Mirror (Season 3): Nosedive fala muito bem sobre como a tecnologia, neste caso em espec\u00edfico as redes sociais que s\u00e3o muito presentes em nossas vidas, tem o potencial de alterar a forma como nos comunicamos, compartilhamos informa\u00e7\u00e3o, e somos classificadados em nossa sociedade. Outro exemplo, o filme Minority Report fala sobre como uma tecnologia para a preven\u00e7\u00e3o de crimes pode ser usada para cercear a liberdade das pessoas. Apesar do futurismo do v\u00eddeos, situa\u00e7\u00f5es exatamente como estas j\u00e1 est\u00e3o acontecendo, como se pode ver em Facial recognition, data harvesting and the end of privacy Facing Up to Facial Recognition Police Unlock AI's Potential to Monitor, Surveil and Solve Crimes Embora o reconhecimento facial receba grande parte da aten\u00e7\u00e3o , h\u00e1 v\u00e1rios outros exemplos de tecnologia sendo usada em detrimento da sociedade, n\u00e3o por erro do julgamento, mas por direta a\u00e7\u00e3o de engenheiros, administradores e desenvolvedores de software , \u00e9 o caso da Volkswagen, documentado no Epis\u00f3dio 1, Temporada 1, de Dirty Money , no Netflix. Fontes sobre o mesmo assunto abundam, por exemplo Volkswagen emissions scandal Felizmente, h\u00e1 tamb\u00e9m rea\u00e7\u00f5es dos seus colegas de profiss\u00e3o, como visto na iniciativa Ethical OS , que discutiremos nas pr\u00f3ximas semanas. Semana 2 - 19/08/2020 Antes de falarmos sobre os pontos e materiais vistos na atividade ass\u00edncrona da semana 1, vamos definir um arcabou\u00e7o te\u00f3rico para falarmos sobre o certo e o errado na exerc\u00edcio da profiss\u00e3o. \u00c9tica x Moral A palavra \u00e9tica vem do grego \u00e9thos , que significa \"costume\", segundo o Priberam , mas a conota\u00e7\u00e3o que nos interessa aqui \u00e9 mais restrita. \u00c9tica Conjunto de regras de conduta de um indiv\u00edduo ou de um grupo. \"\u00e9tica\", in Dicion\u00e1rio Priberam da L\u00edngua Portuguesa, 2008-2020 Este conjunto de regras evolue com os tempos, refletindo a sociedade que as gera. Entretanto, a \u00e9tica segue princ\u00edpios universais que deveriam ser atemporais. Refor\u00e7ando, deveriam ser atemporais, mas s\u00e3o reflexo da sociedade que as gera, que escolhe como agir. Segundo Cortella , a \u00e9tica \u00e9 o conjunto de princ\u00edpios e valores que usamos para decidir a nossa conduta social. O comportamento gerado no contexto da \u00e9tica \u00e9 chamado moral , isto \u00e9, a materializa\u00e7\u00e3o da \u00e9tica em pr\u00e1ticas, e que refletem muito a cultura em que se desenvolve. A moral \u00e9 mais vol\u00e1til. Poder\u00edamos dizer que a moral \"aspira\" ser a \u00e9tica, mas que esta aspira\u00e7\u00e3o est\u00e1 longe de ser alcan\u00e7ada, se n\u00e3o for intang\u00edvel. Por exemplo, podemos pensar facilmente em a\u00e7\u00f5es que, consideradas morais muito recentemente, hoje s\u00e3o consideradas aberra\u00e7\u00f5es, pelo menos em algumas sociedades. Castra\u00e7\u00e3o feminina Pena de morte para ad\u00falteros Deuteron\u00f4mio 22:22 - Se um homem for pego em flagrante deitado com a mulher de outro, os dois dever\u00e3o pagar por esse delito com pena de morte, o homem e a mulher com quem se deitou. Desse modo extirpar\u00e1s o mal do meio do teu povo, \u00f3 Israel. Escravagismo \u00caxodo 21:1-6 - Estes s\u00e3o os estatutos que lhes propor\u00e1s: Se comprares um servo hebreu, seis anos servir\u00e1; mas ao s\u00e9timo sair\u00e1 forro, de gra\u00e7a. Se entrar sozinho, sozinho sair\u00e1; se tiver mulher, ent\u00e3o com ele sair\u00e1 sua mulher. Se seu senhor lhe houver dado uma mulher e ela lhe houver dado filhos ou filhas, a mulher e os filhos dela ser\u00e3o de seu senhor e ele sair\u00e1 sozinho. Mas se esse servo expressamente disser: \u201cEu amo a meu senhor, a minha mulher e a meus filhos, n\u00e3o quero sair forro\u201d, ent\u00e3o seu senhor o levar\u00e1 perante os juizes, e o far\u00e1 chegar porta, ou ao umbral da porta, e o seu senhor lhe furar\u00e1 a orelha com uma sovela; e ele o servir\u00e1 para sempre. Casamento com menores de idade - Converse com seus pais e av\u00f3s sobre o assunto. \u00c9 muito poss\u00edvel que uma de suas ancestrais recentes tenha \"se casado\" com 13 ou 14 anos de idade. Assim, embora a Moral varie e \u00c9tica n\u00e3o, como sociedade, o que consideramos \u00e9tico nada mais \u00e9 que moral, e certamente ir\u00e1 mudar no futuro. Por exemplo, quem garante que no futuro n\u00e3o ser\u00e1 considerado (por todos) que comer carne \u00e9 uma abomina\u00e7\u00e3o? Logo, doravante, quando falarmos de \u00e9tica, lembre-se que estamos falando na verdade do que achamos ser \u00e9tico hoje, isto \u00e9, moral. Se voc\u00ea ficou mais confuso que esclarecido, teremos um oportunidade de em um futuro pr\u00f3ximo esclarecer estas d\u00favidas com um especilista na \u00e1rea. Por enquanto, para melhor entender o que \u00e9 \u00e9tico, pode ser \u00fatil ver alguns exemplos do que obviamente n\u00e3o \u00e9, em v\u00e1rias situa\u00e7\u00f5es. Exemplos de falta de \u00e9tica na vida Achar uma carteira com dinheiro, pegar o dinheiro e jogar a carteira fora, sem ter feito um esfor\u00e7o sincero para encontrar o dono. Comer o lanche do seu colega de rep\u00fablica, sem autoriza\u00e7\u00e3o. Violar acordo de monogamia. Algo interessante sobre o \u00faltimo ponto acima \u00e9 que embora para maior o acordo seja entre duas partes, muitos considerar\u00e3o que o acordo \u00e9 com a sociedade. Este seria tamb\u00e9m um exemplo interessante para falar sobre hipocrisia, mas deixaremos isso para outro momento. J\u00e1 outros exemplos s\u00e3o mais complicados. Se eu te perguntar se \u00e9 anti-\u00e9tico cobrar 5000 reais por uma p\u00e1gina Web feita no Word, voc\u00ea provavelmente diria que n\u00e3o, afinal, desde que voc\u00ea esteja entregando o produto e seu cliente esteja disposto a pagar, ent\u00e3o tudo bem, certo? Mas e se seu cliente n\u00e3o tiver op\u00e7\u00e3o ou se n\u00e3o tiver informa\u00e7\u00e3o o suficiente para detectar que est\u00e1 sendo explorado, ainda assim \u00e9 \u00e9tico cobrar tal valor? Vejamos um caso real com uma ideia parecida: Pharma Bro In September 2015, Shkreli received widespread criticism when Turing obtained the manufacturing license for the antiparasitic drug Daraprim and raised its price by a factor of 56 (from US$13.5 to $750 per pill), leading him to be referred to by the media as \"the most hated man in America\" and \"Pharma Bro\" ( Fonte ) Este exemplo, onde um rem\u00e9dio teve seu pre\u00e7o aumentado de 13 para 750 D\u00f3lares, por p\u00edlula, d\u00e9cadas depois de ter sido inventado, e com processo de fabrica\u00e7\u00e3o simples, reprodut\u00edvel por adolescentes , \u00e9 excelente para indicar uma idiossincrazia da sociedade capitalista. Enquanto dif\u00edcilmente algu\u00e9m considerar\u00e1 o aumento \u00e9tico, a relativiza\u00e7\u00e3o do que \u00e9 errado e certo \u00e9 muito comum em nossa sociedade. Vejamos alguns exemplos na universidade, mais pr\u00f3ximos de n\u00f3s, e muito bem apontados neste blog . Exemplos de falta de \u00e9tica na Universidade \"Copia lista de exerc\u00edcio para conseguir se formar sem esfor\u00e7o e critica vagabundo por n\u00e3o arrumar uma enxada e ir capinar um terreno.\" \"Pede para o colega assinar a lista de presen\u00e7a e depois critica funcion\u00e1rio fantasma.\" \"Cola nas provas e grita \"abaixo a corrup\u00e7\u00e3o!\" na pr\u00f3xima manifesta\u00e7\u00e3o.\" Embora os exemplos aqui sejam de a\u00e7\u00f5es n\u00e3o \u00e9ticas dos alunos, \u00e9 \u00f3bvio que h\u00e1 problemas do lado da universidade tamb\u00e9m, em v\u00e1rios n\u00edveis. Exemplos de falta de \u00e9tica na Universidade Professores da UFRGS s\u00e3o presos por fraude em bolsas de estudo . Envolvidos em fraude no vestibular da UFU devem ressarcir cofres p\u00fablicos MPF/MG: professor universit\u00e1rio com dedica\u00e7\u00e3o exclusiva n\u00e3o pode exercer outra atividade remunerada Professor falta e n\u00e3o rep\u00f5e com outra atividade ou aula Este \u00faltimo exemplo n\u00e3o d\u00e1 manchete no jornal porqu\u00ea os alunos preferem n\u00e3o ter a aula reposta, n\u00e3o \u00e9 mesmo? Mas sabemos que \u00e9 errado. \u00c9tica no Exerc\u00edcio da Profiss\u00e3o O comportamento anti\u00e9tico se estende aos postos de trabalho, obviamente, onde funcion\u00e1rios n\u00e3o cumprem hor\u00e1rios, chefes assumem os m\u00e9ritos dos trabalho de seus subalternos, sabotagens abundam e discrimina\u00e7\u00e3o \u00e9 algo constante. Para minimizar atos anti\u00e9ticos como estes, diversas profiss\u00f5es produzem c\u00f3digos de \u00e9tica , manuais gerais de conduta no exerc\u00edcio da profiss\u00e3o. Um dos exemplos mais famosos \u00e9 o c\u00f3digo da medicina, publicizado na m\u00eddia. O famoso Juramento de Hip\u00f3crates parece ser um e universal, mas como poderia? Obviamente o mesmo sofreu altera\u00e7\u00f5es com a passagem do tempo e espalhamento pelo mundo. Veja a seguinte vers\u00e3o, que contem partes que obviamente deixaram de ser v\u00e1lidas e outras que nem precisariam ser ditas. Juramento de Hip\u00f3crates Eu juro, por Apolo, m\u00e9dico, por Escul\u00e1pio, Higeia e Panaceia, e tomo por testemunhas todos os deuses e todas as deusas , cumprir, segundo meu poder e minha raz\u00e3o, a promessa que se segue: Estimar, tanto quanto a meus pais, aquele que me ensinou esta arte; fazer vida comum e, se necess\u00e1rio for, com ele partilhar meus bens ; Ter seus filhos por meus pr\u00f3prios irm\u00e3os; ensinar-lhes esta arte, se eles tiverem necessidade de aprend\u00ea-la, sem remunera\u00e7\u00e3o e nem compromisso escrito; fazer participar dos preceitos, das li\u00e7\u00f5es e de todo o resto do ensino, meus filhos, os de meu mestre e os disc\u00edpulos inscritos segundo os regulamentos da profiss\u00e3o, por\u00e9m, s\u00f3 a estes. Aplicarei os regimes para o bem do doente segundo o meu poder e entendimento, nunca para causar dano ou mal a algu\u00e9m . A ningu\u00e9m darei por comprazer, nem rem\u00e9dio mortal nem um conselho que induza a perda. Do mesmo modo n\u00e3o darei a nenhuma mulher uma subst\u00e2ncia abortiva . Conservarei imaculada minha vida e minha arte. N\u00e3o praticarei a talha, mesmo sobre um calculoso confirmado; deixarei essa opera\u00e7\u00e3o aos pr\u00e1ticos que disso cuidam. Em toda a casa, a\u00ed entrarei para o bem dos doentes, mantendo-me longe de todo o dano volunt\u00e1rio e de toda a sedu\u00e7\u00e3o sobretudo longe dos prazeres do amor, com as mulheres ou com os homens livres ou escravizados . \u00c0quilo que no exerc\u00edcio ou fora do exerc\u00edcio da profiss\u00e3o e no conv\u00edvio da sociedade, eu tiver visto ou ouvido, que n\u00e3o seja preciso divulgar, eu conservarei inteiramente secreto. Se eu cumprir este juramento com fidelidade, que me seja dado gozar felizmente da vida e da minha profiss\u00e3o, honrado para sempre entre os homens; se eu dele me afastar ou infringir, o contr\u00e1rio aconte\u00e7a. levantar fonte. Este juramento tem seus m\u00e9ritos mas \u00e9 rid\u00edculo em alguns pontos, como bem apontado por Dr\u00e1uzio Varella . A vers\u00e3o seguinte, mais recente, faz mais sentido. Juramento de Hip\u00f3crates Prometo que, ao exercer a arte de curar, mostrar-me-ei sempre fiel aos preceitos da honestidade, da caridade e da ci\u00eancia. Penetrando no interior dos lares, meus olhos ser\u00e3o cegos, minha l\u00edngua calar\u00e1 os segredos que me forem revelados, o que terei como preceito de honra. Nunca me servirei da minha profiss\u00e3o para corromper os costumes ou favorecer o crime. Se eu cumprir este juramento com fidelidade, goze eu para sempre a minha vida e a minha arte com boa reputa\u00e7\u00e3o entre os homens; se o infringir ou dele afastar-me, suceda-me o contr\u00e1rio. levantar fonte. Ainda assim \u00e9 estranho fazer um juramento para fazer seu trabalho corretamente. Imagine-se jurando que minimizar\u00e1 bugs no seu c\u00f3digo e n\u00e3o acessar\u00e1 dados indevidamente. N\u00e3o, o juramento de Hip\u00f3crates \u00e9 mais para ingl\u00eas os pais verem que para servir como c\u00f3digo de \u00e9tica. O verdadeiro c\u00f3digo de \u00e9tica da Medicina no Brasil \u00e9 estabelecido pelo conselho federal de medicina e \u00e9 bem mais extenso. \u00c9tica na Computa\u00e7\u00e3o J\u00e1 na computa\u00e7\u00e3o, como fica a quest\u00e3o da \u00e9tica profissional? N\u00e3o h\u00e1, no Brazil, um c\u00f3digo de \u00e9tica estabelecido pelo Conselho Federal dos Computeiros, at\u00e9 por qu\u00ea n\u00e3o h\u00e1 um reconhecimento dos \"computeiros\" como uma classe profissional como \u00e9 o caso dos m\u00e9dicos. Na computa\u00e7\u00e3o, entra quem quiser, e fica quem se mostrar habilitado, tenha se formado em ci\u00eancia da computa\u00e7\u00e3o, engenharia el\u00e9trica, sistemas de informa\u00e7\u00e3o, administra\u00e7\u00e3o de empresas ou educa\u00e7\u00e3o f\u00edsica, apesar de ser uma discuss\u00e3o antiga . Se n\u00e3o h\u00e1 defini\u00e7\u00e3o de quem pode atuar com computa\u00e7\u00e3o, h\u00e1 definitivamente muitos exemplos de falta de \u00e9tica na \u00e1rea. Como visto na atividade ass\u00edncrona, um sistema em parte software foi usado para enganar testes de emiss\u00e3o de poluentes por carros. Em um exemplo de \"ladr\u00e3o que rouba ladr\u00e3o\", o s\u00edtio Pirate Bay usava o computador de seus usu\u00e1rios para minerar cripto moedas. e o rob\u00f4 de limpeza Roomba estava coletando informa\u00e7\u00f5es sobre os interiores das casas, como quantidade de pessoas, marcas de produtos usados, mapa 3d do ambiente, e o fabricante poderia vender estas informa\u00e7\u00f5es para outras empresas. Em outro exemplo bem mais simples e comum, um desenvolvedor introduziu defeitos em seu software para ser convocado, e remunerado, para fazer corre\u00e7\u00f5es. Quer dizer que n\u00e3o h\u00e1 um c\u00f3digo de \u00e9tica a ser seguido na \u00e1rea? N\u00e3o \u00e9 exatamente o caso, pois a Sociedade Brasileira de Computa\u00e7\u00e3o , atrav\u00e9s de sua comiss\u00e3o de \u00e9tica, prop\u00f4s o seguinte c\u00f3digo de \u00e9tica profissional . C\u00f3digo de \u00c9tica do profissional de Inform\u00e1tica - SBC Art. 1\u00b0: Contribuir para o bem-estar social, promovendo, sempre que poss\u00edvel, a inclus\u00e3o de todos setores da sociedade. Art. 2\u00b0: Exercer o trabalho profissional com responsabilidade, dedica\u00e7\u00e3o, honestidade e justi\u00e7a, buscando sempre a melhor solu\u00e7\u00e3o. Art. 3\u00ba: Esfor\u00e7ar-se para adquirir continuamente compet\u00eancia t\u00e9cnica e profissional, mantendo-se sempre atualizado com os avan\u00e7os da profiss\u00e3o. Art. 4\u00ba: Atuar dentro dos limites de sua compet\u00eancia profissional e orientar-se por elevado esp\u00edrito p\u00fablico. Art. 5\u00ba: Guardar sigilo profissional das informa\u00e7\u00f5es a que tiver acesso em decorr\u00eancia das atividades exercidas. Art. 6\u00ba: Conduzir as atividades profissionais sem discrimina\u00e7\u00e3o, seja de ra\u00e7a, sexo, religi\u00e3o, nacionalidade, cor da pele, idade, estado civil ou qualquer outra condi\u00e7\u00e3o humana. Art. 7\u00ba: Respeitar a legisla\u00e7\u00e3o vigente, o interesse social e os direitos de terceiros. Art. 8\u00ba : Honrar compromissos, contratos, termos de responsabilidade, direitos de propriedade, copyrights e patentes. Art. 9\u00ba : Pautar sua rela\u00e7\u00e3o com os colegas de profiss\u00e3o nos princ\u00edpios de considera\u00e7\u00e3o, respeito, apre\u00e7o, solidariedade e da harmonia da classe. Art. 10\u00ba: N\u00e3o praticar atos que possam comprometer a honra, a dignidade, privacidade de qualquer pessoa. Art. 11\u00ba: Nunca apropriar-se de trabalho intelectual, iniciativas ou solu\u00e7\u00f5es encontradas por outras pessoas. Art. 12\u00ba: Zelar pelo cumprimento deste c\u00f3digo. Art. 13\u00ba: Reconhecer que qualquer viola\u00e7\u00e3o das normas deste c\u00f3digo \u00e9 incompat\u00edvel com sua associa\u00e7\u00e3o \u00e0 SBC. Vejamos como isso afeta a sua vida, considerando algumas situa\u00e7\u00f5es exemplo. Aplicando o c\u00f3digo de \u00e9tica da SBC Seu chefe lhe diz para modificar o pre\u00e7o de um item em um pedido enviado por um cliente. Seu colega sugere que voc\u00eas abram o banco de dados de mensagens SMS trocados pelo sistema de telefonia da empresa em que trabalha. Algu\u00e9m lhe oferece 50 reais para baixar a imagem do dvd do Windows 10 da Internet e instalar em seu (da pessoa) computador. Para garantir sua renda, introduz erros nos seus programas de forma que o empregador dependa de sua \"expertise\" Quais artigos do c\u00f3digo de \u00e9tica da SBC estes pedidos violam? Mesmo que voc\u00ea n\u00e3o v\u00e1 tatuar o c\u00f3digo de \u00e9tica proposto pela SBC nas costas ou recit\u00e1-lo tr\u00eas vezes antes de dormir, faz sentido seguir suas orienta\u00e7\u00f5es gerais, que s\u00e3o, agir corretamente para com a sociedade , a comunidade (seus colegas de profiss\u00e3o), e com seu empregador . Afinal, computa\u00e7\u00e3o certamente j\u00e1 causar\u00e1 problemas demais em nossas vidas, no processo de torn\u00e1-las melhor (veja dois exemplos a seguir). Ent\u00e3o, n\u00e3o \u00e9 necess\u00e1rio que n\u00f3s, os \"computeiros\", ajamos de m\u00e1 f\u00e9. Revis\u00e3o da Atividade Ass\u00edncrona da Semana 1 O que voc\u00eas acharam dos v\u00eddeos que falam sobre pr\u00e9-crime, ou o uso de IA para identificar crimes antes de acontecerem? Como fica a quest\u00e3o da privacidade? O pr\u00e9-julgamento pode afetar o resultado, levando a profecias auto-realizadoras? Como previnir que tecnologias sejam mal utilizadas? Atividade Ass\u00edncrona: Computa\u00e7\u00e3o e Sociedade Quanto mais a IA se desenvolve, maior \u00e9 seu potencial para nos auxiliar na tomada de decis\u00f5es em nossas vidas. Qual a melhor vacina para COVID-19? \u00c9 melhor o carro se desligar neste sem\u00e1foro e religar quando abrir ou manter o motor funcionando? Qual a melhor rota de entrega de encomendas? Dentre as respostas para estas perguntas, \u00e9 poss\u00edvel identificar aquela que \u00e9 melhor. Para a segunda, por exemplo, se a IA mandar desligar o motor para apenas um segundo depois eu ter que religar o carro, ent\u00e3o a resposta n\u00e3o foi boa e deve ser penalizada. Algumas perguntas, entretanto, s\u00e3o mais subjetivas. O comportamento desta pessoa, no parque, a meia-noite, \u00e9 suspeito? Qual o melhor candidato para esta vaga de emprego? Qual o melhor artigo para oferecer para leitura a este usu\u00e1rio? E nesta subjetividade, os vi\u00e9ses dos humanos s\u00e3o reproduzidos nas m\u00e1quinas. No seu feed do Facebook por exemplo, voc\u00ea deve receber muito mais not\u00edcias sobre as vigens de seus colegas que de recalls de BMW. Isso acontece porqu\u00ea o Facebook lhe oferece artigos que casam com seus interesses, levantados por anos de intera\u00e7\u00e3o com o sistema. Acontece que esta abordagem refor\u00e7a seus interesses e lhe mantem \u00e9 uma bolha. H\u00e1 v\u00e1rios casos documentados de vi\u00e9s no mundo da IA. O problema principal aqui \u00e9 que nossos vi\u00e9ses s\u00e3o reproduzidos sem nos darmos conta, e estes vi\u00e9ses poderiam ser a raz\u00e3o da nossa destrui\u00e7\u00e3o. Se voc\u00ea nunca se preocupou com destruir formigas, seres inferiores a voc\u00ea, por qu\u00ea uma IA deveria se importar com voc\u00ea, se lhe julgar inferior? E alguns certamente acham que seremos inferiores em algum momento. Eles certamente j\u00e1 jogam M\u00e1rio melhor que eu. Para previnir este desastre, isto \u00e9, que elas se tornem superiores, n\u00e3o que elas joguem M\u00e1rio melhor que n\u00f3s, alguns advogam que limitemos o poder das IA. O que voc\u00ea acha? Mesmo se limitarmos o poder de decis\u00e3o da AI em nossas vidas, algumas situa\u00e7\u00f5es certamente vir\u00e3o em um futuro pr\u00f3ximo. Por exemplo, vejamos alguns dos dilemas que ve\u00edculos auto dirig\u00edveis enfrentar\u00e3o. Como n\u00f3s, como desenvolvedores podemos ajudar, ou pelo menos n\u00e3o piorar, o futuro da humanidade? E se sobrar tempo, aprendam sobre HAL, no filme 2001 - Uma odiss\u00e9ia no espa\u00e7o . Semana 3 - 26/08/2020 Atividade S\u00edncrona Na palestra com o Prof. Sert\u00f3rio, do Instituto de Filosofia (IFILO) da UFU, vimos que a \u00e9tica \u00e9 na realidade o pensar sobre as rela\u00e7\u00f5es de grupo com um foco na qualifica\u00e7\u00e3o das intera\u00e7\u00f5es quanto a serem ben\u00e9ficas ao grupo. Atividade Ass\u00edncrona A atividade desta semana ser\u00e1 condesada com outra, no futuro pr\u00f3ximo. Semana 4 Atividade S\u00edncrona A palestra com Pedro Paulo Silveira , ex-aluno da FACOM e co-fundador e CTO da Recrutei, foi realmente inspiradora. Pedro compartilhou hist\u00f3rias de sucessos e diversos erros cometidos, mostrando que \u00e9 com insist\u00eancia que se consegue progredir como empreendedor. Al\u00e9m de empreender, isto \u00e9, montar sua pr\u00f3pria empresa e atacar algum problema ou, como dizem os profissionais do ramo, uma dor de um cliente, voc\u00ea tamb\u00e9m tem a op\u00e7\u00e3o de seguir algu\u00e9m, trabalhando em uma empresa. Enquanto muito julgam que isto \u00e9 ser apenas mais um dente na engrenagem, n\u00e3o h\u00e1 nada de mal em um carreira assim; tudo depende do seu perfil. Uma outra possibilidade \u00e9 a carreira acad\u00eamica, isto \u00e9, uma carreira voltada para o ensino das pr\u00f3ximas gera\u00e7\u00f5es de tecnologistas. \u00c9 seguindo esta carreira pelo menos inicialmente que voc\u00ea pode vir a se tornar um pesquisador, seja na academia (universidades) ou na ind\u00fastria, embora esta \u00faltima op\u00e7\u00e3o seja limitada no Brasil. Atividade Ass\u00edncrona A carreira de pesquisador Na atividade ass\u00edncrona desta semana, exploraremos um pouco a carreira acad\u00eamica, aproveitando a experi\u00eancia deste que vos fala escreve. Para come\u00e7armos, estando voc\u00eas inseridos no contexto acad\u00eamico, pelo menos temporariamente, \u00e9 natural que tenham ouvido os seguintes termos: p\u00f3s-gradua\u00e7\u00e3o mestrado doutorado PhD especializa\u00e7\u00e3o certifica\u00e7\u00e3o MBA Estes termos, todos relacionados pois o primeiro \u00e9 o termo geral usado para descrever os demais, precisam ser entendidos para se falar em carreira acad\u00eamica. Vejamos ent\u00e3o o que s\u00e3o as p\u00f3s-gradua\u00e7\u00f5es. P\u00f3s-gradua\u00e7\u00e3o O qu\u00ea e para qu\u00ea? Sem surpresas e sem piadas, uma p\u00f3s-gradua\u00e7\u00e3o \u00e9 um curso feito ap\u00f3s um curso de gradua\u00e7\u00e3o. Isto \u00e9, um curso que presume um conhecimento pr\u00e9vio adquirido em um curso de gradua\u00e7\u00e3o, como Sistemas de Informa\u00e7\u00e3o. O objetivo de um curso de p\u00f3s-gradua\u00e7\u00e3o \u00e9 lhe permitir se aprofundar em um t\u00f3pico, se especializando no mesmo, ou complementar a forma\u00e7\u00e3o obtida no curso de gradua\u00e7\u00e3o. Com um objetivo t\u00e3o amplo, \u00e9 \u00f3bvio que deve haver m\u00faltiplos tipos de p\u00f3s-gradua\u00e7\u00e3o, classificadas em dois tipos: lato sensu stricto sensu Os cursos stricto sensu s\u00e3o mais voltados para atua\u00e7\u00e3o na academia e pesquisa de forma geral. Em outras palavras, s\u00e3o pr\u00e9-requisitos para se atuar na doc\u00eancia no ensino superior e o caminho mais direto para se tornar um pesquisador. Este tipo de p\u00f3s-gradua\u00e7\u00e3o \u00e9 subdividido em dois tipos, oferecidos por universidades e, em n\u00famero menor, centros de pesquisa. O primeiro tipo \u00e9 o mestrado , um curso com dura\u00e7\u00e3o de 24 a 30 meses em que o estudante deve se aprofundar em t\u00f3picos de sua \u00e1rea de forma\u00e7\u00e3o 1 , al\u00e9m de aprender/aperfei\u00e7oar o uso do m\u00e9todo cient\u00edfico na resolu\u00e7\u00e3o de problemas. Ao final do mestrado, o estudante produz uma monografia que resume o trabalho \u00e9 denominado disserta\u00e7\u00e3o de mestrado (ou master thesis , nos pa\u00edses de l\u00edngua inglesa). O trabalho e a monografia devem ser defendidos diante de uma banca de doutores da \u00e1rea, demonstrando o conhecimento do estado da arte da \u00e1rea em desenvolveu seu trabalho, caraterizando o problema que atacou, e posicionando o seu trabalho em rela\u00e7\u00e3o ao estado da arte. Caso aprovado, o estudante recebe o t\u00edtulo de Mestre, por exemplo, Mestre em Ci\u00eancia da Computa\u00e7\u00e3o, Mestre em Engenharia Biom\u00e9dica, etc. O t\u00edtulo equivalente em l\u00edngua inglesa \u00e9 o Master of Science in ... De certa forma, o mestrado pode ser visto como uma inicia\u00e7\u00e3o cient\u00edfica mais avan\u00e7ada, isto \u00e9, um treinamento no m\u00e9todo cient\u00edfico envolvendo a identifica\u00e7\u00e3o de um problema, o estudo da bibliografia relacionada e a aplica\u00e7\u00e3o de resultados pr\u00e9vios de forma criativa. Nada impede que se v\u00e1 al\u00e9m da reprodu\u00e7\u00e3o de resultados e produza novo conhecimento relevante no mestrado. Contudo, a produ\u00e7\u00e3o de resultado significativo s\u00f3 \u00e9 pr\u00e9-requisito para aprova\u00e7\u00e3o no pr\u00f3ximo est\u00e1gio, o curso de doutorado. Assim, um doutorado tem dura\u00e7\u00e3o de 48 a 60 meses, nos quais o doutorando deve identificar um problema, possivelmente um novo problema, relevante, e produzir resultado significativo e in\u00e9dito, expandindo as fronteiras do conhecimento cient\u00edfico na \u00e1rea. Al\u00e9m disso, esta produ\u00e7\u00e3o deve ser feita de forma mais independente do orientador, pois ao final do doutorado o doutor deve estar apto a desenvolver novas pesquisas independentemente, embora colabora\u00e7\u00f5es sejam incentivadas. Para a obten\u00e7\u00e3o do t\u00edtulo, o doutorando deve produzir uma tese de doutorado (ou PhD dissertation ) e defend\u00ea-la perante uma banca de doutores, demostrando os requisitos mencionados acima. No caso de sucesso na defesa, o candidato recebe o t\u00edtulo de Doutor na \u00e1rea, no Brasil. Outros pa\u00edses tem t\u00edtulos equivalentes, como Philosophy Doctor , ou PhD, nos pa\u00edses de l\u00edngua inglesa. Normalmente o Doutorado deve ser precedido por um Mestrado, mas algumas institui\u00e7\u00f5es permitem o ingresso no doutorado diretamente, para candidatos excepcionais. Embora eu n\u00e3o tenha estat\u00edsticas concretas em m\u00e3os, meu sentimento \u00e9 que \u00e9 mais comum o insucesso nesta modaliddae que na normal. Tanto o mestrado quanto o doutorado podem ser do tipo profissional ou acad\u00eamico , sendo que o doutorado profissional n\u00e3o \u00e9 comum no Brasil. Os do tipo profissional s\u00e3o desenvolvidos em ou em parceria com empresas, atacando problemas reais destas, focando-se no desenvolvimento de prot\u00f3tipos e na r\u00e1pida transfer\u00eancia de conhecimento das universidades para a ind\u00fastria. J\u00e1 os do tipo acad\u00eamico s\u00e3o realizados nas universidades, sem necessariamente atacar um problema com aplicabilidade imediata; isto \u00e9 chamado de pesquisa b\u00e1sica, ou pesquisa pela pesquisa. Apesar do que se possa achar, boa parte dos avan\u00e7os tecnol\u00f3gicos que temos hoje s\u00f3 foram poss\u00edveis por causa de pesquisa b\u00e1sica Na FACOM, temos um programa de p\u00f3s-gradua\u00e7\u00e3o que oferece cursos de mestrado e doutorado acad\u00eamicos em Ci\u00eancida da Computa\u00e7\u00e3o. Apesar do nome dos cursos, graduados em \u00e1reas afins \u00e0 computa\u00e7\u00e3o s\u00e3o bem vindos e, de fato, v\u00e1rios ex-alunos do curso de Sistemas de Informa\u00e7\u00e3o j\u00e1 passaram pelo programa. Lato Sensu Enquanto os cursos stricto sensu buscam formar pesquisadores, cursos lato sensu visam acrescentar uma habilidade pr\u00e1tica bem mais imedidata no desenvolvimento das atividades profissionais. No Brasil, este tipo de p\u00f3s-gradua\u00e7\u00e3o se divide em dois tipos, aperfei\u00e7oamento e especializa\u00e7\u00e3o, basicamente pela dura\u00e7\u00e3o do curso. Enquanto os aperfei\u00e7oamentos tem dura\u00e7\u00e3o entre 180 e 359 horas de dura\u00e7\u00e3o, especializa\u00e7\u00f5es tem um m\u00ednimo de 360 hooras. Outra diferen\u00e7a importante \u00e9 que especializa\u00e7\u00f5es exigem a produ\u00e7\u00e3o de uma monografia de conclus\u00e3o de curso, enquanto o mesmo n\u00e3o \u00e9 verdade para aperfei\u00e7oamentos. Ao completar uma especializa\u00e7\u00e3o, o estudante recebe o t\u00edtulo de especialista, por exemplo, especialista em administra\u00e7\u00e3o de redes, se o curso feito for em administra\u00e7\u00e3o. Nenhum t\u00edtulo \u00e9 conferido no aperfei\u00e7oamento. Uma \"curiosidade\" importante \u00e9 que cr\u00e9ditos cr\u00e9ditos obtidos em programas de p\u00f3s-gradua\u00e7\u00e3o podem ser usados para obter t\u00edtulo de especialista, mesmo sem a apresenta\u00e7\u00e3o de uma monografia Outro termo muito em voga no mundo das qualifica\u00e7\u00f5es \u00e9 o MBA, master of business administration , que embora possa ser traduzido como \"mestrado em administra\u00e7\u00e3o de empresas\", no Brasil \u00e9 considerado uma especializa\u00e7\u00e3o. Al\u00e9m das p\u00f3s Assim como se pode fazer m\u00faltiplos cursos de gradua\u00e7\u00e3o, pode-se fazer tamb\u00e9m m\u00faltiplos de p\u00f3s. Contudo, embora seja comum m\u00faltiplas especializa\u00e7\u00f5es e aperfei\u00e7\u00f5amentos, dificilmente algu\u00e9m faria dois mestrados ou doutoramentos. Isto porqu\u00ea cursos stricto sensu s\u00e3o considerados uma escada, mestrado ap\u00f3s a gradua\u00e7\u00e3o e doutorado ap\u00f3s o mestrado, continuando uma linha do forma\u00e7\u00e3o rumo a uma carreira de pesquisador, e que um doutor est\u00e1 apto a estender seu conhecimento sozinho, e por isso novos cursos n\u00e3o fazem sentido. Alguns de voc\u00eas podem estar se perguntando o que \u00e9 um p\u00f3s-doutorado, se n\u00e3o um curso de \"p\u00f3s-p\u00f3s-gradua\u00e7\u00e3o\". A verdade \u00e9 que um p\u00f3s-doutorado \u00e9 apenas uma atividade tempor\u00e1ria (bico) para doutores (e.g, auxiliar de laborat\u00f3rio), um trabalho sem muito prest\u00edgio, para sobreviver at\u00e9 que se obtenha uma posi\u00e7\u00e3o de trabalho permanente, um emprego \"de verdade\". No Brasil, contudo, os p\u00f3s-doutorados s\u00e3o confundidos com est\u00e1gios de pesquisa usados por pesquisadores para estabelecer colabora\u00e7\u00f5es com outras institui\u00e7\u00f5es ou iniciar uma mudan\u00e7a de linha de pesquisa, tamb\u00e9m conhecido como sab\u00e1tico . \u00c9 por isso que de vez em quando alguns de nossos professores \"desaparecem\" por um ou dois anos pra fazer um post-doc . \u00c9 importante refor\u00e7ar que um p\u00f3s-doc, n\u00e3o sendo um curso, n\u00e3o confere um t\u00edtulo. Ningu\u00e9m \u00e9 \"p\u00f3s-doutor\" ou tem \"p\u00f3s-doutorado\" pela universide X. Se algu\u00e9m apresenta esta credencial, ou n\u00e3o entende o sistema, ou est\u00e1 tentando dar uma incrementada artificial no curr\u00edculo. Ent\u00e3o que dizer que o doutorado \u00e9 o fim da linha na carreira acad\u00eamica? Sim e n\u00e3o. H\u00e1 tamb\u00e9m a evolu\u00e7\u00e3o para o status de livre-docente e professor titular , conferido professores experientes e que demonstrem algumas qualidades via um concurso. No servi\u00e7o federal e, portanto, na UFU, n\u00e3o h\u00e1 a figura do livre-docente, mas n\u00f3s temos v\u00e1rios professores titulares, que tem no m\u00ednimo 18 anos na carreira docente e com carreira relevante em termos de ensino, pesquisa e administra\u00e7\u00e3o. Compensa? Mas para voc\u00eas que est\u00e3o ainda na gradua\u00e7\u00e3o, a pergunta que deve estar se formando em suas cabe\u00e7as \u00e9 fazer ou n\u00e3o uma p\u00f3s-gradua\u00e7\u00e3o? H\u00e1 dois aspectos importantes nesta quest\u00e3o, o financeiro e o do perfil profissional. Em termos financeiros, normalmente as p\u00f3s-gradua\u00e7\u00f5es adicionam um pr\u00eamio \u00e0 remunera\u00e7\u00e3o do profissional. Isto \u00e9, quanto mais p\u00f3s, mais qualificado e melhor remunerado o profissional. Contudo, embora aperfei\u00e7oamentos e especializa\u00e7\u00f5es possam ser feitos e conclu\u00eddos facilmente enquanto empregados, cursos stricto sensu s\u00e3o muito demandantes e podem exigir dedica\u00e7\u00e3o exclusiva. Assim, \u00e9 preciso considerar que enquanto \u00e9 verdade que ao final do curso \u00e9 poss\u00edvel que o profissional \"valha\" mais, tamb\u00e9m \u00e9 preciso considerar que o mesmo deixou de adquirir experi\u00eancia profissional durante o per\u00edodo em que fez o curso. Em uma pesquisa sobre diferen\u00e7as de sal\u00e1rio feita nos EUA, verificou-se que embora o mestrado geralmente compense em termos financeiros, o doutorado n\u00e3o compensa, pois a evolu\u00e7\u00e3o salarial obtida com 4 anos de experi\u00eancia \u00e9 maior que a obtida com o t\u00edtulo de doutor. Mas se este \u00e9 o caso, por qu\u00ea algu\u00e9m faria um doutorado? Basicamente, para se tornar um pesquisador, ou seja, pelo perfil da pessoa. Atua\u00e7\u00e3o Mas o que \u00e9 um pesquisador? Embora alguns insistam que o termo correto deveria ser cientista e que pesquisador \u00e9 algo simples de se tornar, acho que est\u00e1 claro que aqui nos referimos ao profissional que procura expandir o conhecimento cient\u00edfico por meio da busca por problemas relevantes e pela aplica\u00e7\u00e3o do m\u00e9todo cient\u00edfico. Dito isso, est\u00e1 dito tudo, mas se n\u00e3o, damos alguns apontadores para mais leituras: Academic Researcher Industrial Researcher Na pr\u00e1tica, em termos de Brasil, doutores est\u00e3o \"presos\" \u00e0s universidades, com raras exce\u00e7\u00f5es, pois se faz pouca pesquisa fora das mesmas. Assim, tornar-ser um doutor e atuar como pesquisador no Brasil implica quase sempre em ser tamb\u00e9m professor. Al\u00e9m disso, poucas universidades privadas fazem pesquisa e, logo, \u00e9 preciso pensar na Universidades Federais como destino maior dos doutores. J\u00e1 fora do pa\u00eds, a situa\u00e7\u00e3o \u00e9 outra, mais amig\u00e1vel a doutores na ind\u00fastria. Assim, fazer p\u00f3s gradua\u00e7\u00e3o ou n\u00e3o, eis a quest\u00e3o . Embora eu n\u00e3o possa te dar uma resposta, tanto eu quanto qualquer outro professor com quem tenha afinidade pode ser procurado para falar mais sobre os pr\u00f3s e contras da carreira, somando \u00e0s suas leituras e buscas para achar a resposta adequada a voc\u00ea. Para saber um pouco mais sobre a carreira de pesquisador ou, como fazem quest\u00e3o alguns, cientistas, assista ao seguinte v\u00eddeo (a parte interessante come\u00e7a em 19:10). Todo Expandir mais sobre a forma em que atua o pesquisador. Semana 5 Atividade S\u00edncrona Computa\u00e7\u00e3o Verde. Apresenta\u00e7\u00e3o dos alunos sobre tema computa\u00e7\u00e3o verde. A atividade foi gravada e est\u00e1 dispon\u00edvel no canal correspondente. Atividade Ass\u00edncrona Para esta semana, separei algumas leituras interessantes sobre como a tecnologia impacta nosso ambiente. O primeiro artigo descreve um experimento da Microsoft para usar o oceano como sistema de refrigeramento natural para datacenters submersos. O segundo fala sobre a retirada, h\u00e1 poucos dias, depois de dois anos, do container. Um fato muito interessante \u00e9 que o datacenter experimentou apenas \\frac{1}{8} \\frac{1}{8} das falhas que o datacenter que ficou em terra sofreu. Menos falhas, menos lixo. Microsoft tests a datacenter under the sea Project Natick underwater datacenter Enquanto iniciativas como esta da MS existem, se voc\u00ea pesquisar, ver\u00e1 que computa\u00e7\u00e3o verde foi um t\u00f3pico quente na segunda metade dos anos 2000 at\u00e9 a primeira metade dos anos 2010. A verdade \u00e9 que muitas iniciativas se enfraqueceram, como discutido no terceiro artigo. Green Computing Analysis Mas embora o buzz tenha sumido ou pelo menos diminuido, a verdade \u00e9 que muito esfor\u00e7o \u00e9 feito para infraestruturas computacionais eficientes, se n\u00e3o por raz\u00f5es ambientais, por econ\u00f4micas. Esta vis\u00e3o reflete muito na forma como datacenters s\u00e3o constru\u00eddos e operados para serem \"verdes\" . Esta \u00e9 uma das for\u00e7as por tr\u00e1s do Open Compute Project . Outra evid\u00eancia de que o verde ainda continua por a\u00ed \u00e9 o ESG, uma avalia\u00e7\u00e3o de empresas feitas por investidores para decidir se deve ou n\u00e3o investir na mesma. ESG \u00e9 a sigla em ingl\u00eas para Ambiente, Sociedade e Governan\u00e7a Semana 6 Atividade S\u00edncrona Propriedade Intelectual Apresenta\u00e7\u00e3o dos alunos sobre o tema \"Propriedade Intelectual\" A atividade foi gravada e est\u00e1 dispon\u00edvel no canal correspondente. Atividade Ass\u00edncrona Registro de Software Nesta atividade, complementaremos o conte\u00fado visto na apresenta\u00e7\u00e3o feita na atividade s\u00edncrona, nos focando em aspectos pr\u00e1ticos para quem \u00e9 da \u00e1rea de computa\u00e7\u00e3o. Apenas refor\u00e7ando, temos como principais conceitos e derivados os seguintes: graph TD A[Propriedade intelectual] --> B[Propriedade Industrial] --> E1[Patente] B --> E2[Marca] B --> E3[...] A[Propriedade intelectual] --> D[Direitor Autoral] --> E4[Direito Moral] D --> E5[Direto Patrimonial] Para uma revis\u00e3o destes conceitos, consulte os seguintes s\u00edtios: Notas introdut\u00f3rias sobre a propriedade intelectual Propriedade Intelectual - Portal da Ind\u00fastria Propriedade Intelectual: direitos morais e patrimoniais do autor Importante para n\u00f3s, \u00e9 o registro de Software, mecanismo pelo qual se facilida a garantia da propriedade intelectual sobre o software. Observe que o registro de software n\u00e3o \u00e9 uma forma de prote\u00e7\u00e3o da propriedade industrial pois um software, na legisla\u00e7\u00e3o brasileira, Lei 9609 , tamb\u00e9m conhecida como \"Lei do Software\", est\u00e1 mais para uma obra liter\u00e1ria que uma inven\u00e7\u00e3o. Duas observa\u00e7\u00f5es s\u00e3o importantes aqui. Primeiro, a lei deixa claro que o software desenvolvido no contexto de um contrato de servi\u00e7o, \u00e9 de propriedade do contratante, e n\u00e3o do desenvolvedor; n\u00e3o h\u00e1 nem mesmo o direito de ser reconhecido como autor. Segundo, se o software for parte de um sistema maior, composto tamb\u00e9m por hardware, ele pode ser inclu\u00eddo em uma patente para prote\u00e7\u00e3o da propriedade industrial. Al\u00e9m disso, \u00e9 importante que se saiba que uma patente pode ser requisitada em outras jurisdi\u00e7\u00f5es, como no United States Patent and Trademark Office ou equivalentes ao redor do mundo. Chamo \u00e0 aten\u00e7\u00e3o o Art. 6o da lei do software, que trata do pl\u00e1gio de software. A c\u00f3pia do c\u00f3digo indica claramente pl\u00e1gio, mas a c\u00f3pia da funcionalidade \u00e9 algo debat\u00edvel. Lei 9609 - Arg 6o, Inciso III a ocorr\u00eancia de semelhan\u00e7a de programa a outro, preexistente, quando se der por for\u00e7a das caracter\u00edsticas funcionais de sua aplica\u00e7\u00e3o, da observ\u00e2ncia de preceitos normativos e t\u00e9cnicos, ou de limita\u00e7\u00e3o de forma alternativa para a sua express\u00e3o; Ora, se um programa resolve o mesmo problema, de um mesmo dom\u00ednio, em um ambiente computacional semelhante, algumas caracter\u00edsticas ser\u00e3o semelhantes. O qu\u00e3o semelhante constitui pl\u00e1gio? Este \u00e9 um trabalho para o juiz da causa, que provavelmente n\u00e3o entende nada de computa\u00e7\u00e3o, determinar. Licen\u00e7as TODO Expandir motiva\u00e7\u00e3o sobre licen\u00e7as Para escolher uma licen\u00e7a para o seu software (ou mesmo outras cria\u00e7\u00f5es), use a ferramenta choose a license , que compara as principais. Caso estas n\u00e3o lhe atendam, ou caso queira entender o que outras licensas querem dizer, a Wikipedia tem um bom e vasto comparativo Semana 7 Atividade S\u00edncrona Apresenta\u00e7\u00e3o dos alunos sobre o tema \"Hacking e Privacidade\" A atividade foi gravada e est\u00e1 dispon\u00edvel no canal correspondente. Atividade Ass\u00edncrona Na atidadade ass\u00edncrona desta semana, voc\u00ea aprender\u00e1 um pouco mais sobre Teste de Penetra\u00e7\u00e3o :alert: Para aqueles que quiserem saber mais sobre hacking \u00e9tico, este curso introdut\u00f3rio tem 15 horas de dura\u00e7\u00e3o. Uma cartilha sobre a LGPD :alert: foi disponbilizada no canal do tema E, por recomenda\u00e7\u00e3o dos colegas, assisti ao filme The Social Dilemma :alert: que agora recomendo a voc\u00eas fortemente. Semana 8 Atividade S\u00edncrona Apresenta\u00e7\u00e3o dos alunos sobre o tema \"Ass\u00e9dio\" A atividade foi gravada e est\u00e1 dispon\u00edvel no canal correspondente. Atividade Ass\u00edncrona Semana 9 Atividade S\u00edncrona Atividade Ass\u00edncrona Material complementar Material extra, em v\u00e1rios t\u00f3picos Carreira Neste blog, discute-se o que \u00e9 esperado de profissionais em v\u00e1rios n\u00edveis de suas carreiras, do ponto de vista do recrutador. Se voc\u00ea sabe o que \u00e9 esperado, pode se preparar melhor. Checklist de avalia\u00e7\u00e3o de Desenvolvedores Junior X Senior Checklist de avaliac\u00e3o de desenvolvedor back-end Why software is eating the world LGPD LGPD em uma p\u00e1gina: ( pdf ) \u00c9tica na Computa\u00e7\u00e3o Center for Humane Technology Ethical OS \u00c9 poss\u00edvel, mas muito mais dif\u00edcil, ser aceito e completar um mestrado em \u00e1rea diferente da de sua forma\u00e7\u00e3o. \u21a9","title":"Profiss\u00e3o em SI - E1"},{"location":"teaching/gsi009/#profissao-em-sistemas-de-informacao","text":"O objetivo desta disciplina \u00e9 preparar os discentes para atuarem com consci\u00eancia, \u00e9tica e responsabilidade na sociedade em geral e em seus ambientes de trabalho, de forma emp\u00e1tica e respeitosa ao pr\u00f3ximo, independentemente de qualquer fator, e de forma a minimizar impactos negativos e maximizar os positivos da tecnologia da informa\u00e7\u00e3o na sociedade e no ambiente. Se est\u00e1 interessado na disciplina, na forma de AARE, matricule-se e continue lendo. Caso contr\u00e1rio, volte no pr\u00f3ximo semestre quando, possivelmente, teremos atividades presenciais. Lembre-se, GSI009 \u00e9 uma disciplina obrigat\u00f3ria do curr\u00edculo. Se est\u00e1 lendo isto, ent\u00e3o assumo que se matriculou; \u00f3timo! Sua primeira fonte de informa\u00e7\u00e3o sobre esta disciplina \u00e9 este s\u00edtio, que conter\u00e1 notas de aula, atividades e apontadores para outros documentos e instru\u00e7\u00f5es de acesso. Al\u00e9m disso, usaremos a ferramenta Teams \u2122 da Microsoft para nossos encontros s\u00edncronos, atendimento a alunos e para comunica\u00e7\u00e3o em geral. Ap\u00f3s criar sua conta usando o email da UFU , cadastre-se na disciplina aqui . O controle de frequ\u00eancia nas atividades s\u00edncronas ser\u00e1 feito pelo relat\u00f3rio de presen\u00e7a apresentado pelo Teams, que diz exatamente quando entrou e quando saiu da reuni\u00e3o. Nas atividades ass\u00edncronas, o controle ser\u00e1 feito pela submiss\u00e3o de respostas \u00e0s atividades propostas, como question\u00e1rios.","title":"Profiss\u00e3o em Sistemas de Informa\u00e7\u00e3o"},{"location":"teaching/gsi009/#semana-1-12082020","text":"","title":"Semana 1 - 12/08/2020"},{"location":"teaching/gsi009/#programa","text":"A disciplina abordar\u00e1 os t\u00f3picos definidos na ficha da disciplia, dispon\u00edvel no s\u00edtio do curso. O plano da disciplina, aula-a-aula est\u00e1 dispon\u00edvel aqui e na aba Arquivos no Teams.","title":"Programa"},{"location":"teaching/gsi009/#avaliacao","text":"Voc\u00eas ser\u00e3o avaliados de acordo com os crit\u00e9rios tamb\u00e9m dispon\u00edveis no plano. Para cada atividade do tipo X X , a nota N(X) N(X) da atividade ser\u00e1 calculada pela f\u00f3rmula N(X) = \\frac{N(X_1) + N(X_2) + ... + N(X_m)}{m} N(X) = \\frac{N(X_1) + N(X_2) + ... + N(X_m)}{m} onde N(X_i) N(X_i) \u00e9 a i i -\u00e9sima atividade do tipo X X , de um total de m m .","title":"Avalia\u00e7\u00e3o"},{"location":"teaching/gsi009/#atividades-assincronas","text":"Assista e leia a pelo menos os item marcados com o \u00edcone e ent\u00e3o responda aos question\u00e1rios da semana no Teams. Voc\u00ea deve cumprir as atividade at\u00e9 o fim do dia anterior ao da pr\u00f3xima atividade s\u00edncrona . Na \u00faltima semana, a atividade deve ser cumprida at\u00e9 a sexta-feira da mesma semana.","title":"Atividades Ass\u00edncronas"},{"location":"teaching/gsi009/#seminarios","text":"Os alunos dever\u00e3o apresentar semin\u00e1rios, desenvolvidos em grupo, para seus colegas. O objetivo dos semin\u00e1ris \u00e9 estimular discuss\u00e3o sobre o t\u00f3pico em tela. Para isso, planeje seu semin\u00e1rio para que tenha dura\u00e7\u00e3o de 75 minutos , incluindo discuss\u00e3o; este \u00e9 um crit\u00e9rio de avalia\u00e7\u00e3o . Os semin\u00e1rios tem t\u00f3picos T\u00e9cnicos e N\u00e3o t\u00e9cnicos ; por serem mais dif\u00edceis de se preparar, os n\u00e3o t\u00e9cnicos acontecer\u00e3o por \u00faltimo. A escolha do t\u00f3pico ser\u00e1, em princ\u00edpio, livre, desde que cada t\u00f3pico tenha um quinto dos alunos da turma. Caso isso n\u00e3o aconte\u00e7a, a os grupos ser\u00e3o impostos. Sua apresenta\u00e7\u00e3o ser\u00e1 avaliada nos seguintes pontos: Conte\u00fado: Contextualiza\u00e7\u00e3o Import\u00e2ncia para o profissional da \u00e1rea Legisla\u00e7\u00e3o pertinente Referencial te\u00f3rico Algo mais: discuss\u00e3o, v\u00eddeo, din\u00e2mica, pessoas importantes... Postar os slides 2 dias antes da apresenta\u00e7\u00e3o via Teams Qualidade dos slides Al\u00e9m da apresenta\u00e7\u00e3o, voc\u00ea dever\u00e1 preparar um question\u00e1rio com quest\u00f5es pertinentes ao tema e que sejam abordados durante a apresenta\u00e7\u00e3o. Estes ser\u00e3o avaliados pelos crit\u00e9rios a seguir: Qualidade do quiz Perguntas pertinentes a quem se interessar pela \u00e1rea Perguntas em portugu\u00eas correto Entregar Quiz 2 dias antes da apresenta\u00e7\u00e3o Enviar formul\u00e1rio no Teams, somente para o professor Enviar gabarito em mensagem separada, somente para o professor. Question\u00e1rio deve ter 5 perguntas de m\u00faltiplas alternativas Cada pergunta deve ter 5 respostas","title":"Semin\u00e1rios"},{"location":"teaching/gsi009/#atividade-assincrona-computacao-e-sociedade","text":"Os v\u00e1rios ramos da computa\u00e7\u00e3o, estando presentes cada vez mais na vida das pessoas, certamente podem afetar positiva e negativamente estas vidas. Assim, \u00e9 importante pensar sobre como nossas atua\u00e7\u00f5es como \"computeiros\" impactam a sociedade ao nosso redor, a despeito da sociedade entender o que fazemos ou n\u00e3o Para dar alguns exemplos simples e bem pr\u00f3ximos, pensemos na quantidade de dados pessoais que as redes sociais acumulam. Voc\u00ea, ao criar sua conta do Facebook ou Instagram, leu os termos de servi\u00e7o? Sabe quais dados podem ser gravados e com quem podem ser compartilhados? A frase seguinte descreve bem a situa\u00e7\u00e3o: Se voc\u00ea n\u00e3o est\u00e1 pagando pelo produto, ent\u00e3o o produto \u00e9 voc\u00ea! Em praticamente todos os servi\u00e7os de redes sociais, todas as sua intera\u00e7\u00f5es s\u00e3o gravadas e usadas para montar seu perfil, que ser\u00e1 colocado em grupos usados para direcionar an\u00fancios e campanhas. Por mais que voc\u00ea possa se achar especial, saiba que somos muito, muito previs\u00edveis e que podemos ser facilmente manipulados. Para ver um grande exemplo disso, pense nas campanhas pol\u00edticas de 2016 nos estados unidos e 2018 no Brasil. Milhares de mensagens direcionadas os eleitores indecisos serviram para virar a balan\u00e7a para um lado ou para outro, como \u00e9 muito bem documentado em \"Big Hack\", dispon\u00edvel no Netflix. Mas para al\u00e9m dos perfis das redes sociais, a tecnologia poder\u00e1 afetar nossa vida de outras formas tamb\u00e9m muito importantes. Ela permite a gera\u00e7\u00e3o e processamento de imagens m\u00e9dicas de forma a melhorar diagn\u00f3sticos, permite cirurgias a longa dist\u00e2ncia, o entretenimento no conforto da sua casa, o relacionamento com outrem, o aumento da efici\u00eancia dos neg\u00f3cios, a otimiza\u00e7\u00e3o de transportes, etcetera . Infelizmente, parece que toda tecnologia com potencial para uso ben\u00e9fico \u00e0 sociedade, tamb\u00e9m pode ser usada em seu detrimento. Por exemplo, as IA (Intelig\u00eancias Artificiais) sendo treinadas por dados classificados por humanos, perseverar\u00e3o divis\u00f5es sociais, desigualdades e discrimina\u00e7\u00f5es. Steven Levy discute esta ideia muito bem no artigo We Asked for Flying Cars. We Got Axl Rose's Twitter Spat . Na fic\u00e7\u00e3o, vemos v\u00e1rios exemplos destas reviravoltas. Em espec\u00edfico, o epis\u00f3dio Black Mirror (Season 3): Nosedive fala muito bem sobre como a tecnologia, neste caso em espec\u00edfico as redes sociais que s\u00e3o muito presentes em nossas vidas, tem o potencial de alterar a forma como nos comunicamos, compartilhamos informa\u00e7\u00e3o, e somos classificadados em nossa sociedade. Outro exemplo, o filme Minority Report fala sobre como uma tecnologia para a preven\u00e7\u00e3o de crimes pode ser usada para cercear a liberdade das pessoas. Apesar do futurismo do v\u00eddeos, situa\u00e7\u00f5es exatamente como estas j\u00e1 est\u00e3o acontecendo, como se pode ver em Facial recognition, data harvesting and the end of privacy Facing Up to Facial Recognition Police Unlock AI's Potential to Monitor, Surveil and Solve Crimes Embora o reconhecimento facial receba grande parte da aten\u00e7\u00e3o , h\u00e1 v\u00e1rios outros exemplos de tecnologia sendo usada em detrimento da sociedade, n\u00e3o por erro do julgamento, mas por direta a\u00e7\u00e3o de engenheiros, administradores e desenvolvedores de software , \u00e9 o caso da Volkswagen, documentado no Epis\u00f3dio 1, Temporada 1, de Dirty Money , no Netflix. Fontes sobre o mesmo assunto abundam, por exemplo Volkswagen emissions scandal Felizmente, h\u00e1 tamb\u00e9m rea\u00e7\u00f5es dos seus colegas de profiss\u00e3o, como visto na iniciativa Ethical OS , que discutiremos nas pr\u00f3ximas semanas.","title":"Atividade Ass\u00edncrona: Computa\u00e7\u00e3o e Sociedade"},{"location":"teaching/gsi009/#semana-2-19082020","text":"Antes de falarmos sobre os pontos e materiais vistos na atividade ass\u00edncrona da semana 1, vamos definir um arcabou\u00e7o te\u00f3rico para falarmos sobre o certo e o errado na exerc\u00edcio da profiss\u00e3o.","title":"Semana 2 - 19/08/2020"},{"location":"teaching/gsi009/#etica-x-moral","text":"A palavra \u00e9tica vem do grego \u00e9thos , que significa \"costume\", segundo o Priberam , mas a conota\u00e7\u00e3o que nos interessa aqui \u00e9 mais restrita. \u00c9tica Conjunto de regras de conduta de um indiv\u00edduo ou de um grupo. \"\u00e9tica\", in Dicion\u00e1rio Priberam da L\u00edngua Portuguesa, 2008-2020 Este conjunto de regras evolue com os tempos, refletindo a sociedade que as gera. Entretanto, a \u00e9tica segue princ\u00edpios universais que deveriam ser atemporais. Refor\u00e7ando, deveriam ser atemporais, mas s\u00e3o reflexo da sociedade que as gera, que escolhe como agir. Segundo Cortella , a \u00e9tica \u00e9 o conjunto de princ\u00edpios e valores que usamos para decidir a nossa conduta social. O comportamento gerado no contexto da \u00e9tica \u00e9 chamado moral , isto \u00e9, a materializa\u00e7\u00e3o da \u00e9tica em pr\u00e1ticas, e que refletem muito a cultura em que se desenvolve. A moral \u00e9 mais vol\u00e1til. Poder\u00edamos dizer que a moral \"aspira\" ser a \u00e9tica, mas que esta aspira\u00e7\u00e3o est\u00e1 longe de ser alcan\u00e7ada, se n\u00e3o for intang\u00edvel. Por exemplo, podemos pensar facilmente em a\u00e7\u00f5es que, consideradas morais muito recentemente, hoje s\u00e3o consideradas aberra\u00e7\u00f5es, pelo menos em algumas sociedades. Castra\u00e7\u00e3o feminina Pena de morte para ad\u00falteros Deuteron\u00f4mio 22:22 - Se um homem for pego em flagrante deitado com a mulher de outro, os dois dever\u00e3o pagar por esse delito com pena de morte, o homem e a mulher com quem se deitou. Desse modo extirpar\u00e1s o mal do meio do teu povo, \u00f3 Israel. Escravagismo \u00caxodo 21:1-6 - Estes s\u00e3o os estatutos que lhes propor\u00e1s: Se comprares um servo hebreu, seis anos servir\u00e1; mas ao s\u00e9timo sair\u00e1 forro, de gra\u00e7a. Se entrar sozinho, sozinho sair\u00e1; se tiver mulher, ent\u00e3o com ele sair\u00e1 sua mulher. Se seu senhor lhe houver dado uma mulher e ela lhe houver dado filhos ou filhas, a mulher e os filhos dela ser\u00e3o de seu senhor e ele sair\u00e1 sozinho. Mas se esse servo expressamente disser: \u201cEu amo a meu senhor, a minha mulher e a meus filhos, n\u00e3o quero sair forro\u201d, ent\u00e3o seu senhor o levar\u00e1 perante os juizes, e o far\u00e1 chegar porta, ou ao umbral da porta, e o seu senhor lhe furar\u00e1 a orelha com uma sovela; e ele o servir\u00e1 para sempre. Casamento com menores de idade - Converse com seus pais e av\u00f3s sobre o assunto. \u00c9 muito poss\u00edvel que uma de suas ancestrais recentes tenha \"se casado\" com 13 ou 14 anos de idade. Assim, embora a Moral varie e \u00c9tica n\u00e3o, como sociedade, o que consideramos \u00e9tico nada mais \u00e9 que moral, e certamente ir\u00e1 mudar no futuro. Por exemplo, quem garante que no futuro n\u00e3o ser\u00e1 considerado (por todos) que comer carne \u00e9 uma abomina\u00e7\u00e3o? Logo, doravante, quando falarmos de \u00e9tica, lembre-se que estamos falando na verdade do que achamos ser \u00e9tico hoje, isto \u00e9, moral. Se voc\u00ea ficou mais confuso que esclarecido, teremos um oportunidade de em um futuro pr\u00f3ximo esclarecer estas d\u00favidas com um especilista na \u00e1rea. Por enquanto, para melhor entender o que \u00e9 \u00e9tico, pode ser \u00fatil ver alguns exemplos do que obviamente n\u00e3o \u00e9, em v\u00e1rias situa\u00e7\u00f5es. Exemplos de falta de \u00e9tica na vida Achar uma carteira com dinheiro, pegar o dinheiro e jogar a carteira fora, sem ter feito um esfor\u00e7o sincero para encontrar o dono. Comer o lanche do seu colega de rep\u00fablica, sem autoriza\u00e7\u00e3o. Violar acordo de monogamia. Algo interessante sobre o \u00faltimo ponto acima \u00e9 que embora para maior o acordo seja entre duas partes, muitos considerar\u00e3o que o acordo \u00e9 com a sociedade. Este seria tamb\u00e9m um exemplo interessante para falar sobre hipocrisia, mas deixaremos isso para outro momento. J\u00e1 outros exemplos s\u00e3o mais complicados. Se eu te perguntar se \u00e9 anti-\u00e9tico cobrar 5000 reais por uma p\u00e1gina Web feita no Word, voc\u00ea provavelmente diria que n\u00e3o, afinal, desde que voc\u00ea esteja entregando o produto e seu cliente esteja disposto a pagar, ent\u00e3o tudo bem, certo? Mas e se seu cliente n\u00e3o tiver op\u00e7\u00e3o ou se n\u00e3o tiver informa\u00e7\u00e3o o suficiente para detectar que est\u00e1 sendo explorado, ainda assim \u00e9 \u00e9tico cobrar tal valor? Vejamos um caso real com uma ideia parecida: Pharma Bro In September 2015, Shkreli received widespread criticism when Turing obtained the manufacturing license for the antiparasitic drug Daraprim and raised its price by a factor of 56 (from US$13.5 to $750 per pill), leading him to be referred to by the media as \"the most hated man in America\" and \"Pharma Bro\" ( Fonte ) Este exemplo, onde um rem\u00e9dio teve seu pre\u00e7o aumentado de 13 para 750 D\u00f3lares, por p\u00edlula, d\u00e9cadas depois de ter sido inventado, e com processo de fabrica\u00e7\u00e3o simples, reprodut\u00edvel por adolescentes , \u00e9 excelente para indicar uma idiossincrazia da sociedade capitalista. Enquanto dif\u00edcilmente algu\u00e9m considerar\u00e1 o aumento \u00e9tico, a relativiza\u00e7\u00e3o do que \u00e9 errado e certo \u00e9 muito comum em nossa sociedade. Vejamos alguns exemplos na universidade, mais pr\u00f3ximos de n\u00f3s, e muito bem apontados neste blog . Exemplos de falta de \u00e9tica na Universidade \"Copia lista de exerc\u00edcio para conseguir se formar sem esfor\u00e7o e critica vagabundo por n\u00e3o arrumar uma enxada e ir capinar um terreno.\" \"Pede para o colega assinar a lista de presen\u00e7a e depois critica funcion\u00e1rio fantasma.\" \"Cola nas provas e grita \"abaixo a corrup\u00e7\u00e3o!\" na pr\u00f3xima manifesta\u00e7\u00e3o.\" Embora os exemplos aqui sejam de a\u00e7\u00f5es n\u00e3o \u00e9ticas dos alunos, \u00e9 \u00f3bvio que h\u00e1 problemas do lado da universidade tamb\u00e9m, em v\u00e1rios n\u00edveis. Exemplos de falta de \u00e9tica na Universidade Professores da UFRGS s\u00e3o presos por fraude em bolsas de estudo . Envolvidos em fraude no vestibular da UFU devem ressarcir cofres p\u00fablicos MPF/MG: professor universit\u00e1rio com dedica\u00e7\u00e3o exclusiva n\u00e3o pode exercer outra atividade remunerada Professor falta e n\u00e3o rep\u00f5e com outra atividade ou aula Este \u00faltimo exemplo n\u00e3o d\u00e1 manchete no jornal porqu\u00ea os alunos preferem n\u00e3o ter a aula reposta, n\u00e3o \u00e9 mesmo? Mas sabemos que \u00e9 errado.","title":"\u00c9tica x Moral"},{"location":"teaching/gsi009/#etica-no-exercicio-da-profissao","text":"O comportamento anti\u00e9tico se estende aos postos de trabalho, obviamente, onde funcion\u00e1rios n\u00e3o cumprem hor\u00e1rios, chefes assumem os m\u00e9ritos dos trabalho de seus subalternos, sabotagens abundam e discrimina\u00e7\u00e3o \u00e9 algo constante. Para minimizar atos anti\u00e9ticos como estes, diversas profiss\u00f5es produzem c\u00f3digos de \u00e9tica , manuais gerais de conduta no exerc\u00edcio da profiss\u00e3o. Um dos exemplos mais famosos \u00e9 o c\u00f3digo da medicina, publicizado na m\u00eddia. O famoso Juramento de Hip\u00f3crates parece ser um e universal, mas como poderia? Obviamente o mesmo sofreu altera\u00e7\u00f5es com a passagem do tempo e espalhamento pelo mundo. Veja a seguinte vers\u00e3o, que contem partes que obviamente deixaram de ser v\u00e1lidas e outras que nem precisariam ser ditas. Juramento de Hip\u00f3crates Eu juro, por Apolo, m\u00e9dico, por Escul\u00e1pio, Higeia e Panaceia, e tomo por testemunhas todos os deuses e todas as deusas , cumprir, segundo meu poder e minha raz\u00e3o, a promessa que se segue: Estimar, tanto quanto a meus pais, aquele que me ensinou esta arte; fazer vida comum e, se necess\u00e1rio for, com ele partilhar meus bens ; Ter seus filhos por meus pr\u00f3prios irm\u00e3os; ensinar-lhes esta arte, se eles tiverem necessidade de aprend\u00ea-la, sem remunera\u00e7\u00e3o e nem compromisso escrito; fazer participar dos preceitos, das li\u00e7\u00f5es e de todo o resto do ensino, meus filhos, os de meu mestre e os disc\u00edpulos inscritos segundo os regulamentos da profiss\u00e3o, por\u00e9m, s\u00f3 a estes. Aplicarei os regimes para o bem do doente segundo o meu poder e entendimento, nunca para causar dano ou mal a algu\u00e9m . A ningu\u00e9m darei por comprazer, nem rem\u00e9dio mortal nem um conselho que induza a perda. Do mesmo modo n\u00e3o darei a nenhuma mulher uma subst\u00e2ncia abortiva . Conservarei imaculada minha vida e minha arte. N\u00e3o praticarei a talha, mesmo sobre um calculoso confirmado; deixarei essa opera\u00e7\u00e3o aos pr\u00e1ticos que disso cuidam. Em toda a casa, a\u00ed entrarei para o bem dos doentes, mantendo-me longe de todo o dano volunt\u00e1rio e de toda a sedu\u00e7\u00e3o sobretudo longe dos prazeres do amor, com as mulheres ou com os homens livres ou escravizados . \u00c0quilo que no exerc\u00edcio ou fora do exerc\u00edcio da profiss\u00e3o e no conv\u00edvio da sociedade, eu tiver visto ou ouvido, que n\u00e3o seja preciso divulgar, eu conservarei inteiramente secreto. Se eu cumprir este juramento com fidelidade, que me seja dado gozar felizmente da vida e da minha profiss\u00e3o, honrado para sempre entre os homens; se eu dele me afastar ou infringir, o contr\u00e1rio aconte\u00e7a. levantar fonte. Este juramento tem seus m\u00e9ritos mas \u00e9 rid\u00edculo em alguns pontos, como bem apontado por Dr\u00e1uzio Varella . A vers\u00e3o seguinte, mais recente, faz mais sentido. Juramento de Hip\u00f3crates Prometo que, ao exercer a arte de curar, mostrar-me-ei sempre fiel aos preceitos da honestidade, da caridade e da ci\u00eancia. Penetrando no interior dos lares, meus olhos ser\u00e3o cegos, minha l\u00edngua calar\u00e1 os segredos que me forem revelados, o que terei como preceito de honra. Nunca me servirei da minha profiss\u00e3o para corromper os costumes ou favorecer o crime. Se eu cumprir este juramento com fidelidade, goze eu para sempre a minha vida e a minha arte com boa reputa\u00e7\u00e3o entre os homens; se o infringir ou dele afastar-me, suceda-me o contr\u00e1rio. levantar fonte. Ainda assim \u00e9 estranho fazer um juramento para fazer seu trabalho corretamente. Imagine-se jurando que minimizar\u00e1 bugs no seu c\u00f3digo e n\u00e3o acessar\u00e1 dados indevidamente. N\u00e3o, o juramento de Hip\u00f3crates \u00e9 mais para ingl\u00eas os pais verem que para servir como c\u00f3digo de \u00e9tica. O verdadeiro c\u00f3digo de \u00e9tica da Medicina no Brasil \u00e9 estabelecido pelo conselho federal de medicina e \u00e9 bem mais extenso.","title":"\u00c9tica no Exerc\u00edcio da Profiss\u00e3o"},{"location":"teaching/gsi009/#etica-na-computacao","text":"J\u00e1 na computa\u00e7\u00e3o, como fica a quest\u00e3o da \u00e9tica profissional? N\u00e3o h\u00e1, no Brazil, um c\u00f3digo de \u00e9tica estabelecido pelo Conselho Federal dos Computeiros, at\u00e9 por qu\u00ea n\u00e3o h\u00e1 um reconhecimento dos \"computeiros\" como uma classe profissional como \u00e9 o caso dos m\u00e9dicos. Na computa\u00e7\u00e3o, entra quem quiser, e fica quem se mostrar habilitado, tenha se formado em ci\u00eancia da computa\u00e7\u00e3o, engenharia el\u00e9trica, sistemas de informa\u00e7\u00e3o, administra\u00e7\u00e3o de empresas ou educa\u00e7\u00e3o f\u00edsica, apesar de ser uma discuss\u00e3o antiga . Se n\u00e3o h\u00e1 defini\u00e7\u00e3o de quem pode atuar com computa\u00e7\u00e3o, h\u00e1 definitivamente muitos exemplos de falta de \u00e9tica na \u00e1rea. Como visto na atividade ass\u00edncrona, um sistema em parte software foi usado para enganar testes de emiss\u00e3o de poluentes por carros. Em um exemplo de \"ladr\u00e3o que rouba ladr\u00e3o\", o s\u00edtio Pirate Bay usava o computador de seus usu\u00e1rios para minerar cripto moedas. e o rob\u00f4 de limpeza Roomba estava coletando informa\u00e7\u00f5es sobre os interiores das casas, como quantidade de pessoas, marcas de produtos usados, mapa 3d do ambiente, e o fabricante poderia vender estas informa\u00e7\u00f5es para outras empresas. Em outro exemplo bem mais simples e comum, um desenvolvedor introduziu defeitos em seu software para ser convocado, e remunerado, para fazer corre\u00e7\u00f5es. Quer dizer que n\u00e3o h\u00e1 um c\u00f3digo de \u00e9tica a ser seguido na \u00e1rea? N\u00e3o \u00e9 exatamente o caso, pois a Sociedade Brasileira de Computa\u00e7\u00e3o , atrav\u00e9s de sua comiss\u00e3o de \u00e9tica, prop\u00f4s o seguinte c\u00f3digo de \u00e9tica profissional . C\u00f3digo de \u00c9tica do profissional de Inform\u00e1tica - SBC Art. 1\u00b0: Contribuir para o bem-estar social, promovendo, sempre que poss\u00edvel, a inclus\u00e3o de todos setores da sociedade. Art. 2\u00b0: Exercer o trabalho profissional com responsabilidade, dedica\u00e7\u00e3o, honestidade e justi\u00e7a, buscando sempre a melhor solu\u00e7\u00e3o. Art. 3\u00ba: Esfor\u00e7ar-se para adquirir continuamente compet\u00eancia t\u00e9cnica e profissional, mantendo-se sempre atualizado com os avan\u00e7os da profiss\u00e3o. Art. 4\u00ba: Atuar dentro dos limites de sua compet\u00eancia profissional e orientar-se por elevado esp\u00edrito p\u00fablico. Art. 5\u00ba: Guardar sigilo profissional das informa\u00e7\u00f5es a que tiver acesso em decorr\u00eancia das atividades exercidas. Art. 6\u00ba: Conduzir as atividades profissionais sem discrimina\u00e7\u00e3o, seja de ra\u00e7a, sexo, religi\u00e3o, nacionalidade, cor da pele, idade, estado civil ou qualquer outra condi\u00e7\u00e3o humana. Art. 7\u00ba: Respeitar a legisla\u00e7\u00e3o vigente, o interesse social e os direitos de terceiros. Art. 8\u00ba : Honrar compromissos, contratos, termos de responsabilidade, direitos de propriedade, copyrights e patentes. Art. 9\u00ba : Pautar sua rela\u00e7\u00e3o com os colegas de profiss\u00e3o nos princ\u00edpios de considera\u00e7\u00e3o, respeito, apre\u00e7o, solidariedade e da harmonia da classe. Art. 10\u00ba: N\u00e3o praticar atos que possam comprometer a honra, a dignidade, privacidade de qualquer pessoa. Art. 11\u00ba: Nunca apropriar-se de trabalho intelectual, iniciativas ou solu\u00e7\u00f5es encontradas por outras pessoas. Art. 12\u00ba: Zelar pelo cumprimento deste c\u00f3digo. Art. 13\u00ba: Reconhecer que qualquer viola\u00e7\u00e3o das normas deste c\u00f3digo \u00e9 incompat\u00edvel com sua associa\u00e7\u00e3o \u00e0 SBC. Vejamos como isso afeta a sua vida, considerando algumas situa\u00e7\u00f5es exemplo. Aplicando o c\u00f3digo de \u00e9tica da SBC Seu chefe lhe diz para modificar o pre\u00e7o de um item em um pedido enviado por um cliente. Seu colega sugere que voc\u00eas abram o banco de dados de mensagens SMS trocados pelo sistema de telefonia da empresa em que trabalha. Algu\u00e9m lhe oferece 50 reais para baixar a imagem do dvd do Windows 10 da Internet e instalar em seu (da pessoa) computador. Para garantir sua renda, introduz erros nos seus programas de forma que o empregador dependa de sua \"expertise\" Quais artigos do c\u00f3digo de \u00e9tica da SBC estes pedidos violam? Mesmo que voc\u00ea n\u00e3o v\u00e1 tatuar o c\u00f3digo de \u00e9tica proposto pela SBC nas costas ou recit\u00e1-lo tr\u00eas vezes antes de dormir, faz sentido seguir suas orienta\u00e7\u00f5es gerais, que s\u00e3o, agir corretamente para com a sociedade , a comunidade (seus colegas de profiss\u00e3o), e com seu empregador . Afinal, computa\u00e7\u00e3o certamente j\u00e1 causar\u00e1 problemas demais em nossas vidas, no processo de torn\u00e1-las melhor (veja dois exemplos a seguir). Ent\u00e3o, n\u00e3o \u00e9 necess\u00e1rio que n\u00f3s, os \"computeiros\", ajamos de m\u00e1 f\u00e9.","title":"\u00c9tica na Computa\u00e7\u00e3o"},{"location":"teaching/gsi009/#revisao-da-atividade-assincrona-da-semana-1","text":"O que voc\u00eas acharam dos v\u00eddeos que falam sobre pr\u00e9-crime, ou o uso de IA para identificar crimes antes de acontecerem? Como fica a quest\u00e3o da privacidade? O pr\u00e9-julgamento pode afetar o resultado, levando a profecias auto-realizadoras? Como previnir que tecnologias sejam mal utilizadas?","title":"Revis\u00e3o da Atividade Ass\u00edncrona da Semana 1"},{"location":"teaching/gsi009/#atividade-assincrona-computacao-e-sociedade_1","text":"Quanto mais a IA se desenvolve, maior \u00e9 seu potencial para nos auxiliar na tomada de decis\u00f5es em nossas vidas. Qual a melhor vacina para COVID-19? \u00c9 melhor o carro se desligar neste sem\u00e1foro e religar quando abrir ou manter o motor funcionando? Qual a melhor rota de entrega de encomendas? Dentre as respostas para estas perguntas, \u00e9 poss\u00edvel identificar aquela que \u00e9 melhor. Para a segunda, por exemplo, se a IA mandar desligar o motor para apenas um segundo depois eu ter que religar o carro, ent\u00e3o a resposta n\u00e3o foi boa e deve ser penalizada. Algumas perguntas, entretanto, s\u00e3o mais subjetivas. O comportamento desta pessoa, no parque, a meia-noite, \u00e9 suspeito? Qual o melhor candidato para esta vaga de emprego? Qual o melhor artigo para oferecer para leitura a este usu\u00e1rio? E nesta subjetividade, os vi\u00e9ses dos humanos s\u00e3o reproduzidos nas m\u00e1quinas. No seu feed do Facebook por exemplo, voc\u00ea deve receber muito mais not\u00edcias sobre as vigens de seus colegas que de recalls de BMW. Isso acontece porqu\u00ea o Facebook lhe oferece artigos que casam com seus interesses, levantados por anos de intera\u00e7\u00e3o com o sistema. Acontece que esta abordagem refor\u00e7a seus interesses e lhe mantem \u00e9 uma bolha. H\u00e1 v\u00e1rios casos documentados de vi\u00e9s no mundo da IA. O problema principal aqui \u00e9 que nossos vi\u00e9ses s\u00e3o reproduzidos sem nos darmos conta, e estes vi\u00e9ses poderiam ser a raz\u00e3o da nossa destrui\u00e7\u00e3o. Se voc\u00ea nunca se preocupou com destruir formigas, seres inferiores a voc\u00ea, por qu\u00ea uma IA deveria se importar com voc\u00ea, se lhe julgar inferior? E alguns certamente acham que seremos inferiores em algum momento. Eles certamente j\u00e1 jogam M\u00e1rio melhor que eu. Para previnir este desastre, isto \u00e9, que elas se tornem superiores, n\u00e3o que elas joguem M\u00e1rio melhor que n\u00f3s, alguns advogam que limitemos o poder das IA. O que voc\u00ea acha? Mesmo se limitarmos o poder de decis\u00e3o da AI em nossas vidas, algumas situa\u00e7\u00f5es certamente vir\u00e3o em um futuro pr\u00f3ximo. Por exemplo, vejamos alguns dos dilemas que ve\u00edculos auto dirig\u00edveis enfrentar\u00e3o. Como n\u00f3s, como desenvolvedores podemos ajudar, ou pelo menos n\u00e3o piorar, o futuro da humanidade? E se sobrar tempo, aprendam sobre HAL, no filme 2001 - Uma odiss\u00e9ia no espa\u00e7o .","title":"Atividade Ass\u00edncrona: Computa\u00e7\u00e3o e Sociedade"},{"location":"teaching/gsi009/#semana-3-26082020","text":"","title":"Semana 3 - 26/08/2020"},{"location":"teaching/gsi009/#atividade-sincrona","text":"Na palestra com o Prof. Sert\u00f3rio, do Instituto de Filosofia (IFILO) da UFU, vimos que a \u00e9tica \u00e9 na realidade o pensar sobre as rela\u00e7\u00f5es de grupo com um foco na qualifica\u00e7\u00e3o das intera\u00e7\u00f5es quanto a serem ben\u00e9ficas ao grupo.","title":"Atividade S\u00edncrona"},{"location":"teaching/gsi009/#atividade-assincrona","text":"A atividade desta semana ser\u00e1 condesada com outra, no futuro pr\u00f3ximo.","title":"Atividade Ass\u00edncrona"},{"location":"teaching/gsi009/#semana-4","text":"","title":"Semana 4"},{"location":"teaching/gsi009/#atividade-sincrona_1","text":"A palestra com Pedro Paulo Silveira , ex-aluno da FACOM e co-fundador e CTO da Recrutei, foi realmente inspiradora. Pedro compartilhou hist\u00f3rias de sucessos e diversos erros cometidos, mostrando que \u00e9 com insist\u00eancia que se consegue progredir como empreendedor. Al\u00e9m de empreender, isto \u00e9, montar sua pr\u00f3pria empresa e atacar algum problema ou, como dizem os profissionais do ramo, uma dor de um cliente, voc\u00ea tamb\u00e9m tem a op\u00e7\u00e3o de seguir algu\u00e9m, trabalhando em uma empresa. Enquanto muito julgam que isto \u00e9 ser apenas mais um dente na engrenagem, n\u00e3o h\u00e1 nada de mal em um carreira assim; tudo depende do seu perfil. Uma outra possibilidade \u00e9 a carreira acad\u00eamica, isto \u00e9, uma carreira voltada para o ensino das pr\u00f3ximas gera\u00e7\u00f5es de tecnologistas. \u00c9 seguindo esta carreira pelo menos inicialmente que voc\u00ea pode vir a se tornar um pesquisador, seja na academia (universidades) ou na ind\u00fastria, embora esta \u00faltima op\u00e7\u00e3o seja limitada no Brasil.","title":"Atividade S\u00edncrona"},{"location":"teaching/gsi009/#atividade-assincrona_1","text":"","title":"Atividade Ass\u00edncrona"},{"location":"teaching/gsi009/#semana-5","text":"","title":"Semana 5"},{"location":"teaching/gsi009/#atividade-sincrona_2","text":"","title":"Atividade S\u00edncrona"},{"location":"teaching/gsi009/#atividade-assincrona_2","text":"Para esta semana, separei algumas leituras interessantes sobre como a tecnologia impacta nosso ambiente. O primeiro artigo descreve um experimento da Microsoft para usar o oceano como sistema de refrigeramento natural para datacenters submersos. O segundo fala sobre a retirada, h\u00e1 poucos dias, depois de dois anos, do container. Um fato muito interessante \u00e9 que o datacenter experimentou apenas \\frac{1}{8} \\frac{1}{8} das falhas que o datacenter que ficou em terra sofreu. Menos falhas, menos lixo. Microsoft tests a datacenter under the sea Project Natick underwater datacenter Enquanto iniciativas como esta da MS existem, se voc\u00ea pesquisar, ver\u00e1 que computa\u00e7\u00e3o verde foi um t\u00f3pico quente na segunda metade dos anos 2000 at\u00e9 a primeira metade dos anos 2010. A verdade \u00e9 que muitas iniciativas se enfraqueceram, como discutido no terceiro artigo. Green Computing Analysis Mas embora o buzz tenha sumido ou pelo menos diminuido, a verdade \u00e9 que muito esfor\u00e7o \u00e9 feito para infraestruturas computacionais eficientes, se n\u00e3o por raz\u00f5es ambientais, por econ\u00f4micas. Esta vis\u00e3o reflete muito na forma como datacenters s\u00e3o constru\u00eddos e operados para serem \"verdes\" . Esta \u00e9 uma das for\u00e7as por tr\u00e1s do Open Compute Project . Outra evid\u00eancia de que o verde ainda continua por a\u00ed \u00e9 o ESG, uma avalia\u00e7\u00e3o de empresas feitas por investidores para decidir se deve ou n\u00e3o investir na mesma. ESG \u00e9 a sigla em ingl\u00eas para Ambiente, Sociedade e Governan\u00e7a","title":"Atividade Ass\u00edncrona"},{"location":"teaching/gsi009/#semana-6","text":"","title":"Semana 6"},{"location":"teaching/gsi009/#atividade-sincrona_3","text":"","title":"Atividade S\u00edncrona"},{"location":"teaching/gsi009/#atividade-assincrona_3","text":"","title":"Atividade Ass\u00edncrona"},{"location":"teaching/gsi009/#semana-7","text":"","title":"Semana 7"},{"location":"teaching/gsi009/#atividade-sincrona_4","text":"Apresenta\u00e7\u00e3o dos alunos sobre o tema \"Hacking e Privacidade\" A atividade foi gravada e est\u00e1 dispon\u00edvel no canal correspondente.","title":"Atividade S\u00edncrona"},{"location":"teaching/gsi009/#atividade-assincrona_4","text":"Na atidadade ass\u00edncrona desta semana, voc\u00ea aprender\u00e1 um pouco mais sobre Teste de Penetra\u00e7\u00e3o :alert: Para aqueles que quiserem saber mais sobre hacking \u00e9tico, este curso introdut\u00f3rio tem 15 horas de dura\u00e7\u00e3o. Uma cartilha sobre a LGPD :alert: foi disponbilizada no canal do tema E, por recomenda\u00e7\u00e3o dos colegas, assisti ao filme The Social Dilemma :alert: que agora recomendo a voc\u00eas fortemente.","title":"Atividade Ass\u00edncrona"},{"location":"teaching/gsi009/#semana-8","text":"","title":"Semana 8"},{"location":"teaching/gsi009/#atividade-sincrona_5","text":"Apresenta\u00e7\u00e3o dos alunos sobre o tema \"Ass\u00e9dio\" A atividade foi gravada e est\u00e1 dispon\u00edvel no canal correspondente.","title":"Atividade S\u00edncrona"},{"location":"teaching/gsi009/#atividade-assincrona_5","text":"","title":"Atividade Ass\u00edncrona"},{"location":"teaching/gsi009/#semana-9","text":"","title":"Semana 9"},{"location":"teaching/gsi009/#atividade-sincrona_6","text":"","title":"Atividade S\u00edncrona"},{"location":"teaching/gsi009/#atividade-assincrona_6","text":"","title":"Atividade Ass\u00edncrona"},{"location":"teaching/gsi009/#material-complementar","text":"Material extra, em v\u00e1rios t\u00f3picos","title":"Material complementar"},{"location":"teaching/gsi009/#carreira","text":"Neste blog, discute-se o que \u00e9 esperado de profissionais em v\u00e1rios n\u00edveis de suas carreiras, do ponto de vista do recrutador. Se voc\u00ea sabe o que \u00e9 esperado, pode se preparar melhor. Checklist de avalia\u00e7\u00e3o de Desenvolvedores Junior X Senior Checklist de avaliac\u00e3o de desenvolvedor back-end Why software is eating the world","title":"Carreira"},{"location":"teaching/gsi009/#lgpd","text":"LGPD em uma p\u00e1gina: ( pdf )","title":"LGPD"},{"location":"teaching/gsi009/#etica-na-computacao_1","text":"Center for Humane Technology Ethical OS \u00c9 poss\u00edvel, mas muito mais dif\u00edcil, ser aceito e completar um mestrado em \u00e1rea diferente da de sua forma\u00e7\u00e3o. \u21a9","title":"\u00c9tica na Computa\u00e7\u00e3o"},{"location":"teaching/gsi009/_draft/index_aare1/","text":"Palestra: Processo seletivo em Inform\u00e1tica layout: notes title: Palestra 2 output: true part: 3 layout: notes title: Palestra 3 output: true part: 3 layout: notes title: Palestra 4 output: true part: 3 layout: notes title: Palestra 5 output: true part: 3 Convidado layout: notes title: Palestra 6 output: true part: 3 Convidado layout: notes title: Encerramento output: true part: 4","title":"Palestra - Processo seletivo em Inform\u00e1tica"}]}